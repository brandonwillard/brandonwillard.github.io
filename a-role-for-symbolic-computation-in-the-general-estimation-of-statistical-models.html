<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>A Role for Symbolic Computation in the General Estimation of Statistical Models - Brandon T. Willard</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="https://brandonwillard.github.io/a-role-for-symbolic-computation-in-the-general-estimation-of-statistical-models.html">

        <meta name="author" content="Brandon T. Willard" />

        <meta property="og:site_name" content="Brandon T. Willard" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="A Role for Symbolic Computation in the General Estimation of Statistical Models"/>
        <meta property="og:url" content="https://brandonwillard.github.io/a-role-for-symbolic-computation-in-the-general-estimation-of-statistical-models.html"/>
        <meta property="og:description" content=""/>
        <meta property="article:published_time" content="2017-01-18" />
            <meta property="article:section" content="articles" />
            <meta property="article:author" content="Brandon T. Willard" />



    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://brandonwillard.github.io/theme/css/bootstrap.readable.min.css" type="text/css"/>
    <link href="https://brandonwillard.github.io/theme/css/font-awesome.min.css" rel="stylesheet">
    <link href="https://brandonwillard.github.io/theme/css/academicons.min.css" rel="stylesheet">

    <link href="https://brandonwillard.github.io/theme/css/pygments/vim.css" rel="stylesheet">
    <link rel="stylesheet" href="https://brandonwillard.github.io/theme/css/style.css" type="text/css"/>
        <link href="https://brandonwillard.github.io/extra/custom.css" rel="stylesheet">

        <link href="https://brandonwillard.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Brandon T. Willard ATOM Feed"/>

        <link href="https://brandonwillard.github.io/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="Brandon T. Willard RSS Feed"/>
        <link href="https://brandonwillard.github.io/feeds/articles.atom.xml" type="application/atom+xml" rel="alternate"
              title="Brandon T. Willard articles ATOM Feed"/>
</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://brandonwillard.github.io/" class="navbar-brand">
Brandon T. Willard            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                         <li><a href="https://brandonwillard.github.io/pages/publications.html">
                             Publications
                          </a></li>
                         <li><a href="https://brandonwillard.github.io/pages/projects.html">
                             Projects
                          </a></li>
                         <li><a href="https://brandonwillard.github.io/pages/about.html">
                             About
                          </a></li>
                        <li class="active">
                            <a href="https://brandonwillard.github.io/category/articles.html">Articles</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<!-- Banner -->
<!-- End Banner -->

<!-- Content Container -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="https://brandonwillard.github.io/a-role-for-symbolic-computation-in-the-general-estimation-of-statistical-models.html"
                       rel="bookmark"
                       title="Permalink to A Role for Symbolic Computation in the General Estimation of Statistical Models">
                        A Role for Symbolic Computation in the General Estimation of Statistical Models
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2017-01-18T00:00:00-06:00"> Wed 18 January 2017</time>
    </span>





    
</footer><!-- /.post-info -->                    </div>
                </div>
                <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Brandon T. Willard" />
  <title>A Role for Symbolic Computation in the General Estimation of Statistical Models</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
</head>
<body>
<!--  -->
<!-- <div id="header"> -->
<!-- <h1 class="title">A Role for Symbolic Computation in the General Estimation of Statistical Models</h1> -->
<!--  -->
<!--  -->
<!-- <h2 class="author">Brandon T. Willard</h2> -->
<!--  -->
<!--  -->
<!-- <h3 class="date">2017–01–18</h3> -->
<!--  -->
<!-- </div> -->
<!--  -->
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>In this document we describe how symbolic computation can be used to provide generalizable statistical estimation through a combination of existing open source frameworks. Specifically, we will show how symbolic tools can be used to address the estimation of non-smooth functions that appear in models with parameter regularization, shrinkage and sparsity. We employ a mathematical framework that makes extensive use of <em>proximal operators</em> <span class="citation" data-cites="parikh_proximal_2014 combettes_proximal_2011">(Parikh and Boyd 2014; Combettes and Pesquet 2011)</span> and their properties for maximum a posteriori (MAP) estimation: i.e. the <em>proximal framework</em>. This framework produces what we’ll call <em>proximal methods</em> and their implementations as <em>proximal algorithms</em>.</p>
<p>In <span class="citation" data-cites="polson_proximal_2015">Polson, Scott, and Willard (2015)</span> we outlined a set of seemingly disparate optimization techniques within the fields of statistics, computer vision, and machine learning (e.g. gradient descent, ADMM, EM, Douglas-Rachford) that are unified by their various applications of proximal methods. These methods–and the concepts behind them–have found much success in recent times and admit quite a few interesting paths for research. In other words, there are many reasons to alone discuss the implementation of proximal methods.</p>
<p>Proximal operators also enjoy a breadth of closed-form solutions and useful properties that are amenable to symbolic computation. In more than a few cases, the work required to produce a proximal algorithm overlaps with well-established features of computer algebra systems and symbolic mathematics, such as symbolic differentiation and algebraic equation solving.</p>
<p>Symbolic integration provides an excellent example of how proximal operators could be implemented in a symbolic system. In these systems, mappings between functions (as canonicalized graphs) and their generalized hypergeometric equivalents are used to exploit the latter’s relevant convolution identities. In the same vein, it is possible to use tables of closed-form proximal operators and their properties to produce a wide array of estimation algorithms for many non-smooth functions. We outline how this might be done in the following sections.</p>
<p>Otherwise, the ideas discussed here are part of a never-ending attempt to answer a question that arises naturally in both mathematics and programming–at all levels: <em>How does one provide a means of generating robust solutions to as many problems as possible?</em> Instead of the common efforts to independently implement each model, method and/or combination of the two–followed by their placement in an API or library of functions–implementations can be encoded in and organized by the very mathematics from which they were derived. This close coupling between mathematical principles and their implementations might be the only reasonable way to remove barriers between theory, research and practice.</p>
<section id="a-context" class="level2">
<h2>A Context</h2>
<p>Much recent work in statistical modeling and estimation has had the goal of producing sparse results and/or efficient, near automatic model selection. This objective is shared with other related practices–such as Deep Learning and Compressed Sensing. In the former case, we can point to Dropout <span class="citation" data-cites="srivastava_dropout_2014">(Srivastava et al. 2014)</span> and–in the latter–<span class="math inline">\(\ell_p\)</span> regularization <span class="citation" data-cites="donoho_compressed_2006">(Donoho 2006)</span> as basic examples.</p>
<p>Here we’ll simply assume that a practitioner intends to produce sparse estimates using the well-known LASSO–or <span class="math inline">\(\ell_1\)</span> penalty.</p>
<p>In PyMC3 <span class="citation" data-cites="salvatier_probabilistic_2016">(Salvatier, Wiecki, and Fonnesbeck 2016)</span>, the Bayes version of LASSO <span class="citation" data-cites="park_bayesian_2008">(Park and Casella 2008)</span> is easily specified.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="im">import</span> scipy <span class="im">as</span> sc</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="im">import</span> pymc3 <span class="im">as</span> pm</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="im">import</span> theano</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="im">import</span> theano.tensor <span class="im">as</span> tt</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="im">from</span> theano <span class="im">import</span> shared <span class="im">as</span> tt_shared</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>theano.config.mode <span class="op">=</span> <span class="st">&#39;FAST_COMPILE&#39;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>mu_true <span class="op">=</span> np.zeros(<span class="dv">100</span>)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>mu_true[:<span class="dv">20</span>] <span class="op">=</span> np.exp(<span class="op">-</span>np.arange(<span class="dv">20</span>)) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>X <span class="op">=</span> np.random.randn(<span class="bu">int</span>(np.alen(mu_true) <span class="op">*</span> <span class="fl">0.7</span>), np.alen(mu_true))</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>y <span class="op">=</span> sc.stats.norm.rvs(loc<span class="op">=</span>X.dot(mu_true), scale<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>X_tt <span class="op">=</span> tt_shared(X, name<span class="op">=</span><span class="st">&#39;X&#39;</span>, borrow<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>y_tt <span class="op">=</span> tt_shared(y, name<span class="op">=</span><span class="st">&#39;y&#39;</span>, borrow<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> lasso_model:</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>    <span class="co"># Would be nice if we could pass the symbolic y_tt.shape, so</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>    <span class="co"># that our model would automatically conform to changes in</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>    <span class="co"># the shared variables X_tt.</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>    <span class="co"># See https://github.com/pymc-devs/pymc3/pull/1125</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a>    beta_rv <span class="op">=</span> pm.Laplace(<span class="st">&#39;beta&#39;</span>, mu<span class="op">=</span><span class="dv">0</span>, b<span class="op">=</span><span class="dv">1</span>, shape<span class="op">=</span>X.shape[<span class="dv">1</span>])</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a>    y_rv <span class="op">=</span> pm.Normal(<span class="st">&#39;y&#39;</span>, mu<span class="op">=</span>X_tt.dot(beta_rv), sd<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>                     shape<span class="op">=</span>y.shape[<span class="dv">0</span>], observed<span class="op">=</span>y_tt)</span></code></pre></div>
<p>Again, the negative total log likelihood in our example has a non-smooth <span class="math inline">\(\ell_1\)</span> term. Keeping this in mind, let’s say we wanted to produce a MAP estimate using PyMC3. A function is already provided for this task: <code>find_MAP</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="cf">with</span> lasso_model:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    params_0 <span class="op">=</span> pm.find_MAP(<span class="bu">vars</span><span class="op">=</span>[beta_rv])</span></code></pre></div>
<p>In our run of the above, an exception was thrown due to <code>nan</code> values within the gradient evaluation. We can inspect the gradient at <span class="math inline">\(\beta = 0, 1\)</span> and reproduce the result.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>start <span class="op">=</span> pm.Point({<span class="st">&#39;beta&#39;</span>: np.zeros(X.shape[<span class="dv">1</span>])}, model<span class="op">=</span>lasso_model)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>bij <span class="op">=</span> pm.DictToArrayBijection(pm.ArrayOrdering(lasso_model.<span class="bu">vars</span>),</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>start)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>logp <span class="op">=</span> bij.mapf(lasso_model.fastlogp)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>dlogp <span class="op">=</span> bij.mapf(lasso_model.fastdlogp(lasso_model.<span class="bu">vars</span>))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="co"># Could also inspect the log likelihood of the prior:</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="co"># beta_rv.dlogp().f(np.zeros_like(start[&#39;beta&#39;]))</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>grad_at_0 <span class="op">=</span> dlogp(np.zeros_like(start[<span class="st">&#39;beta&#39;</span>]))</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>grad_at_1 <span class="op">=</span> dlogp(np.ones_like(start[<span class="st">&#39;beta&#39;</span>]))</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(np.<span class="bu">sum</span>(np.isnan(grad_at_0)))</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="dv">100</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(np.<span class="bu">sum</span>(np.isnan(grad_at_1)))</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="dv">0</span></span></code></pre></div>
<p>The s are not due to any short-coming of PyMC3; they only demonstrate a suitable place for our ideas and improvements. Additionally, by working within PyMC3, we can readily apply certain mathematical results. For instance, theorems that apply only to distributions. This idea is more relevant to the graph optimizations we consider later, but is still very important.</p>
</section>
</section>
<section id="the-proximal-context" class="level1">
<h1>The Proximal Context</h1>
<p>We start with the essential ingredient: the proximal operator.</p>
<div class="Def" data-markdown="" data-title-name="[Proximal Operator]">
<p><span class="math display">\[\begin{equation*}
\operatorname*{prox}_{\phi}(x) =
    \operatorname*{argmin}_{z} \left\{
    \frac{1}{2} \left(z - x\right)^2 + \phi(z)
    \right\}
    \;.
\end{equation*}\]</span></p>
</div>
<p>As we mentioned earlier, the proximal operator is the main tool of proximal algorithms. Exact solutions to proximal operators exist for many <span class="math inline">\(\phi\)</span>, and, since they’re often quite simple in form, their computation is relatively cheap: a property that the proximal methods themselves can inherit.</p>
<p>Consider the MAP estimation of a penalized likelihood, i.e. <span class="math display">\[\begin{equation}
\beta^* = \operatorname*{argmin}_\beta \left\{ l(\beta) + \gamma \phi(\beta) \right\}
  \;,
  \label{eq:prox_problem}
\end{equation}\]</span> where functions <span class="math inline">\(l\)</span> and <span class="math inline">\(\phi\)</span> are commonly referred to as likelihood and prior terms (or loss and penalty), respectively. The proximal framework usually assumes <span class="math inline">\(l\)</span> and <span class="math inline">\(\phi\)</span> are at least lower semi-continuous and convex–although quite a few useful results still hold for non-convex functions.</p>
<p>Notice that Equation <span class="math inline">\(\eqref{eq:prox_problem}\)</span> takes the form of a proximal operator when <span class="math inline">\(l(\beta) = \frac{1}{2} (y - \beta)^2\)</span>. Otherwise, in regression problems, we have <span class="math inline">\(l(\beta) = \frac{1}{2} \|y - X \beta\|^2\)</span>. In this case, properties of the proximal operator can be used to produce independent proximal operators in each dimension of <span class="math inline">\(\beta\)</span>. Since more than one property of the proximal operator can accomplish this–and result in distinct approaches–one might begin to see here a reason for the breadth of proximal methods.</p>
<p>The proximal operator relevant to our example, <span class="math inline">\(\operatorname*{prox}_{|\cdot|}\)</span>, is equivalent to the soft-thresholding operator. Its implementation in Theano is somewhat trivial, but–for the sake of exposition–we provide an example.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>beta_tt <span class="op">=</span> tt.vector(<span class="st">&#39;beta&#39;</span>, dtype<span class="op">=</span>tt.config.floatX)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>beta_tt.tag.test_value <span class="op">=</span> np.r_[<span class="op">-</span><span class="dv">10</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="fl">0.2</span>, <span class="dv">0</span>, <span class="fl">0.2</span>, <span class="dv">1</span>,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="dv">10</span>].astype(tt.config.floatX)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>lambda_tt <span class="op">=</span> tt.scalar(<span class="st">&#39;lambda&#39;</span>, dtype<span class="op">=</span>tt.config.floatX)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>lambda_tt.tag.test_value <span class="op">=</span> np.array(<span class="fl">0.5</span>).astype(tt.config.floatX)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a><span class="kw">def</span> soft_threshold(beta_, lambda_):</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>    <span class="cf">return</span> tt.sgn(beta_) <span class="op">*</span> tt.maximum(tt.abs_(beta_) <span class="op">-</span> lambda_, <span class="dv">0</span>)</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(soft_threshold(beta_tt, lambda_tt).tag.test_value)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>[<span class="op">-</span><span class="fl">9.5</span> <span class="op">-</span><span class="fl">0.5</span> <span class="op">-</span><span class="fl">0.</span>   <span class="fl">0.</span>   <span class="fl">0.</span>   <span class="fl">0.5</span>  <span class="fl">9.5</span>]</span></code></pre></div>
<p>Proximal operators can be composed with a gradient step to produce the <em>proximal gradient</em> algorithm: <span class="math display">\[\begin{equation}
\beta = \operatorname*{prox}_{\alpha \lambda \phi}(\beta - \alpha \nabla l(\beta))
  \;.
  \label{eq:forward-backward}
\end{equation}\]</span></p>
<p>Besides the proximal operator for <span class="math inline">\(\phi\)</span>, steps in the proximal gradient algorithm are very straightforward and require only the gradient of <span class="math inline">\(l(\beta)\)</span>. This is where a tangible benefit of symbolic computation becomes apparent: <span class="math inline">\(\nabla l(\beta)\)</span> can be computed automatically and efficiently. With [backtracking] line search to handle unknown step sizes, <span class="math inline">\(\alpha\)</span>, the proximal gradient algorithm provides a surprisingly general means of sparse estimation.</p>
</section>
<section id="the-symbolic-operations" class="level1">
<h1>The Symbolic Operations</h1>
<p>In order to identify a relevant, non-smooth problem, check that a given proximal method’s conditions are satisfied (e.g. convexity), and potentially solve the resulting proximal operators in closed-form, we need to obtain expressions for <span class="math inline">\(l\)</span> and <span class="math inline">\(\phi\)</span>.</p>
<p>In some cases, we’re able to tease apart <span class="math inline">\(l\)</span> and <span class="math inline">\(\phi\)</span> using only the interface provided by PyMC3. Specifically, the <em>observed</em> and <em>unobserved</em> random variable fields in PyMC3 models.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="im">from</span> theano <span class="im">import</span> clone <span class="im">as</span> tt_clone</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>logl <span class="op">=</span> tt_clone(lasso_model.observed_RVs[<span class="dv">0</span>].logpt,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>                {beta_rv: beta_tt})</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>logl.name <span class="op">=</span> <span class="st">&quot;logl&quot;</span></span></code></pre></div>
<p>Instead, let’s assume we’re extending <code>find_MAP</code> with even more generality, so that we can’t determine <span class="math inline">\(l\)</span> and <span class="math inline">\(\phi\)</span> in this way. This situation can occur when a user specifies custom distributions or potential functions. Regardless, we need to operate at a more symbolic level.</p>
<div class="remark" data-markdown="" data-title-name="">
<p>At this point, it is extremely worthwhile to browse the <a href="http://deeplearning.net/software/theano/extending/graphstructures.html">Theano documentation</a> regarding graphs and their constituent objects.</p>
</div>
<p>The total log-likelihood is a good place to start. Let’s look at the symbolic graph for the log-likelihood of our model.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="im">from</span> theano <span class="im">import</span> pp <span class="im">as</span> tt_pp</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="im">from</span> theano <span class="im">import</span> pprint <span class="im">as</span> tt_pprint</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(tt_pp(lasso_model.logpt))</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>(Sum{acc_dtype<span class="op">=</span>float64}(Sum{acc_dtype<span class="op">=</span>float64}(((<span class="op">-</span>log(TensorConstant{<span class="dv">2</span>}))</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="op">-</span> (<span class="op">|</span>(<span class="op">\</span>beta <span class="op">-</span> TensorConstant{<span class="dv">0</span>})<span class="op">|</span> <span class="op">/</span> TensorConstant{<span class="dv">1</span>})))) <span class="op">+</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>Sum{acc_dtype<span class="op">=</span>float64}(Sum{acc_dtype<span class="op">=</span>float64}(switch(TensorConstant{<span class="dv">1</span>},</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>(((TensorConstant{<span class="op">-</span><span class="fl">1.0</span>} <span class="op">*</span> ((y <span class="op">-</span> (X <span class="op">\</span>dot <span class="op">\</span>beta)) <span class="op">**</span> TensorConstant{<span class="dv">2</span>}))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a><span class="op">+</span> log(TensorConstant{<span class="fl">0.159154943092</span>})) <span class="op">/</span> TensorConstant{<span class="fl">2.0</span>}),</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>TensorConstant{<span class="op">-</span>inf}))))</span></code></pre></div>
<p>The <a href="http://deeplearning.net/software/theano/tutorial/printing_drawing.html#pretty-printing">pretty printed</a> Theano graph tells us–among other things–that we indeed have a sum of <span class="math inline">\(\ell_2\)</span> and <span class="math inline">\(\ell_1\)</span> terms, although they are found among other confusing results (such as a <code>switch</code> statement).</p>
<p>As with most graphs produced by symbolic algebra systems, we need to understand how operations and objects are expressed in a graph and exactly which ones are relevant to us. After doing so, we can develop a means of finding what we want. The <a href="http://deeplearning.net/software/theano/tutorial/printing_drawing.html#debug-print">debug printout</a> is often a better visual summary of graphs, since it expresses branches clearly.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> tt.printing.debugprint(lasso_model.logpt)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>Elemwise{add,no_inplace} [<span class="bu">id</span> A] <span class="st">&#39;&#39;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a> <span class="op">|</span>Sum{acc_dtype<span class="op">=</span>float64} [<span class="bu">id</span> B] <span class="st">&#39;&#39;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a> <span class="op">|</span> <span class="op">|</span>Sum{acc_dtype<span class="op">=</span>float64} [<span class="bu">id</span> C] <span class="st">&#39;&#39;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a> <span class="op">|</span>   <span class="op">|</span>Elemwise{sub,no_inplace} [<span class="bu">id</span> D] <span class="st">&#39;&#39;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a> <span class="op">|</span>     <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> E] <span class="st">&#39;&#39;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a> <span class="op">|</span>     <span class="op">|</span> <span class="op">|</span>Elemwise{neg,no_inplace} [<span class="bu">id</span> F] <span class="st">&#39;&#39;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a> <span class="op">|</span>     <span class="op">|</span>   <span class="op">|</span>Elemwise{log,no_inplace} [<span class="bu">id</span> G] <span class="st">&#39;&#39;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a> <span class="op">|</span>     <span class="op">|</span>     <span class="op">|</span>TensorConstant{<span class="dv">2</span>} [<span class="bu">id</span> H]</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a> <span class="op">|</span>     <span class="op">|</span>Elemwise{true_div,no_inplace} [<span class="bu">id</span> I] <span class="st">&#39;&#39;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a> <span class="op">|</span>       <span class="op">|</span>Elemwise{abs_,no_inplace} [<span class="bu">id</span> J] <span class="st">&#39;&#39;</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a> <span class="op">|</span>       <span class="op">|</span> <span class="op">|</span>Elemwise{sub,no_inplace} [<span class="bu">id</span> K] <span class="st">&#39;&#39;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a> <span class="op">|</span>       <span class="op">|</span>   <span class="op">|</span>beta [<span class="bu">id</span> L]</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a> <span class="op">|</span>       <span class="op">|</span>   <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> M] <span class="st">&#39;&#39;</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a> <span class="op">|</span>       <span class="op">|</span>     <span class="op">|</span>TensorConstant{<span class="dv">0</span>} [<span class="bu">id</span> N]</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a> <span class="op">|</span>       <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> O] <span class="st">&#39;&#39;</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a> <span class="op">|</span>         <span class="op">|</span>TensorConstant{<span class="dv">1</span>} [<span class="bu">id</span> P]</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a> <span class="op">|</span>Sum{acc_dtype<span class="op">=</span>float64} [<span class="bu">id</span> Q] <span class="st">&#39;&#39;</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a>   <span class="op">|</span>Sum{acc_dtype<span class="op">=</span>float64} [<span class="bu">id</span> R] <span class="st">&#39;&#39;</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true"></a>     <span class="op">|</span>Elemwise{switch,no_inplace} [<span class="bu">id</span> S] <span class="st">&#39;&#39;</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true"></a>       <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> T] <span class="st">&#39;&#39;</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span>TensorConstant{<span class="dv">1</span>} [<span class="bu">id</span> P]</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true"></a>       <span class="op">|</span>Elemwise{true_div,no_inplace} [<span class="bu">id</span> U] <span class="st">&#39;&#39;</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span>Elemwise{add,no_inplace} [<span class="bu">id</span> V] <span class="st">&#39;&#39;</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>Elemwise{mul,no_inplace} [<span class="bu">id</span> W] <span class="st">&#39;&#39;</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> X] <span class="st">&#39;&#39;</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span> <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>TensorConstant{<span class="op">-</span><span class="fl">1.0</span>} [<span class="bu">id</span> Y]</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>Elemwise{<span class="bu">pow</span>,no_inplace} [<span class="bu">id</span> Z] <span class="st">&#39;&#39;</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>   <span class="op">|</span>Elemwise{sub,no_inplace} [<span class="bu">id</span> BA] <span class="st">&#39;&#39;</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>   <span class="op">|</span> <span class="op">|</span>y [<span class="bu">id</span> BB]</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>   <span class="op">|</span> <span class="op">|</span>dot [<span class="bu">id</span> BC] <span class="st">&#39;&#39;</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>   <span class="op">|</span>   <span class="op">|</span>X [<span class="bu">id</span> BD]</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>   <span class="op">|</span>   <span class="op">|</span>beta [<span class="bu">id</span> L]</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>   <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> BE] <span class="st">&#39;&#39;</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>     <span class="op">|</span>TensorConstant{<span class="dv">2</span>} [<span class="bu">id</span> H]</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> BF] <span class="st">&#39;&#39;</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span>   <span class="op">|</span>Elemwise{log,no_inplace} [<span class="bu">id</span> BG] <span class="st">&#39;&#39;</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span>     <span class="op">|</span>TensorConstant{<span class="fl">0.159154943092</span>} [<span class="bu">id</span> BH]</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> BI] <span class="st">&#39;&#39;</span></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true"></a>       <span class="op">|</span>   <span class="op">|</span>TensorConstant{<span class="fl">2.0</span>} [<span class="bu">id</span> BJ]</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true"></a>       <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> BK] <span class="st">&#39;&#39;</span></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true"></a>         <span class="op">|</span>TensorConstant{<span class="op">-</span>inf} [<span class="bu">id</span> BL]</span></code></pre></div>
<p>We see that the top-most operator is an <code>Elemwise</code> that applies the scalar <code>add</code> operation. This is the “<span class="math inline">\(+\)</span>” in <span class="math inline">\(l + \phi\)</span>. If we were to consider the inputs of this operator as candidates for <span class="math inline">\(l\)</span> and <span class="math inline">\(\phi\)</span>, then we could do the following:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(lasso_model.logpt.owner.inputs)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>[Sum{acc_dtype<span class="op">=</span>float64}<span class="fl">.0</span>, Sum{acc_dtype<span class="op">=</span>float64}<span class="fl">.0</span>]</span></code></pre></div>
<p>Starting from the sub-graphs of each term, we could then search for any non-smooth functions that have known closed-form proximal operators. In our case, we only consider the absolute value function.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">def</span> get_abs_between(input_node):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>    <span class="co">&quot;&quot;&quot; Search for `abs` in the operations between our input and the</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="co">    log-likelihood output node.</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>    term_ops <span class="op">=</span> <span class="bu">list</span>(tt.gof.graph.ops([input_node],</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>[lasso_model.logpt]))</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>    <span class="co"># Is there an absolute value in there?</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bu">filter</span>(<span class="kw">lambda</span> x: x.op <span class="kw">is</span> tt.abs_, term_ops)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>abs_res <span class="op">=</span> [(get_abs_between(in_), in_)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>           <span class="cf">for</span> in_ <span class="kw">in</span> lasso_model.logpt.owner.inputs]</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a><span class="cf">for</span> r_ <span class="kw">in</span> abs_res:</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a>    <span class="cf">if</span> <span class="bu">len</span>(r_[<span class="dv">0</span>]) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a>        phi <span class="op">=</span> r_[<span class="dv">1</span>]</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a>        logp <span class="op">=</span> r_[<span class="dv">1</span>]</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> tt.printing.debugprint(logp)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>Sum{acc_dtype<span class="op">=</span>float64} [<span class="bu">id</span> A] <span class="st">&#39;&#39;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a> <span class="op">|</span>Sum{acc_dtype<span class="op">=</span>float64} [<span class="bu">id</span> B] <span class="st">&#39;&#39;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>   <span class="op">|</span>Elemwise{switch,no_inplace} [<span class="bu">id</span> C] <span class="st">&#39;&#39;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>     <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> D] <span class="st">&#39;&#39;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span>TensorConstant{<span class="dv">1</span>} [<span class="bu">id</span> E]</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>     <span class="op">|</span>Elemwise{true_div,no_inplace} [<span class="bu">id</span> F] <span class="st">&#39;&#39;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span>Elemwise{add,no_inplace} [<span class="bu">id</span> G] <span class="st">&#39;&#39;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>Elemwise{mul,no_inplace} [<span class="bu">id</span> H] <span class="st">&#39;&#39;</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> I] <span class="st">&#39;&#39;</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span> <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>TensorConstant{<span class="op">-</span><span class="fl">1.0</span>} [<span class="bu">id</span> J]</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>Elemwise{<span class="bu">pow</span>,no_inplace} [<span class="bu">id</span> K] <span class="st">&#39;&#39;</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>   <span class="op">|</span>Elemwise{sub,no_inplace} [<span class="bu">id</span> L] <span class="st">&#39;&#39;</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>   <span class="op">|</span> <span class="op">|</span>y [<span class="bu">id</span> M]</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>   <span class="op">|</span> <span class="op">|</span>dot [<span class="bu">id</span> N] <span class="st">&#39;&#39;</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>   <span class="op">|</span>   <span class="op">|</span>X [<span class="bu">id</span> O]</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>   <span class="op">|</span>   <span class="op">|</span>beta [<span class="bu">id</span> P]</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>   <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> Q] <span class="st">&#39;&#39;</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>     <span class="op">|</span>TensorConstant{<span class="dv">2</span>} [<span class="bu">id</span> R]</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> S] <span class="st">&#39;&#39;</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span>   <span class="op">|</span>Elemwise{log,no_inplace} [<span class="bu">id</span> T] <span class="st">&#39;&#39;</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span>     <span class="op">|</span>TensorConstant{<span class="fl">0.159154943092</span>} [<span class="bu">id</span> U]</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> V] <span class="st">&#39;&#39;</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true"></a>     <span class="op">|</span>   <span class="op">|</span>TensorConstant{<span class="fl">2.0</span>} [<span class="bu">id</span> W]</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true"></a>     <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> X] <span class="st">&#39;&#39;</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true"></a>       <span class="op">|</span>TensorConstant{<span class="op">-</span>inf} [<span class="bu">id</span> Y]</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> tt.printing.debugprint(phi)</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true"></a>Sum{acc_dtype<span class="op">=</span>float64} [<span class="bu">id</span> A] <span class="st">&#39;&#39;</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true"></a> <span class="op">|</span>Sum{acc_dtype<span class="op">=</span>float64} [<span class="bu">id</span> B] <span class="st">&#39;&#39;</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true"></a>   <span class="op">|</span>Elemwise{sub,no_inplace} [<span class="bu">id</span> C] <span class="st">&#39;&#39;</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true"></a>     <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> D] <span class="st">&#39;&#39;</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true"></a>     <span class="op">|</span> <span class="op">|</span>Elemwise{neg,no_inplace} [<span class="bu">id</span> E] <span class="st">&#39;&#39;</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true"></a>     <span class="op">|</span>   <span class="op">|</span>Elemwise{log,no_inplace} [<span class="bu">id</span> F] <span class="st">&#39;&#39;</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true"></a>     <span class="op">|</span>     <span class="op">|</span>TensorConstant{<span class="dv">2</span>} [<span class="bu">id</span> G]</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true"></a>     <span class="op">|</span>Elemwise{true_div,no_inplace} [<span class="bu">id</span> H] <span class="st">&#39;&#39;</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true"></a>       <span class="op">|</span>Elemwise{abs_,no_inplace} [<span class="bu">id</span> I] <span class="st">&#39;&#39;</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true"></a>       <span class="op">|</span> <span class="op">|</span>Elemwise{sub,no_inplace} [<span class="bu">id</span> J] <span class="st">&#39;&#39;</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true"></a>       <span class="op">|</span>   <span class="op">|</span>beta [<span class="bu">id</span> K]</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true"></a>       <span class="op">|</span>   <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> L] <span class="st">&#39;&#39;</span></span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true"></a>       <span class="op">|</span>     <span class="op">|</span>TensorConstant{<span class="dv">0</span>} [<span class="bu">id</span> M]</span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true"></a>       <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> N] <span class="st">&#39;&#39;</span></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true"></a>         <span class="op">|</span>TensorConstant{<span class="dv">1</span>} [<span class="bu">id</span> O]</span></code></pre></div>
<p>The above approach is still too limiting; we need something more robust. For instance, our logic could fail on graphs that are expressed as <span class="math inline">\(\eta (l + \phi) + 1\)</span>–although a graph for the equivalent expression <span class="math inline">\(\eta l + \eta \phi + \eta\)</span> might succeed. These are types of weaknesses inherent to naive approaches like ours. Furthermore, sufficient logic that uses a similar approach is likely to result in complicated and less approachable code.</p>
<p>The appropriate computational tools are found in the subjects of graph unification and term rewriting, as well as the areas of functional and logic programming. Luckily, Theano provides some basic unification capabilities through its <code>PatternSub</code> class.</p>
<p><code>PatternSub</code> works within the context of Theano <a href="http://deeplearning.net/software/theano/optimizations.html">graph optimization</a>. Graph optimizations perform the common symbolic operations of reduction/simplification and rewriting. Consider the <code>phi</code> variable; the print-outs show an unnecessary subtraction with <span class="math inline">\(0\)</span>. Clearly this step is unnecessary, so–in a basic way–we can see that the graph hasn’t been simplified, yet.</p>
<p>Many standard algebraic simplifications are already present in Theano, and, by creating our own graph optimizations, we can provide the advanced functionality we’ve been alluding to.</p>
<div class="example" data-markdown="" data-title-name="[Algebraic Graph Optimization]">
<p>As a quick demonstration, we’ll make replacement patterns for multiplicative distribution across two forms of addition: <code>sum</code> and <code>add</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>test_a_tt <span class="op">=</span> tt.as_tensor_variable(<span class="dv">5</span>, name<span class="op">=</span><span class="st">&#39;a&#39;</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>test_b_tt <span class="op">=</span> tt.as_tensor_variable(<span class="dv">2</span>, name<span class="op">=</span><span class="st">&#39;b&#39;</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>test_c_tt <span class="op">=</span> tt.as_tensor_variable(np.r_[<span class="dv">1</span>, <span class="dv">2</span>], name<span class="op">=</span><span class="st">&#39;c&#39;</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>test_exprs_tt <span class="op">=</span> (test_a_tt <span class="op">*</span> test_b_tt,)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>test_exprs_tt <span class="op">+=</span> (test_a_tt <span class="op">*</span> (test_b_tt <span class="op">+</span> test_a_tt),)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>test_exprs_tt <span class="op">+=</span> (test_a_tt <span class="op">*</span> (test_c_tt <span class="op">+</span> test_a_tt),)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>test_exprs_tt <span class="op">+=</span> (test_a_tt <span class="op">*</span> (test_c_tt <span class="op">+</span> test_c_tt),)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>mul_dist_pat_tt <span class="op">=</span> (tt.gof.opt.PatternSub(</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>    (tt.mul, <span class="st">&#39;x&#39;</span>, (tt.<span class="bu">sum</span>, <span class="st">&#39;y&#39;</span>, <span class="st">&#39;z&#39;</span>)),</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>    (tt.<span class="bu">sum</span>, (tt.mul, <span class="st">&#39;x&#39;</span>, <span class="st">&#39;y&#39;</span>), (tt.mul, <span class="st">&#39;x&#39;</span>, <span class="st">&#39;z&#39;</span>))</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>),)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>mul_dist_pat_tt <span class="op">+=</span> (tt.gof.opt.PatternSub(</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>    (tt.mul, <span class="st">&#39;x&#39;</span>, (tt.add, <span class="st">&#39;y&#39;</span>, <span class="st">&#39;z&#39;</span>)),</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>    (tt.add, (tt.mul, <span class="st">&#39;x&#39;</span>, <span class="st">&#39;y&#39;</span>), (tt.mul, <span class="st">&#39;x&#39;</span>, <span class="st">&#39;z&#39;</span>))</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>),)</span></code></pre></div>
<p>Substitutions can be applied to an objective function until it is in a fully-reduced form: <code>EquilibriumOptimizer</code> provides this functionality.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>test_sub_eqz_opt_tt <span class="op">=</span> tt.gof.opt.EquilibriumOptimizer(</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>    mul_dist_pat_tt, max_use_ratio<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>test_fgraph_tt <span class="op">=</span> tt.gof.fg.FunctionGraph(</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>    tt.gof.graph.inputs(test_exprs_tt), test_exprs_tt)</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> tt.printing.debugprint(test_fgraph_tt)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>Elemwise{mul,no_inplace} [<span class="bu">id</span> A] <span class="st">&#39;&#39;</span>   <span class="dv">5</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a> <span class="op">|</span>TensorConstant{<span class="dv">5</span>} [<span class="bu">id</span> B]</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a> <span class="op">|</span>TensorConstant{<span class="dv">2</span>} [<span class="bu">id</span> C]</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>Elemwise{mul,no_inplace} [<span class="bu">id</span> D] <span class="st">&#39;&#39;</span>   <span class="dv">8</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a> <span class="op">|</span>TensorConstant{<span class="dv">5</span>} [<span class="bu">id</span> B]</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a> <span class="op">|</span>Elemwise{add,no_inplace} [<span class="bu">id</span> E] <span class="st">&#39;&#39;</span>   <span class="dv">4</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>   <span class="op">|</span>TensorConstant{<span class="dv">2</span>} [<span class="bu">id</span> C]</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>   <span class="op">|</span>TensorConstant{<span class="dv">5</span>} [<span class="bu">id</span> B]</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>Elemwise{mul,no_inplace} [<span class="bu">id</span> F] <span class="st">&#39;&#39;</span>   <span class="dv">9</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a> <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> G] <span class="st">&#39;&#39;</span>   <span class="dv">3</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a> <span class="op">|</span> <span class="op">|</span>TensorConstant{<span class="dv">5</span>} [<span class="bu">id</span> B]</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a> <span class="op">|</span>Elemwise{add,no_inplace} [<span class="bu">id</span> H] <span class="st">&#39;&#39;</span>   <span class="dv">7</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a>   <span class="op">|</span>TensorConstant{[<span class="dv">1</span> <span class="dv">2</span>]} [<span class="bu">id</span> I]</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a>   <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> J] <span class="st">&#39;&#39;</span>   <span class="dv">2</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a>     <span class="op">|</span>TensorConstant{<span class="dv">5</span>} [<span class="bu">id</span> B]</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true"></a>Elemwise{mul,no_inplace} [<span class="bu">id</span> K] <span class="st">&#39;&#39;</span>   <span class="dv">6</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true"></a> <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> L] <span class="st">&#39;&#39;</span>   <span class="dv">1</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true"></a> <span class="op">|</span> <span class="op">|</span>TensorConstant{<span class="dv">5</span>} [<span class="bu">id</span> B]</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true"></a> <span class="op">|</span>Elemwise{add,no_inplace} [<span class="bu">id</span> M] <span class="st">&#39;&#39;</span>   <span class="dv">0</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true"></a>   <span class="op">|</span>TensorConstant{[<span class="dv">1</span> <span class="dv">2</span>]} [<span class="bu">id</span> I]</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true"></a>   <span class="op">|</span>TensorConstant{[<span class="dv">1</span> <span class="dv">2</span>]} [<span class="bu">id</span> I]</span></code></pre></div>
<p>Now, when we apply the optimization, the <code>FunctionGraph</code> should contain the replacements.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>test_fgraph_opt <span class="op">=</span> test_sub_eqz_opt_tt.optimize(test_fgraph_tt)</span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> tt.printing.debugprint(test_fgraph_tt)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>Elemwise{mul,no_inplace} [<span class="bu">id</span> A] <span class="st">&#39;&#39;</span>   <span class="dv">5</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a> <span class="op">|</span>TensorConstant{<span class="dv">5</span>} [<span class="bu">id</span> B]</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a> <span class="op">|</span>TensorConstant{<span class="dv">2</span>} [<span class="bu">id</span> C]</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>Elemwise{add,no_inplace} [<span class="bu">id</span> D] <span class="st">&#39;&#39;</span>   <span class="dv">10</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a> <span class="op">|</span>Elemwise{mul,no_inplace} [<span class="bu">id</span> E] <span class="st">&#39;&#39;</span>   <span class="dv">4</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a> <span class="op">|</span> <span class="op">|</span>TensorConstant{<span class="dv">5</span>} [<span class="bu">id</span> B]</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a> <span class="op">|</span> <span class="op">|</span>TensorConstant{<span class="dv">2</span>} [<span class="bu">id</span> C]</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a> <span class="op">|</span>Elemwise{mul,no_inplace} [<span class="bu">id</span> F] <span class="st">&#39;&#39;</span>   <span class="dv">3</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>   <span class="op">|</span>TensorConstant{<span class="dv">5</span>} [<span class="bu">id</span> B]</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>   <span class="op">|</span>TensorConstant{<span class="dv">5</span>} [<span class="bu">id</span> B]</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>Elemwise{add,no_inplace} [<span class="bu">id</span> G] <span class="st">&#39;&#39;</span>   <span class="dv">12</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a> <span class="op">|</span>Elemwise{mul,no_inplace} [<span class="bu">id</span> H] <span class="st">&#39;&#39;</span>   <span class="dv">9</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a> <span class="op">|</span> <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> I] <span class="st">&#39;&#39;</span>   <span class="dv">2</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true"></a> <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>TensorConstant{<span class="dv">5</span>} [<span class="bu">id</span> B]</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true"></a> <span class="op">|</span> <span class="op">|</span>TensorConstant{[<span class="dv">1</span> <span class="dv">2</span>]} [<span class="bu">id</span> J]</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true"></a> <span class="op">|</span>Elemwise{mul,no_inplace} [<span class="bu">id</span> K] <span class="st">&#39;&#39;</span>   <span class="dv">8</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true"></a>   <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> I] <span class="st">&#39;&#39;</span>   <span class="dv">2</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true"></a>   <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> L] <span class="st">&#39;&#39;</span>   <span class="dv">1</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true"></a>     <span class="op">|</span>TensorConstant{<span class="dv">5</span>} [<span class="bu">id</span> B]</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true"></a>Elemwise{add,no_inplace} [<span class="bu">id</span> M] <span class="st">&#39;&#39;</span>   <span class="dv">11</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true"></a> <span class="op">|</span>Elemwise{mul,no_inplace} [<span class="bu">id</span> N] <span class="st">&#39;&#39;</span>   <span class="dv">7</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true"></a> <span class="op">|</span> <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> O] <span class="st">&#39;&#39;</span>   <span class="dv">0</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true"></a> <span class="op">|</span> <span class="op">|</span> <span class="op">|</span>TensorConstant{<span class="dv">5</span>} [<span class="bu">id</span> B]</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true"></a> <span class="op">|</span> <span class="op">|</span>TensorConstant{[<span class="dv">1</span> <span class="dv">2</span>]} [<span class="bu">id</span> J]</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true"></a> <span class="op">|</span>Elemwise{mul,no_inplace} [<span class="bu">id</span> P] <span class="st">&#39;&#39;</span>   <span class="dv">6</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true"></a>   <span class="op">|</span>DimShuffle{x} [<span class="bu">id</span> O] <span class="st">&#39;&#39;</span>   <span class="dv">0</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true"></a>   <span class="op">|</span>TensorConstant{[<span class="dv">1</span> <span class="dv">2</span>]} [<span class="bu">id</span> J]</span></code></pre></div>
</div>
<p>Even more symbolic capabilities might be needed to [efficiently] achieve the functionality we desire. Standalone libraries like SymPy and <a href="https://github.com/logpy/logpy/">LogPy</a> can be adapted to Theano graphs and provide these capabilities–although direct implementation in Theano may be better.</p>
<p>Finally, let’s briefly imagine how convexity could be determined symbolically. For differentiable terms, we could start with a simple second derivative test. Within Theano, a “second derivative” can be obtained using the <code>hessian</code> function, and within <code>theano.sandbox.linalg</code> are <code>Optimizer</code> hints for matrix positivity and other properties relevant to determining convexity.</p>
<div class="remark" data-markdown="" data-title-name="">
<p>Other great examples of linear algebra themed optimizations are in <code>theano.sandbox.linalg</code>: for instance, <code>no_transpose_symmetric</code>. Some of these demonstrate exactly how straight-forward adding algebraic features can be.</p>
</div>
<p>Although our convexity testing idea is far too simple for some functions, the point is that the basic tools necessary for work in this direction are already in place. With the logic programming and symbolic libraries mentioned earlier, a robust implementation of the convex function calculus could be very much in reach.</p>
</section>
<section id="discussion" class="level1">
<h1>Discussion</h1>
<p>We’ve sketched out some ideas and tools with which one could develop a robust estimation platform guided by the more abstract mathematical frameworks from which new and efficient methods are produced.</p>
<p>Some key steps may require the integration of a fully featured symbolic algebra system. Along these lines, connections between Theano, SymPy and LogPy have been explored in <span class="citation" data-cites="rocklin_mathematically_2013">Rocklin (2013)</span>–as well as many other important aspects of the topics discussed here.</p>
<p>Besides the automation of proximal algorithms themselves, there are areas of application involving very large and complex models–perhaps the ones arising in Deep Learning. How might we consider the operator splitting of ADMM within deeply layered or hierarchical models <span class="citation" data-cites="polson_statistical_2015">(Polson, Willard, and Heidari 2015)</span>? At which levels and on which terms should the splitting be performed? Beyond trying to solve the potentially unwieldy mathematics arising from such questions, by imbuing these symbolic tools with more mathematical awareness, we can at least experiment in these directions and quickly offer numerical solutions. This is–in part–the edge from which statistics hasn’t been benefiting and modern machine learning has.</p>
<p>Before closing, a very related–and interesting–set of ideas is worth mentioning: the possibility of encoding more symbolic knowledge into probabilistic programming platforms like PyMC3. Using the same optimization mechanisms as the examples here, simple distributional relationships can be encoded. For instance, the convolution of normally distributed random variables:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>mu_X <span class="op">=</span> tt.vector(<span class="st">&#39;mu_X&#39;</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>mu_X.tag.test_value <span class="op">=</span> np.array([<span class="fl">1.</span>], dtype<span class="op">=</span>tt.config.floatX)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>sd_X <span class="op">=</span> tt.vector(<span class="st">&#39;sd_X&#39;</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>sd_X.tag.test_value <span class="op">=</span> np.array([<span class="fl">2.</span>], dtype<span class="op">=</span>tt.config.floatX)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>mu_Y <span class="op">=</span> tt.vector(<span class="st">&#39;mu_Y&#39;</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>mu_Y.tag.test_value <span class="op">=</span> np.array([<span class="fl">1.</span>], dtype<span class="op">=</span>tt.config.floatX)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>sd_Y <span class="op">=</span> tt.vector(<span class="st">&#39;sd_Y&#39;</span>)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>sd_Y.tag.test_value <span class="op">=</span> np.array([<span class="fl">0.5</span>], dtype<span class="op">=</span>tt.config.floatX)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a><span class="cf">with</span> pm.Model() <span class="im">as</span> conv_model:</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a>    X_rv <span class="op">=</span> pm.Normal(<span class="st">&#39;X&#39;</span>, mu_X, sd<span class="op">=</span>sd_X, shape<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a>    Y_rv <span class="op">=</span> pm.Normal(<span class="st">&#39;Y&#39;</span>, mu_Y, sd<span class="op">=</span>sd_Y, shape<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a>    Z_rv <span class="op">=</span> X_rv <span class="op">+</span> Y_rv</span></code></pre></div>
<p>We create a Theano <code>Op</code> to handle the convolution.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="kw">class</span> NormConvOp(tt.Op):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>    __props__ <span class="op">=</span> ()</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>    <span class="kw">def</span> make_node(<span class="va">self</span>, <span class="op">*</span>inputs):</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>        name_new <span class="op">=</span> <span class="bu">str</span>.join(<span class="st">&#39;+&#39;</span>, [<span class="bu">getattr</span>(in_, <span class="st">&#39;name&#39;</span>, <span class="st">&#39;&#39;</span>) <span class="cf">for</span> in_ <span class="kw">in</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>inputs])</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>        mu_new <span class="op">=</span> tt.add(<span class="op">*</span>[in_.distribution.mu <span class="cf">for</span> in_ <span class="kw">in</span> inputs])</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>        sd_new <span class="op">=</span> tt.sqrt(tt.add(<span class="op">*</span>[in_.distribution.sd<span class="op">**</span><span class="dv">2</span> <span class="cf">for</span> in_ <span class="kw">in</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a>inputs]))</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>        conv_rv <span class="op">=</span> pm.Normal(name_new, mu<span class="op">=</span>mu_new, sd<span class="op">=</span>sd_new,</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>                            <span class="co"># Is this another place where</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>automatically<span class="op">/</span>Theano managed</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a>                            <span class="co"># shapes are really needed.  For now, we</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>hack it.</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a>                            shape<span class="op">=</span>(<span class="dv">1</span>,))</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true"></a>        <span class="cf">return</span> tt.Apply(<span class="va">self</span>, inputs, [conv_rv])</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true"></a>    <span class="kw">def</span> perform(<span class="va">self</span>, node, inputs, output_storage):</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true"></a>        z <span class="op">=</span> output_storage[<span class="dv">0</span>]</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true"></a>        z[<span class="dv">0</span>] <span class="op">=</span> np.add(<span class="op">*</span>inputs)</span></code></pre></div>
<p>Now, all that’s needed is a <code>PatternSub</code> like before.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="kw">def</span> is_normal_dist(x):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bu">hasattr</span>(x, <span class="st">&#39;distribution&#39;</span>) <span class="kw">and</span> <span class="bu">isinstance</span>(x.distribution,</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>pm.Normal)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>norm_conv_pat_tt <span class="op">=</span> (tt.gof.opt.PatternSub(</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>    (tt.add,</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>     {<span class="st">&#39;pattern&#39;</span>: <span class="st">&#39;x&#39;</span>,</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>      <span class="st">&#39;constraint&#39;</span>: <span class="kw">lambda</span> x: is_normal_dist(x)},</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>     {<span class="st">&#39;pattern&#39;</span>: <span class="st">&#39;y&#39;</span>,</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a>      <span class="st">&#39;constraint&#39;</span>: <span class="kw">lambda</span> x: is_normal_dist(x)}</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a>     ),</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a>    (NormConvOp(), <span class="st">&#39;x&#39;</span>, <span class="st">&#39;y&#39;</span>)),)</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true"></a>norm_conv_opt_tt <span class="op">=</span> tt.gof.opt.EquilibriumOptimizer(norm_conv_pat_tt,</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true"></a>                                                   max_use_ratio<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true"></a></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true"></a>Z_fgraph_tt <span class="op">=</span> tt.gof.fg.FunctionGraph([X_rv, Y_rv], [Z_rv])</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true"></a></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true"></a><span class="co"># We lose the `FreeRV.distribution` attribute when cloning the graph</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true"></a><span class="co"># with `theano.gof.graph.clone_get_equiv` in `FunctionGraph`, so this</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true"></a><span class="co"># hackishly reattaches that information:</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true"></a>_ <span class="op">=</span> [<span class="bu">setattr</span>(g_in, <span class="st">&#39;distribution&#39;</span>, s_in.distribution)</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true"></a>     <span class="cf">for</span> s_in, g_in <span class="kw">in</span> <span class="bu">zip</span>([X_rv, Y_rv], Z_fgraph_tt.inputs)]</span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="cf">with</span> conv_model:</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>    _ <span class="op">=</span> norm_conv_opt_tt.optimize(Z_fgraph_tt)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>norm_conv_var_dist <span class="op">=</span> Z_fgraph_tt.outputs[<span class="dv">0</span>].distribution</span></code></pre></div>
<p>The resulting graph:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> tt.printing.debugprint(Z_fgraph_tt)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>NormConvOp [<span class="bu">id</span> A] <span class="st">&#39;X+Y&#39;</span>   <span class="dv">0</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a> <span class="op">|</span>X [<span class="bu">id</span> B]</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a> <span class="op">|</span>Y [<span class="bu">id</span> C]</span></code></pre></div>
<p>and the convolution’s parameters (for the test values):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(norm_conv_var_dist.mu.tag.test_value)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>[ <span class="fl">2.</span>]</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(norm_conv_var_dist.sd.tag.test_value)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>[ <span class="fl">2.06155281</span>]</span></code></pre></div>
<p>More sophisticated routines–like the example above–could implement parameter expansions, efficient re-parameterizations and equivalent scale mixture forms in an effort to optimize a graph for sampling or point evaluation. Objectives for these optimizations could be straightforward and computationally based (e.g. reducing the number of operations in computations of the log likelihood and other quantities) or more statistically focused (e.g. highly efficient sampling, improve mixing). These ideas are most definitely not new–one example is given by <span class="citation" data-cites="mohasel_afshar_probabilistic_2016">Mohasel Afshar (2016)</span> for symbolic Gibbs sampling, but we hope the examples given here make the point that the tools are readily available and quite accessible.</p>
<p>We’ll end on a much more spacey consideration. Namely, that this is a context in which we can start experimenting rapidly with objectives over the space of estimation routines. This space is generated by–but not limited to–the variety of symbolic representations, re-parameterizations, etc., mentioned above. It does not necessarily require the complete estimation of a model at each step, nor even the numeric value of quantities like the gradient or Hessian. It may involve them, but not their evaluation; perhaps, instead, symbolic comparisons of competing gradients and Hessians arising from different representations. What we’re describing lies somewhere between the completely numeric assessments common today, and the entirely symbolic work found within the theorems and manipulations of the mathematics we use to derive methods.</p>
</section>
<section id="bibliography" class="level1 unnumbered">
<h1 class="unnumbered">"References"</h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-combettes_proximal_2011">
<p>Combettes, Patrick L, and Jean-Christophe Pesquet. 2011. “Proximal Splitting Methods in Signal Processing.” <em>Fixed-Point Algorithms for Inverse Problems in Science and Engineering</em>, 185–212.</p>
</div>
<div id="ref-donoho_compressed_2006">
<p>Donoho, David L. 2006. “Compressed Sensing.” <em>IEEE Transactions on Information Theory</em> 52 (4): 1289–1306. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1614066">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1614066</a>.</p>
</div>
<div id="ref-mohasel_afshar_probabilistic_2016">
<p>Mohasel Afshar, Hadi. 2016. “Probabilistic Inference in Piecewise Graphical Models.” <a href="https://digitalcollections.anu.edu.au/handle/1885/107386">https://digitalcollections.anu.edu.au/handle/1885/107386</a>.</p>
</div>
<div id="ref-parikh_proximal_2014">
<p>Parikh, Neal, and Stephen Boyd. 2014. “Proximal Algorithms.” <em>Foundations and Trends in Optimization</em> 1 (3): 123–231. <a href="https://doi.org/10.1561/2400000003">https://doi.org/10.1561/2400000003</a>.</p>
</div>
<div id="ref-park_bayesian_2008">
<p>Park, Trevor, and George Casella. 2008. “The Bayesian Lasso.” <em>Journal of the American Statistical Association</em> 103 (482): 681–86. <a href="http://amstat.tandfonline.com/doi/abs/10.1198/016214508000000337">http://amstat.tandfonline.com/doi/abs/10.1198/016214508000000337</a>.</p>
</div>
<div id="ref-polson_proximal_2015">
<p>Polson, Nicholas G., James G. Scott, and Brandon T. Willard. 2015. “Proximal Algorithms in Statistics and Machine Learning.” <em>Statistical Science</em> 30 (4): 559–81. <a href="http://projecteuclid.org/euclid.ss/1449670858">http://projecteuclid.org/euclid.ss/1449670858</a>.</p>
</div>
<div id="ref-polson_statistical_2015">
<p>Polson, Nicholas G., Brandon T. Willard, and Massoud Heidari. 2015. “A Statistical Theory of Deep Learning via Proximal Splitting.” <em>arXiv Preprint arXiv:1509.06061</em>. <a href="http://arxiv.org/abs/1509.06061">http://arxiv.org/abs/1509.06061</a>.</p>
</div>
<div id="ref-rocklin_mathematically_2013">
<p>Rocklin, Matthew. 2013. “Mathematically Informed Linear Algebra Codes Through Term Rewriting.” PhD thesis, PhD Thesis, August. <a href="http://people.cs.uchicago.edu/~mrocklin/storage/dissertation.pdf">http://people.cs.uchicago.edu/~mrocklin/storage/dissertation.pdf</a>.</p>
</div>
<div id="ref-salvatier_probabilistic_2016">
<p>Salvatier, John, Thomas V. Wiecki, and Christopher Fonnesbeck. 2016. “Probabilistic Programming in Python Using PyMC3.” <em>PeerJ Computer Science</em> 2 (April): e55. <a href="https://peerj.com/articles/cs-55">https://peerj.com/articles/cs-55</a>.</p>
</div>
<div id="ref-srivastava_dropout_2014">
<p>Srivastava, Nitish, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. 2014. “Dropout: A Simple Way to Prevent Neural Networks from Overfitting.” <em>The Journal of Machine Learning Research</em> 15 (1): 1929–58. <a href="http://dl.acm.org/citation.cfm?id=2670313">http://dl.acm.org/citation.cfm?id=2670313</a>.</p>
</div>
</div>
</section>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  CommonHTML: { linebreaks: { automatic: true } },
  "HTML-CSS": { linebreaks: { automatic: true } },
  SVG: { linebreaks: { automatic: true } },
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
</body>
</html>

            </div>
            <!-- /.entry-content -->
    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'brandonwillard-github-io'; // required: replace example with your forum shortname

            var disqus_config = function () {
                this.language = "en";

                        this.page.identifier = '2017-01-18-a-role-for-symbolic-computation-in-the-general-estimation-of-statistical-models';
                        this.page.url = 'https://brandonwillard.github.io/a-role-for-symbolic-computation-in-the-general-estimation-of-statistical-models.html';
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
        </article>
    </section>

        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>
<div id="aboutme">
        <p>
            <img width="100%" class="img-thumbnail" src="https://brandonwillard.github.io//images/profile-pic.png"/>
        </p>
    <p>
      <strong>About Brandon T. Willard</strong><br/>
        applied math/stats person
    </p>
</div><!-- Sidebar -->
<section class="well well-sm">
  <ul class="list-group list-group-flush">

<!-- Sidebar/Social -->
<li class="list-group-item">
  <h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Social</span></h4>
  <ul class="list-group" id="social">
    <li class="list-group-item"><a href="https://github.com/brandonwillard"><i class="fa fa-github-square fa-lg"></i> github</a></li>
    <li class="list-group-item"><a href="https://scholar.google.com/citations?user=g0oUxG4AAAAJ&hl=en"><i class="ai ai-google-scholar ai-lg"></i> google scholar</a></li>
    <li class="list-group-item"><a href="https://www.linkedin.com/in/brandon-t-willard-468bb410/"><i class="fa fa-linkedin fa-lg"></i> linkedin</a></li>
    <li class="list-group-item"><a href="https://bitbucket.io/brandonwillard"><i class="fa fa-bitbucket-square fa-lg"></i> bitbucket</a></li>
  </ul>
</li>
<!-- End Sidebar/Social -->
  </ul>
</section>
<!-- End Sidebar -->            </aside>
        </div>
    </div>
</div>
<!-- End Content Container -->

<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2020 Brandon T. Willard
            &middot; Powered by <a href="https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>                <p><small>  <a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/deed.en"><img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-nc/4.0/80x15.png" /></a>
    Content
  licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/deed.en">Creative Commons Attribution-NonCommercial 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="https://brandonwillard.github.io/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://brandonwillard.github.io/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="https://brandonwillard.github.io/theme/js/respond.min.js"></script>


    <!-- Disqus -->
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'brandonwillard-github-io'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script');
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <!-- End Disqus Code -->
    <!-- Google Analytics Universal -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-91585967-1', '');
        ga('send', 'pageview');
    </script>
    <!-- End Google Analytics Universal Code -->


</body>
</html>