\documentclass[12pt]{article}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{suffix}
\usepackage{color}

% Sadly, can't use this because it breaks greek letters.
%\usepackage[slantedGreek]{mathpazo}
\usepackage{breqn}

\usepackage{todonotes}
\usepackage{draftwatermark}
\SetWatermarkScale{1}
\SetWatermarkLightness{0.90}

% used by Pweave
\usepackage{graphicx}

\definecolor{bg}{rgb}{0.95,0.95,0.95}
\usepackage[backgroundcolor=bg, topline=false, bottomline=false, leftline=false, rightline=false]{mdframed}

<<pweave_code, echo=False, evaluate=False>>=
from pynoweb_tools.editor_utils import nvim_weave

input_file_base = nvim_weave(rel_figdir='../figures',
                             rel_outdir="./",
                             format_opts={'width': r'\textwidth',
                                          'figfmt': '.png',
                                          'savedformats': ['.png', '.pdf']})

# Compile document to markdown
assert os.system('make {}.pdf'.format(input_file_base)) == 0
assert os.system('make {}.md'.format(input_file_base)) == 0
@

\usepackage{minted}
\setminted{ fontsize=\footnotesize , breaklines=true , breakanywhere=true ,
breakautoindent=true }

% this order is important
%\PassOptionsToPackage{hyphens}{url}
\RequirePackage[hyphens]{url}
\RequirePackage[colorlinks,citecolor=blue,urlcolor=blue]{hyperref}
\usepackage[authoryear]{natbib}

% Apparently cleveref must always be last.
\usepackage{cleveref}
\allowdisplaybreaks

\include{math-commands}

\newcommand{\GordyPhi}{{\Phi_{1}}^\star}
\newcommand{\HornPhi}{\Phi_{2}}
\newcommand{\err}{\ensuremath{\text{err}}}
\newcommand{\Err}{\ensuremath{\text{Err}}}
\newcommand{\hatmu}{\ensuremath{\hat{\mu}}}
\newcommand{\bhatmu}{\ensuremath{\hat{\bmu}}}

\graphicspath{{../../figures/}{../figures/}{./figures/}{./}}

<<sympy_setup, echo=False, results='hidden'>>=

#import numpy as np
#import mpmath as mp
import sympy as sp

import hsplus

#import matplotlib.pyplot as plt
#plt.style.use('ggplot')
#plt.rc('text', usetex=True)
#plot_cmap = plt.cm.YlOrRd

sp.init_printing(
    use_latex='mathjax',
    order='grlex',
    latex_mode='equation',
    #ip=get_ipython(),
    pretty_print=True,
    use_unicode=False,
    num_columns=80,
    wrap_line=True
)
#sp.init_printing(pretty_print=True, use_unicode=True,
#                 wrap_line=True, num_columns=79)

@

\title{SymPy Expression Tree Manipulation}

\author{Brandon Willard}

\date{2016-10-27}


\begin{document}

\maketitle
%\begin{abstract}
%\end{abstract}

I've been working on some extensions to our special function computations in
\href{https://arxiv.org/abs/1605.04796}{Prediction risk for global-local shrinkage regression}
and decided to employ \href{https://github.com/sympy/sympy}{SymPy} as much as possible.  Out of this came
an
\href{https://bitbucket.org/bayes-horseshoe-plus/hsplus-python-pkg/src/master/hsplus/horn_symbolic.py}{implementation}
of a bivariate confluent hypergeometric function: the \href{https://en.wikipedia.org/wiki/Humbert_series}{Humbert}
$\Phi_1$.  This, and some numeric implementations, are available in a
\href{https://bitbucket.org/bayes-horseshoe-plus/hsplus-python-pkg}{Python package}
and an \href{https://bitbucket.org/bayes-horseshoe-plus/hsplus-r-pkg}{R package}.

In the course of this work there are expectations that appear as ratios of $\Phi_1$
functions, so it's helpful to have a symbolic replacement routine to identify them.
\href{http://docs.sympy.org/dev/modules/core.html#sympy.core.basic.Basic.match}{Pattern matching},
\href{http://docs.sympy.org/dev/modules/core.html#sympy.core.basic.Basic.find}{finding},
substitution and
\href{http://docs.sympy.org/dev/modules/core.html#sympy.core.basic.Basic.replace}{replacement}
are fairly standard in SymPy, so nothing
special there; however, when you want something specific, it can get rather tricky.

Personally, I've found the approach offered by the
\href{https://github.com/sympy/sympy/tree/master/sympy/strategies}{\texttt{sympy.strategies}}
and \href{https://github.com/sympy/sympy/tree/master/sympy/unify}{\texttt{sympy.unify}} frameworks
the most appealing.  See the original discussion
\href{https://groups.google.com/d/msg/sympy/fspCavhbd9I/vrzUitvgiuYJ}{here}.
The reason for their appeal is mostly due to their organization of the processes behind
expression tree traversal and manipulation.  It's much easier to see how a very specific and
non-trivial simplification or replacement could be accomplished and iteratively improved.
These points are made very well in the posts \href{http://matthewrocklin.com/blog/tags.html#SymPy-ref}{here},
so check them out.



Let's say we want to write a function \texttt{as\_expectations} that takes
a \texttt{sympy.Expr} and replaces ratios of $\Phi_1$ functions according to
the following pattern:
\begin{equation}
E[X^n] = \frac{\Phi_1(\alpha, \beta, \gamma + n; x, y)}{\Phi_1(\alpha, \beta, \gamma; x, y)}
\;.
\label{eq:expectation}
\end{equation}

As an example, let's set up a situation in which \texttt{as\_expectations} would be used, and, from
there, attempt to construct our function.  Naturally, this will involve a test expression with terms
that we know match \Cref{eq:expectation}:
<<echo=True>>=
import sympy as sp

from hsplus.horn_symbolic import HornPhi1

a, b, g, z_1, z_2 = sp.symbols('a, b, g, z_1, z_2', real=True)
phi1_1 = HornPhi1((a, b), (g,), z_1, z_2)

n = sp.Dummy('n', integer=True, positive=True)
i = sp.Dummy('i', integer=True, nonnegative=True)

phi1_2 = HornPhi1((a, b), (g + n,), z_1, z_2)
phi1_3 = HornPhi1((a, b), (g + n - i,), z_1, z_2)

r_1 = phi1_2/phi1_1
r_2 = phi1_3/phi1_1

expr = a * r_1 - b * r_1 / g + sp.Sum(z_1/z_2 * r_2 - 3 * r_2, (i, 0, n))
@

Our test expression \texttt{expr} looks like this
<<results='latex'>>=
print(sp.latex(expr, mode='equation*', itex=True))
@

The ratios \texttt{r\_1} and \texttt{r\_2} should both be replaced by a symbol for $E[X^m]$,
for $m = n$ and $m = n - i$ when $i < n$ respectively.  We could allow
$E[X^0]$, I suppose, but--for a more interesting discussion--let's not.

We start by creating a SymPy pattern that expresses the mathematical form of $E[X^m]$
in \Cref{eq:expectation}.
<<evaluate=True, echo=True>>=
pnames = ('a', 'b', 'g', 'z_1', 'z_2')
phi1_wild_args_n = sp.symbols(','.join(n_ + '_w' for n_ in pnames),
                              cls=sp.Wild, real=True)

n_w = sp.Wild('n_w',
              properties=(lambda x: x.is_integer and x.is_positive,),
              exclude=(phi1_wild_args_n[2],))

phi1_wild_d = HornPhi1(phi1_wild_args_n[0:2],
                       phi1_wild_args_n[2:3],
                       *phi1_wild_args_n[3:5])

phi1_wild_n = HornPhi1(phi1_wild_args_n[0:2],
                       (phi1_wild_args_n[2] + n_w,),
                       *phi1_wild_args_n[3:5])

C_w = sp.Wild('C_w', exclude=[sp.S.Zero])
E_pattern = phi1_wild_n / phi1_wild_d

E_fn = sp.Function("E", real=True)
@
When we find an $E[X^m]$ we'll replace it with the symbolic function \texttt{E\_fn}.

If we focus on only one of the terms (one we know matches \texttt{E\_pattern}),
\texttt{r\_1}, we should find that our pattern suffices:
<<evaluate=True, term=True>>=
r_1.match(E_pattern)
@

However, building up to the complexity of \texttt{expr}, we see that a
simple product doesn't:
<<evaluate=True, term=True>>=
(a * r_1).match(E_pattern)
@
Basically, the product has introduced some problems that arise from associativity.
Here are the details for the root expression tree:
<<evaluate=True, term=True>>=
(a * r_1).func
(a * r_1).args
@
The root operation is multiplication and the operation's arguments are all terms
in the product/division.

Any complete search for matches to \texttt{E\_pattern} would have to consider all
possible combinations of terms in
\texttt{(a * r\_1).args}, i.e. all possible groupings that arise due to
associativity.
The simple inclusion of another \texttt{Wild} term causes the match to succeed, since
SymPy's basic pattern matching does account for associativity in this case.

Here are a few explicit ways to make the match work:
<<evaluate=True, term=True>>=
(a * r_1).match(C_w * E_pattern)
@
or as a replacement:
<<evaluate=True, results='latex'>>=
res = (a * r_1).replace(C_w * E_pattern, C_w * E_fn(n_w, *phi1_wild_args_n))
print(sp.latex(res, mode='equation*', itex=True))
@
and via \texttt{rewriterule}:
<<evaluate=True, results='latex'>>=
from sympy.unify.rewrite import rewriterule
rl = rewriterule(C_w * E_pattern,
                 C_w * E_fn(n_w, *phi1_wild_args_n),
                 phi1_wild_args_n + (n_w, C_w))
res = list(rl(a * r_1))
print(sp.latex(res, mode='equation*', itex=True))
@

The advantage in using \texttt{rewriterule} is that multiple matches will
be returned.  If we add another $\Phi_1$ in the numerator, so there are
multiple possible $E[X^m]$, we get
<<evaluate=True, results='latex'>>=
phi1_4 = HornPhi1((a, b), (g + n + 1,), z_1, z_2)

res = list(rl(a * r_1 * phi1_4))
print(sp.latex(res, mode='equation*', itex=True))
@
FYI: the associativity of terms inside the function arguments is causing the
seemingly duplicate results.

Naive use of \texttt{Expr.replace} doesn't give all results; instead, it
does something likely unexpected:
<<evaluate=True, results='latex'>>=
res = (a * r_1 * phi1_4).replace(C_w * E_pattern,
                                 C_w * E_fn(n_w, *phi1_wild_args_n))
print(sp.latex(res, mode='equation*', itex=True))
@


Returning to our more complicated \texttt{expr}\dots
Just because we can match products doesn't mean we're finished, since we still need
a good way to traverse the entire expression tree and match the sub-trees.
More importantly, adding the multiplicative \texttt{Wild} term \texttt{C\_w} is
more of a hack than a direct solution, since we don't want the matched contents of
\texttt{C\_w}.

Although \texttt{Expr.replace/xreplace} will match sub-expressions, we found
above that it produces some odd results.  Those results persist when applied
to more complicated expressions:
<<evaluate=True, results='latex'>>=
res = expr.replace(C_w * E_pattern, C_w * E_fn(n_w, *phi1_wild_args_n))
print(sp.latex(res, mode='equation*', itex=True))
@

Again, it looks like the matching was a little too liberal and introduced extra
\texttt{E} and \texttt{HornPhi1} terms.
This is to be expected from the \texttt{Wild} matching in SymPy; it needs us to specify
what \emph{not} to match, as well.
Our ``fix'' that introduced \texttt{C\_w} is the exact source of the problem, but
we can tell it not to match \texttt{HornPhi1} terms and get better results:
<<evaluate=True, results='latex'>>=
C_w = sp.Wild('C_w', exclude=[sp.S.Zero, HornPhi1])
res = expr.replace(C_w * E_pattern, C_w * E_fn(n_w, *phi1_wild_args_n))
print(sp.latex(res, mode='equation*', itex=True))
@

We've stopped it from introducing those superfluous \texttt{E} terms, but we're still not
getting replacements for the \texttt{HornPhi1} ratios in the sums.  Let's single
out those terms and see what's going on:
<<evaluate=True, results='latex'>>=
res = r_2.find(C_w * E_pattern)
print(sp.latex(res, mode='equation*', itex=True))
@

The constrained integer \texttt{Wild} term, \texttt{n\_w}, probably isn't matching.  Given the form
of our pattern, \texttt{n\_w} should match \texttt{n - i}, but \texttt{n - i} isn't strictly positive, as
required:
<<evaluate=True, term=True>>=
(n - i).is_positive == True
sp.ask(sp.Q.positive(n - i)) == True
@

Since $n > 0$ and $i >= 0$, the only missing piece is that $n > i$.
The most relevant mechanism in SymPy to assess this information is the
\href{http://docs.sympy.org/dev/modules/assumptions/index.html}{\texttt{sympy.assumptions}}
interface.  We could add and retrieve the assumption \texttt{sympy.Q.is\_true(n > i)} via
\texttt{sympy.assume.global\_assumptions}, or perform these operations inside of a Python \texttt{with} block,
etc.  This context management, via \texttt{sympy.assumptions.assume.AssumptionsContext},
would have to be performed manually, since I am not aware of any such mechanism offered
by \texttt{Sum} and/or \texttt{Basic.replace}.

Unfortunately, these ideas sound good, but aren't implemented:
<<evaluate=True, term=True>>=
sp.ask(sp.Q.positive(n - i), sp.Q.is_true(n > i)) == True
@

See the documentation for \texttt{sympy.assumptions.ask.ask}; it explicitely states
that inequalities aren't handled, yet.

We could probably perform a manual reworking of \texttt{sympy.Q.is\_true(n > i)} to
\texttt{sympy.Q.is\_true(n - i > 0)}, which is of course equivalent to \texttt{sympy.Q.positive(n - i)}:
the result we want.

If one were to provide this
functionality, there's still the question of how the relevant \texttt{AssumptionsContext}s
would be created and passed around/nested during the subexpression replacements.
There is no apparent means of adding this sort of functionality through the
\texttt{Basic.replace} interface, so this path looks less appealing.
However, nesting \texttt{with} blocks from strategies in \texttt{sympy.strategies} does seem
quite possible.
For example, in \texttt{sympy.strategies.traverse.sall}, one could possibly wrap the
\texttt{return} statement after the \texttt{map(rule, ...)} call in a
\texttt{with sympy.assuming(...):} block
that contains the assumptions for any variables arising as, say, the index of a
\texttt{Sum}--like in our case.  In this scenario, code in the subexpressions would
be able to ask questions like \texttt{sympy.Q.is\_true(n > i)} without altering the global
assumptions context or the objects involved.


Anyway, that's all I wanted to cover here.  Perhaps later I'll post a hack for the
assumptions approach, but--at the very least--I'll try to follow up with a more
direct solution that uses \texttt{sympy.strategies}.

\end{document}
