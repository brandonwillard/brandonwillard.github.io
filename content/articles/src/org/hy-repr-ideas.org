#+TITLE: Readable Strings and Relational Programming in Hy
#+AUTHOR: Brandon T. Willard
#+DATE: 2018-12-20
#+EMAIL: brandonwillard@gmail.com
#+FILETAGS: :hy:relational programming:python:

#+STARTUP: hideblocks indent hidestars
#+OPTIONS: author:t date:t ^:nil toc:nil title:t tex:t d:(not todo notes logbook) html-preamble:t
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../extra/custom.css" />
#+STYLE: <link rel="stylesheet" type="text/css" href="../extra/custom.css" />

# #+INCLUDE: org-setup.org

#+PROPERTY: header-args :eval never :exports both :results output drawer replace
#+PROPERTY: header-args+ :session eval-thoughts

#+BEGIN_abstract
Just some thoughts on a generalized src_python[:eval never]{repr} for Hy and
some connections with relational programming.
#+END_abstract

* Introduction
In the past few months, I've been working on [[https://github.com/hylang/hy][Hy]] a lot.  It's been great for
translating symbolic computation ideas originating in the Lisp community or
simply performing the generic meta-programming inherent to the subject.

One feature I've been missing the most is "readable" print-outs from the REPL.
In this case, "readable" means "a string that can be src_python{eval}'ed to
[re-]produce the object it's meant to represent".
[[https://docs.python.org/3/library/functions.html#repr][Python calls the function(s) that produce these strings "src_python{repr}"s]] and
provides a generic src_python[:eval never]{repr} function--with limited Python
"readability" guarantees--and a src_python[:eval never]{__repr__} property for
object/class-level customization.

:EXAMPLE:
#+NAME: repr-demo
#+BEGIN_SRC python :eval never-export :results output :wrap "SRC python :eval never"
test_obj = {"a": 1, "b": [2, 3]}

# Produce a readable string using `repr`
obj_repr_str = repr(test_obj)
print(obj_repr_str)

# Re-create the object from its readable string form
obj_from_repr = eval(obj_repr_str)
print(obj_from_repr)

print(test_obj == obj_from_repr)
#+END_SRC

#+RESULTS: repr-demo
#+BEGIN_SRC python :eval never
{'a': 1, 'b': [2, 3]}
{'a': 1, 'b': [2, 3]}
True


#+END_SRC
:END:

There's already a src_hy[:eval never]{hy.contrib.hy-repr} module that gets most
of the way there, but it doesn't implement the Python standard
library's src_python[:eval never]{reprlib.Repr}.  The
class src_python[:eval never]{reprlib.Repr} implements limits for the display
lengths of the strings it produces, and its source code provides a few standard
library implementations of primitive
object src_python[:eval never]{repr}s--which require only trivial changes to
produce the desired Hy syntax.

For these reasons--and an overall interest in using and translating more of the
Python standard library to Hy--I decided to try a quick refactoring
of src_hy[:eval never]{hy.contrib.hy-repr} that implements
src_python[:eval never]{reprlib.Repr}.

* The Hy src_python{repr} Problem(s)
The translation of Hy AST to string form is fairly straight-forward.  In most cases,
one only needs to change the src_python{repr}s for Python primitives and basic function
calls (e.g. from src_python[:eval never]{func(1)} to src_hy[:eval never]{(func 1)});
however, changing just a couple lines
in src_python[:eval never]{repr}/src_python[:eval never]{__repr__} functions for
all the Python builtins is very annoying.

Furthermore, what about those custom object src_python[:eval never]{__repr__} methods?
While one might be able to manually patch most--if not all--of the (Python-implemented)
standard library objects, there are far too many 3rd-party
library src_python[:eval never]{__repr__}s with exactly the same trivial
function-call form that can't reasonably be patched.

** Some approaches
The first few things that come to mind when considering a more general approach to
Python-to-Hy src_python[:eval never]{__repr__} translation involve some use of the
existing src_python[:eval never]{repr} code.  That might come in the form of
string manipulation of src_python[:eval never]{repr} output,
which src_hy[:eval never]{hy.contrib.hy-repr} already does in some cases, or
quite possibly some use of a src_python[:eval never]{repr} function's
source or code object.

The latter seems like it has the potential to be more thorough and far-reaching,
but also considerably more involved and computationally inefficient.
Unfortunately, similar things can be said about the regex approach.  Although it
does seem a little easier to implement and--for limited cases--efficient enough
for most purposes, it also comes across as much more brittle.

Fortunately, the latter is unnecessary, because, when the
existing src_python[:eval never]{repr} output is Python readable, it can be
parsed by src_python[:eval never]{ast.parse}.  The
function src_python[:eval never]{ast.parse} effectively handles the regex work
and yields the bulk of information needed for a Hy src_python[:eval never]{repr}
string: the function name and its (positional and keyword) arguments.

:EXAMPLE:
Let's say we implement our own object and src_python[:eval never]{repr}.
#+NAME: test-obj
#+BEGIN_SRC hy :eval never-export :results output :wrap "SRC python :eval never"
(defclass TestClass [object]
  (defn --init-- [self arg1 arg2 &optional kwarg1 kwarg2]
    (setv self.arg1 arg1
          self.arg2 arg2
          self.kwarg1 kwarg1
          self.kwarg2 kwarg2))
  (defn --repr-- [self]
    (.format "TestClass({}, {}, kwarg1={}, kwarg2={})"
             #* (lfor a [self.arg1 self.arg2
                         self.kwarg1 self.kwarg2]
                      (repr a)))))

(setv test-obj (TestClass 1 {"a" 1 "b" 2} :kwarg1 1 :kwarg2 "ok"))
(print (repr test-obj))
#+END_SRC

#+RESULTS: test-obj
#+BEGIN_SRC python :eval never
TestClass(1, {'a': 1, 'b': 2}, kwarg1=1, kwarg2='ok')
#+END_SRC

Since the results are readable, we can do the following:
#+NAME: test-obj-ast
#+BEGIN_SRC hy :eval never-export :results output :wrap "SRC python :eval never"
(import ast astor)
(setv repr-ast (ast.parse (repr test-obj) :mode "eval"))
(print (astor.dump repr-ast))
#+END_SRC

#+RESULTS: test-obj-ast
#+BEGIN_SRC python :eval never
Expression(
    body=Call(func=Name(id='TestClass'),
              args=[Num(n=1),
                    Dict(keys=[Str(s='a'), Str(s='b')],
                         values=[Num(n=1), Num(n=2)])],
              keywords=[keyword(arg='kwarg1', value=Num(n=1)),
                        keyword(arg='kwarg2', value=Str(s='ok'))]))
#+END_SRC
:END:
** A Generalized Hy src_python{repr} Prototype

With existing src_python{repr} output converted to Python AST by Python itself
(using src_python{ast.parse}), we can produce readable Hy strings from the
resulting AST objects.

In this scenario, we need only be concerned with the conversion of Python AST
into readable Hy strings.  This works like an inverse to the Hy compiler: in other
words, a Hy decompiler.  For src_python{repr} purposes, only function call
statements and their arguments need to be decompiled.  Unfortunately, function
arguments can consist of arbitrary Python/Hy objects, and that's
how the decompilation responsibilities start to expand.  If we limit our scope
to a reasonable subset of Python builtins/primitives, the results can still be
quite effective, and won't require a complete decompiler.

On the down-side, if a Hy src_python{repr} implementation overrides the
built-in src_python{repr}, then arguments in existing src_python{repr}/src_python{__repr__}s
might already be converted by the overridden src_python{repr}; however, the results
from src_python{ast.parse} will undo/discard those results.  Even so, custom
class src_python{__repr__}s aren't guaranteed to use the
built-in src_python{repr} on their arguments, so attempts to salvage
already-converted src_python{repr} output are undeniably fraught with
complications.

:EXAMPLE:
Working from the src_python[:eval never]{repr}-produced AST above, I mocked-up a
quick prototype for a generic Python-to-Hy conversion function.

#+NAME: ast-funcall-to-hy
#+BEGIN_SRC hy :eval never-export :results output :wrap "SRC hy :eval never"
(import ast)
(import builtins)

(import [hy.contrib.hy-repr [hy-repr :as -hy-repr]])

(defn ast-funcall-to-hy [ast-obj repr1
                         &optional [level 1]]
  "Turn Python `ast.Call` expressions into Hy `repr` strings.

XXX: Only a very minimal subset of Python-to-Hy AST is implemented.

This can be used to turn a \"readable\" `repr` result, via an actual \"read\" by
`ast.parse`, to Python AST then Hy AST.
"
  (assert (and (instance? ast.Expression ast-obj)
               (instance? ast.Call ast-obj.body)))
  (setv func-name (. ast-obj body func id))
  (setv eval-fn (fn [o]
                  (if (instance? ast.Name o)
                      o.id
                      (repr1 (ast.literal-eval o) (dec level)))))
  (setv func-args (lfor a (. ast-obj body args) (eval-fn a)))
  (setv func-kwargs (lfor k (. ast-obj body keywords)
                          (.format ":{} {}" k.arg (eval-fn k.value))))
  (.format "({})" (.join " " (+ [func-name] func-args func-kwargs))))


(setv test-ast (ast.parse "range(x, y, blah=1, bloh=\"ok\")" :mode "eval"))
(print (ast-funcall-to-hy test-ast (fn [x &rest y] (-hy-repr x))))
#+END_SRC

#+RESULTS: ast-funcall-to-hy
#+BEGIN_SRC hy :eval never
(range x y :blah 1 :bloh "ok")
#+END_SRC

src_python{ast-funcall-to-hy} is an extremely narrow decompiler that only
handles readable function calls (represented by src_python{ast.Call} nodes),
but, as part of a fallback sequence in a Hy src_hy{repr} implementation, it's
still pretty useful.

A function like src_python{ast-funcall-to-hy} can be used in src_python{repr}
logic as follows:
#+NAME: hy-repr
#+BEGIN_SRC hy :eval never-export :results none
(defn hy-repr [x &optional [level 1] [-repr (fn [x &rest y] (-hy-repr x))]]
  "Use `builtin.repr` results to generate readable Hy `repr` strings for cases
we haven't covered explicitly.
"
  (try
    (setv s (builtins.repr x))
    (when (not (.startswith s "<"))
      (do
        (setv repr-ast (ast.parse s :mode "eval"))
        (setv s (ast-funcall-to-hy repr-ast -repr))))
    s
    (except [Exception]
      (.format "<{} instance at {}>" x.__class__.__name__ (id x)))))
#+END_SRC

Now, for the example class, src_python{TestClass}, we can demonstrate automatic
conversion of its Python src_python{__repr__} implementation.
#+NAME: hy-repr-exa
#+BEGIN_SRC hy :eval never-export :results output :wrap "SRC text :eval never"
(setv test-ast (TestClass 1 {"a" 2 "b" 3} :kwarg1 1 :kwarg2 "ok"))
(print (.format "before: {}\nafter: {}"
                (repr test-ast)
                (hy-repr test-ast)))
#+END_SRC

#+RESULTS: hy-repr-exa
#+BEGIN_SRC text :eval never
before: TestClass(1, {'a': 2, 'b': 3}, kwarg1=1, kwarg2='ok')
after: (TestClass 1 {"a" 2  "b" 3} :kwarg1 1 :kwarg2 "ok")
#+END_SRC
:END:
* Relational Programming
While considering all this, I kept thinking about how nice it would be to have
a "bijective" compiler; in other words, the existing Hy compiler, which translates
Hy-to-Python, *and* a Python-to-Hy (de)compiler.  With a Python-to-Hy AST
compiler, we could more broadly convert Python AST output--like the kind in our
example above--to a src_python[:eval never]{repr}/readable string in Hy.

The idea isn't too crazy, especially since one can easily work backward from a
lot of the logic in the existing Hy compiler.  There will be some
edge cases that result in non-bijective translations (i.e. some round-trip
Hy/Python translations might only be *equivalent* and not exactly *equal*), but
this isn't necessarily a blocking issue.  Decisions regarding "canonical" or
reduced forms of Hy/Python AST might be necessary, especially if the resulting AST
is intended to be more human readable than not.

Perhaps what's more discouraging is the effort it would take to ensure that the
compilation processes going both ways are--and stay--coherent during the course
of development.  For instance, when changes are made to the standard compilation
process (i.e. Hy-to-Python), it's likely that changes and tests would also be
needed for the other direction.

This is where a paradigm like relational programming is particularly appealing:
it provides a language for defining--and means for computing--the maps
# \newcommand{\ra}[1]{\kern-1.5ex\xrightarrow{\ \ #1\ \ }\phantom{}\kern-1.5ex}
# \newcommand{\ras}[1]{\kern-1.5ex\xrightarrow{\ \ \smash{#1}\ \ }\phantom{}\kern-1.5ex}
# \newcommand{\da}[1]{\bigg\downarrow\raise.5ex\rlap{\scriptstyle#1}}
# \begin{array}{ccc}
# \text{Hy Syntax} & \ra{\text{astor}} & \text{Python} \\
# \searrow & \text{Python AST} & \nearrow
# \end{array}
\begin{equation*}
  \text{Hy Syntax}
  \longleftrightarrow \text{Python AST}
  \longleftrightarrow \text{Python Syntax}
  \;
\end{equation*}
in a cohesive way.

My relational programming DSL of choice, [[http://minikanren.org][miniKanren]], already has an
implementation in Hy: [[https://github.com/algernon/adderall][=loghyc= (and to be formally known as =adderall=)]].  We've
been using it to perform static code analysis and refactoring in the project
[[https://github.com/hylang/hydiomatic][=hydiomatic=]], so there's also a precedent for parsing Hy syntax in a relational
context.

The missing/next step would be to output Python AST (instead of more Hy forms,
like =hydiomatic= produces, for example).  In the following sections, we will
construct a small relational Hy/Python compiler as a proof-of-concept.

** A Prototype Relational Compiler

Creating a bi-directional Hy/Python AST compiler in miniKanren involves the
construction of goals "relating" the two AST forms.  For simplicity, we'll just
consider function call expressions, like src_python{func(args)}
and src_hy{(func args)}.

:remark:
Also, since these kinds of relations are more easy to specify using constraints
and subtle unification adjustments, we'll use a prototype microKanren
implementation in Hy that provides immediate access to those: [[https://github.com/brandonwillard/hypoKanren][src_hy{hypoKanren}]].

Regardless, given the universality of miniKanren, the goals we construct should
be directly translate-able to other implementations of miniKanren (even in
completely different host languages).

The only obvious caveat to such translation is the availability of
traditional src_hy{cons} semantics in the host language (i.e. the standard Lisp
behavior of src_hy{cons}, src_hy{car}, src_hy{cdr}, and improper
lists/src_hy{cons} pairs).
:END:

#+NAME: miniKanren-imports
#+BEGIN_SRC hy :eval never-export :exports code :results silent
(import ast)
(import astor)
(import types)
(import [collections [Callable]])

(import hy.models)
(import [hy.compiler [asty hy-eval hy-compile]])

(import [hypoKanren.goals [*]])
(import [hypoKanren.core [*]])


(require [hy.contrib.walk [let]])
(require [hypoKanren.goals [*]])
(require [hypoKanren.core [*]])
#+END_SRC

First, let's examine the general structure of the Python AST output generated by
the Hy compiler for the Hy function-call given by src_hy{`(func x :y z)}.
#+NAME: fn_form_ast
#+BEGIN_SRC hy :eval never-export :results value :exports both :wrap "SRC python :eval never"
(astor.dump (hy-compile `(func x :y z) "__console__"))
#+END_SRC

#+RESULTS: fn_form_ast
#+begin_SRC python :eval never
Module(
    body=[Expr(value=Call(func=Name(id='func'), args=[Name(id='x')], keywords=[keyword(arg='y', value=Name(id='z'))]))])
#+end_SRC

In what follows, we'll exclude the src_python{ast.Module} and focus only on
the src_python{src.Expr} and its children.

*** AST Object Unification

To make existing Python AST objects amenable to the [[https://en.wikipedia.org/wiki/Unification_(computer_science)][unification]] used by
miniKanren, we implement src_hy{unify} specializations for src_python{ast.AST}
types.  Our implementation simply generates unevaluated Hy forms, or Hy AST,
that--when evaluated--would (re)create the src_python{ast.AST} objects.

#+BEGIN_REMARK
Alternatively, we could only ever use and create unevaluated Hy forms for Python AST.
Providing unification for AST objects allows for more immediate integration with existing
Python code and/or what it would most likely produce.
#+END_REMARK

src_hy{hypoKanren} uses [[https://github.com/mrocklin/multipledispatch][src_python{multipledispatch}]], so augmenting the
unification process is easy.  This is how we'll add support for AST objects.

#+BEGIN_REMARK
There's already a good pure Python library for unification built
upon src_python{multipledispatch}, [[https://github.com/mrocklin/unification][src_python{unfication}]].  At a later time, it
might be worthwhile to simply add support for Hy objects and use that library
instead.
#+END_REMARK

#+NAME: py-ast-to-expr
#+BEGIN_SRC hy :eval never-export :exports code :results silent
(import [multipledispatch [dispatch]])
(import [hypoKanren.unify [*]])
(import [hy.models [*]])
(import [hy.contrib.walk [prewalk]])


(defmacro/g! dispatch-unify-trans [disp-type trans-func &optional [func 'unify]]
  `(do
     #@((dispatch ~disp-type object object)
        (defn unify-post-walk [~g!u ~g!v ~g!s]
          (~func (~trans-func ~g!u) ~g!v ~g!s)))
     #@((dispatch object ~disp-type object)
        (defn unify-post-walk [~g!u ~g!v ~g!s]
          (~func ~g!u (~trans-func ~g!v) ~g!s)))
     #@((dispatch ~disp-type ~disp-type object)
        (defn unify-post-walk [~g!u ~g!v ~g!s]
          (~func (~trans-func ~g!u) (~trans-func ~g!v) ~g!s)))))

(defn py-ast-to-expr [x]
  (defn -py-ast-to-expr [u]
    (setv ast-expr
          `(~(HySymbol (+ "ast." (name (type u))))
            ~@(chain.from-iterable
                (lfor f u.-fields
                      :if (hasattr u f)
                      [(HyKeyword f) (getattr u f)]))))
    ast-expr)
  (prewalk (fn [y] (if (instance? ast.AST y)
                       (-py-ast-to-expr y)
                       y))
           x))

;; Python AST expansion pre-unification
(dispatch-unify-trans ast.AST (fn [x] (py-ast-to-expr x)))
#+END_SRC

:example:
#+NAME: ast-to-expr-exa
#+BEGIN_SRC hy :eval never-export :results value :wrap "SRC python :eval never"
;; One is an `ast.AST` object, the other an unevaluated `ast.AST`
;; object-generating form.
(setv unify-exa-1 (unify (ast.Expr :value [])
                         `(ast.Expr :value ~(var 0))
                         {}))

;; Both are `ast.AST` objects
(setv unify-exa-2 (unify (ast.Expr :value [])
                         (ast.Expr :value (var 0))
                         {}))

(= (.get unify-exa-1 (var 0))
   (.get unify-exa-2 (var 0))
   [])
#+END_SRC

#+RESULTS: ast-to-expr-exa
#+begin_SRC python :eval never
True
#+end_SRC

Listing [[ast-to-expr-exa]] illustrates unification of two src_python{ast.AST}
forms.  The src_hy{(var 0)} objects are "logic variables" taking the value of
sub-expressions that cause the two src_hy{unify} arguments to, well, unify.  The
third argument to src_hy{unify} is simply a src_python{dict} that stores the logic
variable/sub-expression mappings.

In other words, logic variables are like unknowns that src_hy{unify(u, v, s)}
will "solve" in order to make src_hy{u} and src_hy{v} equal.
:END:

:example:
#+NAME: ast-to-expr-exa-2
#+BEGIN_SRC hy :eval never-export :results value :wrap "SRC python :eval never"
(unify (cons 'ast.Expr (var 0))
       (ast.Expr :value [(ast.Name :id "a")])
       {})
#+END_SRC

#+RESULTS: ast-to-expr-exa-2
#+begin_SRC python :eval never
{(LVar 0): HyExpression([
  HyKeyword('value'),
  [HyExpression([
    HySymbol('ast.Name'),
    HyKeyword('id'),
    'a'])]])}
#+end_SRC

Listing [[ast-to-expr-exa-2]] is a more interesting example that demonstrates
partial/improper list unification.  Since src_python{ast.AST} objects are
expanded into equal object-instantiating Hy AST
forms, src_hy{(cons 'ast.Expr (var 0))} is ultimately unified with
a src_python{HyExpression} (a subclass of src_python{list}).  Under
the src_hy{cons} abstraction, src_hy{(var 0)} can be anything
that--when src_hy{cons}ed with the symbol src_hy{ast.Expr}--will produce the
expression src_hy{(ast.Expr :value [(ast.Name :id "a")])}.  The result is the
partial src_python{HyExpression} comprising the arguments to
the src_python{ast.Expr} constructor--in other words, the src_hy{cdr} of
the src_python{ast.AST} form.
:END:

We will also need to unify some limited Hy AST forms;
specifically, src_python{HySymbol}s.  We will want to extract only the name part
of a Hy symbol and relate that to Python src_python{ast.Name}s via one of the
latter's constructor arguments.

Similar to Python AST nodes, we will expand/lift/abstract src_python{HySymbol}s
to Hy expressions that--when src_hy{eval}'ed--would construct them.  We can only do
this in very limited cases; otherwise, we could end up producing ever-expanding forms.
#+NAME: hy-obj-to-expr
#+BEGIN_SRC hy :eval never-export :exports code :results silent
;; Hy AST expansion pre-unification
(defn unify-hysymbol [u v s]
  (cond
    [(= (first v) 'HySymbol)
     (print )
     (unify `(HySymbol ~(name u)) v s)]
    [True
     (unify u v s)]))

#@((dispatch HySymbol HyExpression object)
   (defn unify-post-walk [u v s]
     (unify-hysymbol u v s)))

#@((dispatch HyExpression HySymbol object)
   (defn unify-post-walk [u v s]
     (unify-hysymbol v u s)))
#+END_SRC

:example:
#+NAME: hy-ast-to-expr-exa
#+BEGIN_SRC hy :eval never-export :results value :wrap "SRC python :eval never"
(unify 'a `(HySymbol ~(var 0)) {})
#+END_SRC

#+RESULTS: hy-ast-to-expr-exa
#+begin_SRC python :eval never
{(LVar 0): 'a'}
#+end_SRC

Listing [[hy-obj-to-expr]] demonstrates the expansion and unification of Hy AST symbols.
:END:

*** Call-expression Goals
Next, we create the miniKanren goals that encapsulate the relationships between
simple Hy and Python AST forms.  In particular, we'll limit ourselves to only
variable reference and function call forms.

#+NAME: hy_py_goals_setup
#+BEGIN_SRC hy :eval never-export :exports code :results silent
(defn listo [l]
  "A goal stating that `l` is a list."
  (conde
    [(== l []) s#]
    [(fresh [lcar lcdr]
            (== l (cons lcar lcdr))
            (listo lcdr))]
    [s# u#]))
#+END_SRC

The first AST relation is a simple one between src_python{HySymbol}s
and src_python{ast.Name}s.  This is where the src_python{HySymbol} unification
implemented above is used.
#+NAME: hy_py_symbolo
#+BEGIN_SRC hy :eval never-export :exports code :results silent
(defn hy-py-symbolo [hy-ast py-ast]
  "A goal relating Hy and Python AST symbol/name objects (e.g. variable and
 function references)."
  (fresh [symbol-name py-ctx]
         (== hy-ast `(HySymbol ~symbol-name))
         (== py-ast `(ast.Name :id ~symbol-name
                               :ctx (ast.Load)))))
#+END_SRC

#+NAME: hy_py_symbolo_tests
#+BEGIN_SRC hy :eval never-export :exports none :results none
(defn test-hy-py-symbolo []
  ;; XXX: `ast` objects do not have field-based equality!
  (assert (= [[`(ast.Name :id "a" :ctx (ast.Load))]]
             (run 1 [res] (hy-py-symbolo 'a res))))
  (assert (= [[`(HySymbol "x")]]
             (run 1 [res] (hy-py-symbolo res (. (ast.parse "x" :mode "eval") body))))))
(test-hy-py-symbolo)
#+END_SRC

Some Python src_python{ast.AST} types have fields consisting of lists containing
other src_python{ast.AST} objects (e.g. the src_python{ast.Call} expressions below).
We need a goal that enforces a relation between the Hy and Python AST forms of
each element in such lists.
#+NAME: hy_py_lapplyo
#+BEGIN_SRC hy :eval never-export :exports code :results silent
(defn lapplyo [func l-in l-out]
  "A goal that applies the goal `func` between all elements in lists `l-in` and
 `l-out`."
  (conj+
    (listo l-in)
    (conde
      [(fresh [lcar lcdr lout-car lout-cdr]
              (== l-in (cons lcar lcdr))
              (func lcar lout-car)
              (lapplyo func lcdr lout-cdr)
              (== l-out (cons lout-car lout-cdr)))]
      [(== l-in [])
       (== l-out l-in)])))
#+END_SRC

#+NAME: hy_py_lapplyo_tests
#+BEGIN_SRC hy :eval never-export :exports none :results none
(defn test-lapplyo []
  ;; Two LVars should generate increasing lists of elements satisfying the
  ;; `func`/relational predicate.
  (assert (= [[[] []]
              [[`(ast.Name :id "_.0" :ctx "_.1")] [`(HySymbol "_.0")]]]
            (run 2 [res l] (lapplyo hy-py-symbolo l res))))

  ;; Check only one side of the `func`/relational predicate.
  (assert (= [] (get (run 1 [res] (lapplyo hy-py-symbolo [] res)) 0 0)))
  (assert (= [`(ast.Name :id "a" :ctx "_.0")]
             (get (run 1 [res] (lapplyo hy-py-symbolo ['a] res)) 0 0)))
  (assert (= [`(ast.Name :id "a" :ctx "_.0") `(ast.Name :id "b" :ctx "_.1")]
             (get (run 1 [res] (lapplyo hy-py-symbolo ['a 'b] res)) 0 0)))

  ;; Now, the other side.
  (assert (= [] (get (run 1 [res] (lapplyo hy-py-symbolo res [])) 0 0)))
  (assert (= [`(HySymbol "a")]
             (get (run 1 [res] (lapplyo hy-py-symbolo
                                        res
                                        [`(ast.Name :id "a" :ctx (ast.Load))])) 0 0)))
  (assert (= [`(HySymbol "a") `(HySymbol "b")]
             (get (run 1 [res] (lapplyo hy-py-symbolo
                                        res
                                        [`(ast.Name :id "a" :ctx (ast.Load))
                                         `(ast.Name :id "b" :ctx (ast.Load))])) 0 0))))
(test-lapplyo)
#+END_SRC

Finally, we create a goal for the AST of call expressions
like src_python{func(x, y, z)} and src_hy{(func x y z)}.
#+NAME: hy_py_callo
#+BEGIN_SRC hy :eval never-export :exports code :results silent
(defn hy-py-callo [hy-ast py-ast]
  "A goal relating call expressions in Python and Hy AST."
  (fresh [hy-op hy-args py-op py-args]
         ;; Hy AST form
         (== (cons hy-op hy-args) hy-ast)
         ;; Py AST form
         (== py-ast `(ast.Expr :value
                               (ast.Call :func
                                         ~py-op
                                         :args
                                         ~py-args
                                         :keywords
                                         [])))
         ;; These two must be related symbols
         (hy-py-symbolo hy-op py-op)
         ;; The arguments are related lists containing more of each AST type.
         (lapplyo hy-py-asto hy-args py-args)))

(defn hy-py-asto [hy-ast py-ast]
  "A goal for a 'branching' relation between multiple types of forms and their
 corresponding Python AST."
  (conde
    [(hy-py-symbolo hy-ast py-ast)]
    [(hy-py-callo hy-ast py-ast)]))
#+END_SRC

#+NAME: hy_py_callo_tests
#+BEGIN_SRC hy :eval never-export :exports none :results silent
;; (project [hy-ast py-ast hy-args py-args]
;;         (do
;;           (print (.format "\n----hy-args: {0!r} ----" hy-args))
;;           (print (.format "\n----py-args: {0!r} ----" py-args))
;;           (print (.format "\n----hy-ast: {0!r} ----" hy-ast))
;;           (print (.format "\n----py-ast: {0!r} ----" py-ast))
;;           s#))

(defn test-hy-py-asto []
  (setv test-py-app-1
        (py-ast-to-expr
          (first (. (ast.parse "blah(x, y, z)") body))))
  (setv test-hy-app-1
        `((HySymbol "blah") (HySymbol "x") (HySymbol "y") (HySymbol "z")))

  (assert (= [[test-hy-app-1]]
             (run 1 [res] (hy-py-callo res test-py-app-1))))
  (assert (= [[test-py-app-1]]
             (run 1 [res] (hy-py-callo test-hy-app-1 res)))))

(test-hy-py-asto)
#+END_SRC

:example:
To demonstrate our [extremely] minimal relational compiler, we create a Hy
function call expression and its corresponding Python AST.
#+NAME: hy_expro_test_setup
#+BEGIN_SRC hy :eval never-export :results value :exports both :wrap "SRC python :eval never"
(setv hy-ast-exa `(print x y z))
(setv py-ast-exa (. (hy-compile hy-ast-exa "__console__") body [0]))
(.format "hy_ast_exa = {}\npy_ast_exa = {}"
         hy-ast-exa
         (astor.dump py-ast-exa))
#+END_SRC

#+RESULTS: hy_expro_test_setup
#+begin_SRC python :eval never
hy_ast_exa = HyExpression([
  HySymbol('print'),
  HySymbol('x'),
  HySymbol('y'),
  HySymbol('z')])
py_ast_exa = Expr(value=Call(func=Name(id='print'), args=[Name(id='x'), Name(id='y'), Name(id='z')], keywords=[]))
#+end_SRC

We first run the Hy-to-Python direction by providing src_hy{hy-expro}
the src_hy{hy-ast-exa} value above and a logic variable (i.e. an "unknown") for
the Python AST term.
#+NAME: hy_py_asto_from_hy_exa
#+BEGIN_SRC hy :eval never-export :exports both :results value :wrap "SRC python :eval never"
(setv rel-res (run 1 [py-ast] (hy-py-asto hy-ast-exa py-ast)))
(setv ast-res (get rel-res 0 0))
ast-res
#+END_SRC

#+RESULTS: hy_py_asto_from_hy_exa
#+begin_SRC python :eval never
HyExpression([
  HySymbol('ast.Expr'),
  HyKeyword('value'),
  HyExpression([
    HySymbol('ast.Call'),
    HyKeyword('func'),
    HyExpression([
      HySymbol('ast.Name'),
      HyKeyword('id'),
      'print',
      HyKeyword('ctx'),
      HyExpression([
        HySymbol('ast.Load')])]),
    HyKeyword('args'),
    HyExpression([
      HyExpression([
        HySymbol('ast.Name'),
        HyKeyword('id'),
        'x',
        HyKeyword('ctx'),
        HyExpression([
          HySymbol('ast.Load')])]),
      HyExpression([
        HySymbol('ast.Name'),
        HyKeyword('id'),
        'y',
        HyKeyword('ctx'),
        HyExpression([
          HySymbol('ast.Load')])]),
      HyExpression([
        HySymbol('ast.Name'),
        HyKeyword('id'),
        'z',
        HyKeyword('ctx'),
        HyExpression([
          HySymbol('ast.Load')])])]),
    HyKeyword('keywords'),
    HyList()])])
#+end_SRC

And, now, the other direction (i.e. known Python AST, unknown Hy AST).
#+NAME: hy_py_asto_from_py_exa
#+BEGIN_SRC hy :eval never-export :exports both :results value :wrap "SRC python :eval never"
(setv rel-res (run 1 [hy-ast] (hy-py-asto hy-ast py-ast-exa)))
(setv ast-res (get rel-res 0 0))
ast-res
#+END_SRC

#+RESULTS: hy_py_asto_from_py_exa
#+begin_SRC python :eval never
[HyExpression([
  HySymbol('HySymbol'),
  'print']), HyExpression([
  HySymbol('HySymbol'),
  'x']), HyExpression([
  HySymbol('HySymbol'),
  'y']), HyExpression([
  HySymbol('HySymbol'),
  'z'])]
#+end_SRC

:END:

# #+BEGIN_SRC hy :eval never-export :exports both :wrap "SRC python :eval never"
# ;; `if` statement
# (setv hy-exa `(if (> 5 (+ 1 x)) (print x) False))
# (run* [out] (fresh [c s f]
#                  (== `(if ~c ~s ~f) hy-exa)
#                  (== out `(asty.If :test ~c))))
# #+END_SRC

# [[citet:someref]].
#
# #+BIBLIOGRAPHY: ../tex/post.bib
# #+BIBLIOGRAPHYSTYLE: plainnat
