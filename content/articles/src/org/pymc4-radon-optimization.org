#+TITLE: Symbolic PyMC Radon Example in PyMC4
#+AUTHOR: Brandon T. Willard
#+DATE: 2019-09-08
#+EMAIL: brandonwillard@gmail.com
#+FILETAGS: :pymc4:tensorflow:symbolic computation:python:symbolic-pymc:

#+STARTUP: hideblocks indent hidestars
#+OPTIONS: author:t date:t ^:nil toc:nil title:t tex:t d:(not "todo" "logbook" "note" "testing" "notes") html-preamble:t
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../extra/custom.css" />
#+STYLE: <link rel="stylesheet" type="text/css" href="../extra/custom.css" />

#+BEGIN_SRC elisp :eval t :exports none :results none
(org-babel-load-file "org-setup.org")
(org-babel-lob-ingest "org-babel-extensions.org")
;; (setq-local org-babel-jupyter-resourse-directory (btw--org-publish-property :figure-dir))
;; (setq-local org-preview-latex-image-directory (btw--org-publish-property :figure-dir))
#+END_SRC

#+PROPERTY: header-args :session radon-pymc4 :exports both :eval never-export :results output drawer replace
#+PROPERTY: header-args:text :eval never

* Introduction

[[https://github.com/pymc-devs/symbolic-pymc][Symbolic PyMC]] is a library that provides tools for symbolic manipulation of
Tensor library models in TensorFlow and Theano.  Over time, we plan to add
tools that are somewhat specialized toward Bayesian model manipulation and
the mathematical identities relevant to model manipulation for MCMC.

The main approach taken by Symbolic PyMC is relational/logic programming powered
by a [[http://minikanren.org/][miniKanren]] implementation in pure Python based on [[https://github.com/pymc-devs/kanren][src_python[:eval never]{kanren}]].

As an example of Symbolic PyMC's usage, we will create a model "optimizer" that
approximates the re-centering and re-scaling commonly demonstrated with the
radon dataset.  This example already exists for Theano in PyMC3 and can be found
in the [[https://github.com/pymc-devs/symbolic-pymc#automatic-re-centering-and-re-scaling][project README]].  Here, we will operate on TensorFlow graphs via PyMC4 and
approximate the same optimization using a very different approach targeted toward
the log-likelihood graph.

To get started, we download the radon dataset and define the un-centered model in Listings
[[python-setup]], [[radon-data-download]], and [[pymc4-radon-model]].

#+NAME: python-setup
#+BEGIN_SRC python :results silent
import numpy as np
import pandas as pd
import tensorflow as tf

import pymc4 as pm
import arviz as az
#+END_SRC

#+NAME: radon-data-download
#+BEGIN_SRC python :results silent
data = pd.read_csv('https://github.com/pymc-devs/pymc3/raw/master/pymc3/examples/data/radon.csv')

county_names = data.county.unique()
county_idx = data['county_code'].values.astype(np.int32)
#+END_SRC

#+NAME: pymc4-radon-model
#+BEGIN_SRC python :results silent
@pm.model
def hierarchical_model(data, county_idx):
    # Hyperpriors
    mu_a = yield pm.Normal('mu_alpha', mu=0., sigma=1)
    sigma_a = yield pm.HalfCauchy('sigma_alpha', beta=1)
    mu_b = yield pm.Normal('mu_beta', mu=0., sigma=1)
    sigma_b = yield pm.HalfCauchy('sigma_beta', beta=1)

    # Intercept for each county, distributed around group mean mu_a
    a = yield pm.Normal('alpha', mu=mu_a, sigma=sigma_a, plate=len(data.county.unique()))
    # Intercept for each county, distributed around group mean mu_a
    b = yield pm.Normal('beta', mu=mu_b, sigma=sigma_b, plate=len(data.county.unique()))

    # Model error
    eps = yield pm.HalfCauchy('eps', beta=1)

    # Expected value
    #radon_est = a[county_idx] + b[county_idx] * data.floor.values
    radon_est = tf.gather(a, county_idx) + tf.gather(
        b, county_idx) * data.floor.values

    # Data likelihood
    y_like = yield pm.Normal('y_like', mu=radon_est, sigma=eps, observed=data.log_radon)


init_num_chains = 50
model = hierarchical_model(data, county_idx)
#+END_SRC

In Listing [[pymc4-radon-model-sample]], we estimates the model using the sample
routine from the [[https://github.com/pymc-devs/pymc4/blob/master/notebooks/radon_hierarchical.ipynb][PyMC4 Radon example Notebook]] in Listing [[pymc4-sample-function]].
The same plots are reproduce here in Figures [[fig:pymc4-radon-plot-energy]] and
[[fig:pymc4-radon-plot-trace]].

#+NAME: pymc4-sample-function
#+BEGIN_SRC python :results silent
def sample(model, init_num_chains=50, num_samples=500, burn_in=500):
    init_num_chains = 50
    pm4_trace, _ = pm.inference.sampling.sample(
        model, num_chains=init_num_chains, num_samples=10, burn_in=10, step_size=1., xla=True)
    for i in range(3):
        step_size_ = []
        for _, x in pm4_trace.items():
            std = tf.math.reduce_std(x, axis=[0, 1])
            step_size_.append(
                std[tf.newaxis, ...] * tf.ones([init_num_chains] + std.shape, dtype=std.dtype))
        pm4_trace, _ = pm.inference.sampling.sample(
            model, num_chains=init_num_chains, num_samples=10 + 10*i, burn_in=10 + 10*i,
            step_size=step_size_, xla=True)

    num_chains = 5
    step_size_ = []
    for _, x in pm4_trace.items():
        std = tf.math.reduce_std(x, axis=[0, 1])
        step_size_.append(
            std[tf.newaxis, ...] * tf.ones([num_chains]+std.shape, dtype=std.dtype))

    pm4_trace, sample_stat = pm.inference.sampling.sample(
        model, num_chains=num_chains, num_samples=num_samples, burn_in=burn_in,
        step_size=step_size_, xla=True)

    az_trace = pm.inference.utils.trace_to_arviz(pm4_trace, sample_stat)

    return az_trace
#+END_SRC

#+NAME: pymc4-radon-model-sample-pickle
#+BEGIN_SRC python :eval never-export :exports none :noweb yes :results silent
import os
import pickle


if os.path.exists('az_trace.pkl'):
    with open('az_trace.pkl', 'rb') as f:
        az_trace = pickle.load(f)
else:
    <<pymc4-radon-model-sample>>

    with open('az_trace.pkl', 'wb') as f:
        pickle.dump(az_trace, f)
#+END_SRC

#+NAME: pymc4-radon-model-sample
#+BEGIN_SRC python :eval never :exports code :results none
az_trace = sample(model)
#+END_SRC

#+NAME: pymc4-radon-plot-setup
#+BEGIN_SRC python :eval never-export :exports code :results silent
import arviz as az
import matplotlib.pyplot as plt

import seaborn as sns

from matplotlib import rcParams


rcParams['figure.figsize'] = (11.7, 8.27)

# plt.rc('text', usetex=True)
sns.set_style("whitegrid")
sns.set_context("paper")
#+END_SRC

#+NAME: pymc4-radon-plot-energy
#+BEGIN_SRC python :eval never :exports code :results silent
_ = az.plot_energy(az_trace)
#+END_SRC

#+NAME: generate-python-plots
#+HEADER: :var code-block-name=""
#+BEGIN_SRC elisp :eval never-export :exports none :results silent
(let* ((src-block-info (save-mark-and-excursion
                         (org-babel-goto-named-src-block code-block-name)
                         (org-babel-get-src-block-info)))
       (root-dir (btw--org-publish-property :base-directory))
       (output-dir (btw--org-publish-property :figure-dir))
       (code-block-src (cadr src-block-info))
       (plot-src
        (format "
import os

output_dir = '%s'
fig_filenames = [os.path.join(output_dir, '%s')
                 + os.path.extsep + out_ext
                 for out_ext in ['pdf', 'png']]

plt.switch_backend('Agg')

%s

for fname in fig_filenames:
   plt.savefig(fname)

_ = os.path.relpath(fig_filenames[-1], '%s')
" output-dir code-block-name code-block-src root-dir))
       (session-name
        (alist-get :session (nth 2 src-block-info)))
       (out-file-name
        (funcall (intern (concat "org-babel-execute:" (car src-block-info)))
                 plot-src
                 `((:result-params silent output drawer)
                   (:result-type . value)
                   (:results value raw)
                   (:session . ,session-name))))
       (code-block-point
        (save-mark-and-excursion
          (org-babel-goto-named-src-block code-block-name)
          (point)))
       (old-src-block-loc org-babel-current-src-block-location)
       (org-babel-current-src-block-location code-block-point))
  (let* ((wrap-src-info (org-babel-lob--src-info "org_fig_wrap")))
    (org-babel-execute-src-block nil
                                 wrap-src-info
                                 `((:var data . ,out-file-name))))
  plot-src)
#+END_SRC

#+CALL: generate-python-plots[:results silent :eval never](code-block-name="pymc4-radon-plot-energy")

#+RESULTS:
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 1.0\textwidth :height 1.0\textwidth :float t :options [keepaspectratio] :placement [p!]
#+CAPTION:
#+NAME: fig:pymc4-radon-plot-energy
[[file:../../figures/pymc4-radon-plot-energy.png]]



#+NAME: pymc4-radon-plot-trace
#+HEADER: :var output_dir=(btw--org-publish-property :figure-dir)
#+HEADER: :post org_fig_wrap(data=*this*, options="[keepaspectratio]", placement="[p!]", caption="")
#+BEGIN_SRC python :eval never :exports results :results value raw
_ = az.plot_trace(az_trace, compact=True)
#+END_SRC

#+CALL: generate-python-plots[:results silent :eval never](code-block-name="pymc4-radon-plot-trace")

#+RESULTS:
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 1.0\textwidth :height 1.0\textwidth :float t :options [keepaspectratio] :placement [p!]
#+CAPTION:
#+NAME: fig:pymc4-radon-plot-trace
[[file:../../figures/pymc4-radon-plot-trace.png]]


* Applying an Optimization

In order to apply our optimization, we need to do some work to obtain a graph of
the log-likelihood function generated by the model in Listing [[pymc4-radon-model]].
With the graph in-hand, we can perform the re-centering and re-scaling
transform--in log-space this time--and obtain a new log-likelihood graph from
which better samples can be generated.

This exercise introduces the TensorFlow function-graph elements that mirror
Theano's src_python[:eval never]{tt.function} and src_python[:eval never]{FunctionGraph}s:
src_python[:eval never]{tensorflow.python.framework.func_graph.FuncGraph}.
src_python[:eval never]{FuncGraph} is a subclass of the regular
src_python[:eval never]{Graph} objects upon which
implicitly src_python[:eval never]{symbolic_pymc} operates.  Just as with
Theano's src_python[:eval never]{FunctionGraph}s, src_python[:eval never]{FuncGraph} simply
specializes a graph by specifying inputs and outputs from elements (i.e. tensors) within
a graph.

* Log-likelihood src_python[:eval never]{FuncGraph}s

In Listing [[logp-func]], we build the log-likelihood function for our model and a
corresponding list of initial values for the parameters.
#+NAME: logp-func
#+BEGIN_SRC python :results silent
state = None
observed = None

logpfn, init = pm.inference.sampling.build_logp_function(model,
                                                         state=state,
                                                         observed=observed)
#+END_SRC

From here we need src_python[:eval never]{FuncGraph}s for each input
to src_python[:eval never]{logpfn}.  Since src_python[:eval never]{logpfn} is
a src_python[:eval never]{tensorflow.python.eager.def_function.Function}
instance, every time it's called with a specific tensor it may create a new
function-object with it's own src_python[:eval never]{FuncGraph}.  In other
words, it dynamically generates function objects based on the inputs it's given.

This specialization process can be performed manually
using src_python[:eval never]{logpfn.get_concrete_function(*args)}, which
necessarily produces
a src_python[:eval never]{tensorflow.python.eager.function.ConcreteFunction}
with the desired src_python[:eval never]{FuncGraph}.  Listing
[[fgraph-specializations]] creates and extracts these two objects.

#+NAME: fgraph-specializations
#+BEGIN_SRC python :results silent
logpfn_cf = logpfn.get_concrete_function(*init.values())
logpfn_fg = logpfn_cf.graph
#+END_SRC

The outputs are now available in graph form as src_python[:eval never]{logpfn_fg.outputs}.
The inputs aren't mapped in this particular function-graph output.  I believe there's a way to
generate those as TF placeholders.

#+NAME: print-graph-dependencies
#+BEGIN_SRC python :exports none :eval never
from tensorflow.python.eager.context import graph_mode
from tensorflow.python.framework.ops import disable_tensor_equality

from symbolic_pymc.tensorflow.printing import tf_dprint


disable_tensor_equality()
#+END_SRC

* The Log-space Transform

Consider the following two equivalent hierarchical models,
\begin{equation}
  \begin{gathered}
    Y = X + \epsilon, \quad
    \epsilon \sim \operatorname{N}\left(0, 1\right)
    \\
    X \sim \operatorname{N}\left(\mu, \sigma^2\right)
  \end{gathered}
\label{eq:model-1}
\end{equation}
\begin{equation}
  \begin{gathered}
    Y = \mu + \sigma \cdot \tilde{X} + \epsilon, \quad
    \epsilon \sim \operatorname{N}\left(0, 1\right)
    \\
    \tilde{X} \sim \operatorname{N}\left(0, 1\right)
  \;.
  \end{gathered}
\label{eq:model-2}
\end{equation}
Models [[eqref:eq:model-1]] and [[eqref:eq:model-2]] are represented in (log) measure space,
respectively, as follows:
\begin{align}
    \log P(Y, X) &= \log P(Y\mid X) + \log P(X)
    \nonumber
    \\
    &= C - \frac{1}{2} \left(y - x\right)^2 - \frac{1}{2 \sigma^2} \left(x - \mu\right)^2
    \label{eq:log-model-1}
    \\
    &= \tilde{C} - \frac{1}{2} \left(y - \mu - \sigma \cdot \tilde{x}\right)^2 - \frac{1}{2} \tilde{x}^2
  \label{eq:log-model-2}
  \;.
\end{align}

Via term rewriting, Equation [[eqref:eq:log-model-2]] is produced by first
applying the replacement rule \(x \to \mu + \sigma \cdot \tilde{x}\) to Equation
[[eqref:eq:log-model-1]], which produces
\begin{align*}
C - \frac{1}{2} \left(y - (\mu + \sigma \cdot \tilde{x})\right)^2 - \frac{1}{2 \sigma^2} \left((\mu + \sigma \cdot \tilde{x}) - \mu\right)^2
\;.
\end{align*}

After a few applications of some simple algebraic properties--as further
replacement rules--one obtains the exact form of Equation [[eqref:eq:log-model-2]].
Here, we'll focus only on applying the initial replacement rule.

In our case, the log-density returned by PyMC4--via the TensorFlow Probability
library (TFP)-- uses src_python[:eval never]{tf.math.squared_difference} to
construct the "squared error" term in the exponential of a normal distribution.
Listing [[tfp-normal-log-lik-graph]] shows the graph produced by a normal
distribution in TFP.

#+NAME: tfp-normal-log-lik-graph
#+BEGIN_SRC python :exports both :results output :wrap "SRC text :eval never" :noweb yes
import tensorflow_probability as tfp

<<print-graph-dependencies>>

with graph_mode(), tf.Graph().as_default() as test_graph:
    mu_tf = tf.compat.v1.placeholder(tf.float32, name='mu',
                                     shape=tf.TensorShape([None]))
    tau_tf = tf.compat.v1.placeholder(tf.float32, name='tau',
                                      shape=tf.TensorShape([None]))

    normal_tfp = tfp.distributions.normal.Normal(mu_tf, tau_tf)

    value_tf = tf.compat.v1.placeholder(tf.float32, name='value',
                                        shape=tf.TensorShape([None]))

    normal_log_lik = normal_tfp.log_prob(value_tf)

    tf_dprint(normal_log_lik)
#+END_SRC

#+RESULTS: tfp-normal-log-lik-graph
#+begin_SRC text :eval never
Tensor(Sub):0,	shape=[None]	"Normal_1/log_prob/sub:0"
|  Op(Sub)	"Normal_1/log_prob/sub"
|  |  Tensor(Mul):0,	shape=[None]	"Normal_1/log_prob/mul:0"
|  |  |  Op(Mul)	"Normal_1/log_prob/mul"
|  |  |  |  Tensor(Const):0,	shape=[]	"Normal_1/log_prob/mul/x:0"
|  |  |  |  Tensor(SquaredDifference):0,	shape=[None]	"Normal_1/log_prob/SquaredDifference:0"
|  |  |  |  |  Op(SquaredDifference)	"Normal_1/log_prob/SquaredDifference"
|  |  |  |  |  |  Tensor(RealDiv):0,	shape=[None]	"Normal_1/log_prob/truediv:0"
|  |  |  |  |  |  |  Op(RealDiv)	"Normal_1/log_prob/truediv"
|  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"value:0"
|  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"tau:0"
|  |  |  |  |  |  Tensor(RealDiv):0,	shape=[None]	"Normal_1/log_prob/truediv_1:0"
|  |  |  |  |  |  |  Op(RealDiv)	"Normal_1/log_prob/truediv_1"
|  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"mu:0"
|  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"tau:0"
|  |  Tensor(AddV2):0,	shape=[None]	"Normal_1/log_prob/add:0"
|  |  |  Op(AddV2)	"Normal_1/log_prob/add"
|  |  |  |  Tensor(Const):0,	shape=[]	"Normal_1/log_prob/add/x:0"
|  |  |  |  Tensor(Log):0,	shape=[None]	"Normal_1/log_prob/Log:0"
|  |  |  |  |  Op(Log)	"Normal_1/log_prob/Log"
|  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"tau:0"


#+end_SRC

Instead of looking for the entire log-likelihood graph for a distribution, we
can focus on only the src_python[:eval never]{SquaredDifference} operators,
since they contain all the relevant terms for our transformation.

More specifically, if we can identify "chains" of such terms,
i.e.  src_python[:eval never]{SquaredDifference(y, x)}
and src_python[:eval never]{SquaredDifference(x, mu)}, then we might be able to
assume that the corresponding subgraph was formed from such a hierarchical
normal model.

Listing [[show-squared-diff-terms]] shows the src_python[:eval never]{SquaredDifference}
sub-graphs in the log-likelihood graph for our radon model.  It demonstrates two
instances of said src_python[:eval never]{SquaredDifference}
"chains": they involve tensors named ~values_5~ and ~values_1~.

#+NAME: show-squared-diff-terms
#+BEGIN_SRC python :exports both :results output :wrap "SRC text :eval never"
square_diff_outs = [o for o in logpfn_fg.get_operations()
                    if o.type == 'SquaredDifference']

for t in square_diff_outs:
    tf_dprint(t)
#+END_SRC

#+RESULTS: show-squared-diff-terms
#+begin_SRC text :eval never
Op(SquaredDifference)	"Normal_5/log_prob/SquaredDifference"
|  Tensor(RealDiv):0,	shape=[]	"Normal_5/log_prob/truediv:0"
|  |  Op(RealDiv)	"Normal_5/log_prob/truediv"
|  |  |  Tensor(Placeholder):0,	shape=[]	"values_5:0"
|  |  |  Tensor(Const):0,	shape=[]	"Normal/scale:0"
|  Tensor(RealDiv):0,	shape=[]	"Normal_5/log_prob/truediv_1:0"
|  |  Op(RealDiv)	"Normal_5/log_prob/truediv_1"
|  |  |  Tensor(Const):0,	shape=[]	"Normal/loc:0"
|  |  |  Tensor(Const):0,	shape=[]	"Normal/scale:0"
Op(SquaredDifference)	"Normal_1_1/log_prob/SquaredDifference"
|  Tensor(RealDiv):0,	shape=[]	"Normal_1_1/log_prob/truediv:0"
|  |  Op(RealDiv)	"Normal_1_1/log_prob/truediv"
|  |  |  Tensor(Placeholder):0,	shape=[]	"values_1:0"
|  |  |  Tensor(Const):0,	shape=[]	"Normal_1/scale:0"
|  Tensor(RealDiv):0,	shape=[]	"Normal_1_1/log_prob/truediv_1:0"
|  |  Op(RealDiv)	"Normal_1_1/log_prob/truediv_1"
|  |  |  Tensor(Const):0,	shape=[]	"Normal_1/loc:0"
|  |  |  Tensor(Const):0,	shape=[]	"Normal_1/scale:0"
Op(SquaredDifference)	"SampleNormal_2_1/log_prob/Normal_2/log_prob/SquaredDifference"
|  Tensor(RealDiv):0,	shape=[85]	"SampleNormal_2_1/log_prob/Normal_2/log_prob/truediv:0"
|  |  Op(RealDiv)	"SampleNormal_2_1/log_prob/Normal_2/log_prob/truediv"
|  |  |  Tensor(Transpose):0,	shape=[85]	"SampleNormal_2_1/log_prob/transpose:0"
|  |  |  |  Op(Transpose)	"SampleNormal_2_1/log_prob/transpose"
|  |  |  |  |  Tensor(Reshape):0,	shape=[85]	"SampleNormal_2_1/log_prob/Reshape:0"
|  |  |  |  |  |  Op(Reshape)	"SampleNormal_2_1/log_prob/Reshape"
|  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[85]	"values_6:0"
|  |  |  |  |  |  |  Tensor(Const):0,	shape=[1]	"SampleNormal_2_1/log_prob/Reshape/shape:0"
|  |  |  |  |  Tensor(Const):0,	shape=[1]	"SampleNormal_2_1/log_prob/transpose/perm:0"
|  |  |  Tensor(Exp):0,	shape=[]	"exp_1/forward/Exp:0"
|  |  |  |  Op(Exp)	"exp_1/forward/Exp"
|  |  |  |  |  Tensor(Placeholder):0,	shape=[]	"values_4:0"
|  Tensor(RealDiv):0,	shape=[]	"SampleNormal_2_1/log_prob/Normal_2/log_prob/truediv_1:0"
|  |  Op(RealDiv)	"SampleNormal_2_1/log_prob/Normal_2/log_prob/truediv_1"
|  |  |  Tensor(Placeholder):0,	shape=[]	"values_5:0"
|  |  |  Tensor(Exp):0,	shape=[]	"exp_1/forward/Exp:0"
|  |  |  |  ...
Op(SquaredDifference)	"SampleNormal_3_1/log_prob/Normal_3/log_prob/SquaredDifference"
|  Tensor(RealDiv):0,	shape=[85]	"SampleNormal_3_1/log_prob/Normal_3/log_prob/truediv:0"
|  |  Op(RealDiv)	"SampleNormal_3_1/log_prob/Normal_3/log_prob/truediv"
|  |  |  Tensor(Transpose):0,	shape=[85]	"SampleNormal_3_1/log_prob/transpose:0"
|  |  |  |  Op(Transpose)	"SampleNormal_3_1/log_prob/transpose"
|  |  |  |  |  Tensor(Reshape):0,	shape=[85]	"SampleNormal_3_1/log_prob/Reshape:0"
|  |  |  |  |  |  Op(Reshape)	"SampleNormal_3_1/log_prob/Reshape"
|  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[85]	"values_3:0"
|  |  |  |  |  |  |  Tensor(Const):0,	shape=[1]	"SampleNormal_3_1/log_prob/Reshape/shape:0"
|  |  |  |  |  Tensor(Const):0,	shape=[1]	"SampleNormal_3_1/log_prob/transpose/perm:0"
|  |  |  Tensor(Exp):0,	shape=[]	"exp_2_1/forward/Exp:0"
|  |  |  |  Op(Exp)	"exp_2_1/forward/Exp"
|  |  |  |  |  Tensor(Placeholder):0,	shape=[]	"values_0:0"
|  Tensor(RealDiv):0,	shape=[]	"SampleNormal_3_1/log_prob/Normal_3/log_prob/truediv_1:0"
|  |  Op(RealDiv)	"SampleNormal_3_1/log_prob/Normal_3/log_prob/truediv_1"
|  |  |  Tensor(Placeholder):0,	shape=[]	"values_1:0"
|  |  |  Tensor(Exp):0,	shape=[]	"exp_2_1/forward/Exp:0"
|  |  |  |  ...
Op(SquaredDifference)	"Normal_4_1/log_prob/SquaredDifference"
|  Tensor(RealDiv):0,	shape=[919]	"Normal_4_1/log_prob/truediv:0"
|  |  Op(RealDiv)	"Normal_4_1/log_prob/truediv"
|  |  |  Tensor(Const):0,	shape=[919]	"Normal_4_1/log_prob/value:0"
|  |  |  Tensor(Exp):0,	shape=[]	"exp_3_1/forward/Exp:0"
|  |  |  |  Op(Exp)	"exp_3_1/forward/Exp"
|  |  |  |  |  Tensor(Placeholder):0,	shape=[]	"values_2:0"
|  Tensor(RealDiv):0,	shape=[919]	"Normal_4_1/log_prob/truediv_1:0"
|  |  Op(RealDiv)	"Normal_4_1/log_prob/truediv_1"
|  |  |  Tensor(AddV2):0,	shape=[919]	"add:0"
|  |  |  |  Op(AddV2)	"add"
|  |  |  |  |  Tensor(GatherV2):0,	shape=[919]	"GatherV2:0"
|  |  |  |  |  |  Op(GatherV2)	"GatherV2"
|  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[85]	"values_6:0"
|  |  |  |  |  |  |  Tensor(Const):0,	shape=[919]	"GatherV2/indices:0"
|  |  |  |  |  |  |  Tensor(Const):0,	shape=[]	"GatherV2/axis:0"
|  |  |  |  |  Tensor(Mul):0,	shape=[919]	"mul:0"
|  |  |  |  |  |  Op(Mul)	"mul"
|  |  |  |  |  |  |  Tensor(GatherV2):0,	shape=[919]	"GatherV2_1:0"
|  |  |  |  |  |  |  |  Op(GatherV2)	"GatherV2_1"
|  |  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[85]	"values_3:0"
|  |  |  |  |  |  |  |  |  Tensor(Const):0,	shape=[919]	"GatherV2_1/indices:0"
|  |  |  |  |  |  |  |  |  Tensor(Const):0,	shape=[]	"GatherV2_1/axis:0"
|  |  |  |  |  |  |  Tensor(Const):0,	shape=[919]	"mul/y:0"
|  |  |  Tensor(Exp):0,	shape=[]	"exp_3_1/forward/Exp:0"
|  |  |  |  ...


#+end_SRC


** Graph Normalization

The src_python[:eval never]{grappler} library in TensorFlow provides a subset of
graph pruning/optimization steps.  Ideally, a library like src_python[:eval never]{grappler}
would provide full-fledged graph normalization/canonicalization upon which we could
base the subgraphs used in our relations.

:REMARK:
While src_python[:eval never]{grappler} does appear to provide some minimal
algebraic normalizations, the extent to which these are performed and their
breadth of relevant operator coverage isn't clear; however, the normalizations
that it does provide are worth using, so we'll make use of them throughout.
:END:

In general, we don't want our "patterns" to be "brittle", e.g. rely on
explicit--yet variable--term orderings in commutative operators (e.g. a pattern
that exclusively targets src_python[:eval never]{mt.add(x_lv, y_lv)} and won't
match the equivalent src_python[:eval never]{mt.add(y_lv, x_lv)}).

Listing [[grappler-normalize-function]] provides a simple means of
applying src_python[:eval never]{grappler}.

#+NAME: grappler-normalize-function
#+BEGIN_SRC python :exports code :results silent
from tensorflow.core.protobuf import config_pb2

from tensorflow.python.framework import ops
from tensorflow.python.framework import importer
from tensorflow.python.framework import meta_graph

from tensorflow.python.grappler import cluster
from tensorflow.python.grappler import tf_optimizer


try:
    gcluster = cluster.Cluster()
except tf.errors.UnavailableError:
    pass

config = config_pb2.ConfigProto()


def normalize_tf_graph(graph_output, graph_inputs=[]):
    """Use grappler to normalize a graph.

    Arguments
    =========
    graph_output: Tensor
      A tensor we want to consider as "output" of a FuncGraph.
    graph_inputs: list of Tensor (optional)
      Any tensors that correspond to inputs for the given output node.

    Returns
    =======
    The simplified graph.
    """
    train_op = graph_output.graph.get_collection_ref(ops.GraphKeys.TRAIN_OP)
    train_op.clear()
    train_op.extend([graph_output] + graph_inputs)

    # if graph_inputs is not None:
    #     # ops.GraphKeys.MODEL_VARIABLES?
    #     train_vars = graph_output.graph.get_collection_ref(ops.GraphKeys.TRAINABLE_VARIABLES),
    #     train_vars.clear()
    #     train_vars.extend(graph_inputs)

    metagraph = meta_graph.create_meta_graph_def(graph=graph_output.graph)

    optimized_graphdef = tf_optimizer.OptimizeGraph(
        config, metagraph, verbose=True, cluster=gcluster)

    optimized_graph = ops.Graph()
    with optimized_graph.as_default():
        importer.import_graph_def(optimized_graphdef, name="")

    opt_graph_output = optimized_graph.get_tensor_by_name(graph_output.name)

    return opt_graph_output
#+END_SRC

In Listing [[grappler-normalize-function]] we
run src_python[:eval never]{grappler} on the log-likelihood graph for a normal
random variable from Listing [[tfp-normal-log-lik-graph]].

#+NAME: grappler-normalize-test-graph
#+BEGIN_SRC python :exports code :results silent :wrap
normal_log_lik_opt = normalize_tf_graph(normal_log_lik)
#+END_SRC

Listing [[opt-graph-output-cmp]] compares the computed outputs for the original and
normalized graphs--given identical inputs.
#+NAME: opt-graph-output-cmp
#+BEGIN_SRC python :exports both :results value :wrap "SRC python :eval never" :eval never-export
res_unopt = normal_log_lik.eval({'mu:0': np.r_[3], 'tau:0': np.r_[1], 'value:0': np.r_[1]},
                                 session=tf.compat.v1.Session(graph=normal_log_lik.graph))

res_opt = normal_log_lik_opt.eval({'mu:0': np.r_[3], 'tau:0': np.r_[1], 'value:0': np.r_[1]},
                                  session=tf.compat.v1.Session(graph=normal_log_lik_opt.graph))

# They should be equal, naturally
assert np.array_equal(res_unopt, res_opt)

_ = [res_unopt, res_opt]
#+END_SRC

#+RESULTS: opt-graph-output-cmp
#+begin_SRC python :eval never
[array([-2.9189386], dtype=float32), array([-2.9189386], dtype=float32)]
#+end_SRC

#+NAME: opt-graph-print
#+BEGIN_SRC python :exports both :results output :wrap "SRC text :eval never" :eval never-export
tf_dprint(normal_log_lik_opt)
#+END_SRC

#+RESULTS: opt-graph-print
#+begin_SRC text :eval never
Tensor(Sub):0,	shape=[None]	"Normal_1/log_prob/sub:0"
|  Op(Sub)	"Normal_1/log_prob/sub"
|  |  Tensor(Mul):0,	shape=[None]	"Normal_1/log_prob/mul:0"
|  |  |  Op(Mul)	"Normal_1/log_prob/mul"
|  |  |  |  Tensor(SquaredDifference):0,	shape=[None]	"Normal_1/log_prob/SquaredDifference:0"
|  |  |  |  |  Op(SquaredDifference)	"Normal_1/log_prob/SquaredDifference"
|  |  |  |  |  |  Tensor(RealDiv):0,	shape=[None]	"Normal_1/log_prob/truediv:0"
|  |  |  |  |  |  |  Op(RealDiv)	"Normal_1/log_prob/truediv"
|  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"value:0"
|  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"tau:0"
|  |  |  |  |  |  Tensor(RealDiv):0,	shape=[None]	"Normal_1/log_prob/truediv_1:0"
|  |  |  |  |  |  |  Op(RealDiv)	"Normal_1/log_prob/truediv_1"
|  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"mu:0"
|  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"tau:0"
|  |  |  |  Tensor(Const):0,	shape=[]	"Normal_1/log_prob/mul/x:0"
|  |  Tensor(AddV2):0,	shape=[None]	"Normal_1/log_prob/add:0"
|  |  |  Op(AddV2)	"Normal_1/log_prob/add"
|  |  |  |  Tensor(Log):0,	shape=[None]	"Normal_1/log_prob/Log:0"
|  |  |  |  |  Op(Log)	"Normal_1/log_prob/Log"
|  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"tau:0"
|  |  |  |  Tensor(Const):0,	shape=[]	"Normal_1/log_prob/add/x:0"


#+end_SRC

From the output of Listing [[opt-graph-print]], we can see
that src_python[:eval never]{grappler} has performed some constant folding and
has reordered the inputs in src_python[:eval never]{"add_1_1"}--among other
things.

** miniKanren Transform Relations

In Listing [[kanren-shift-squaredo-func]], we create miniKanren functions that
identify the aforementioned src_python[:eval never]{SquaredDifference} "chains"
and perform the re-centered/scaled \(X\) substitution.

#+NAME: kanren-shift-squaredo-func
#+BEGIN_SRC python :results silent
from itertools import chain
from functools import partial

from unification import var, reify, unify

from kanren import run, eq, lall, conde
from kanren.goals import not_equalo
from kanren.core import goaleval

from symbolic_pymc.tensorflow.meta import mt
from symbolic_pymc.relations.graph import graph_applyo, reduceo
from symbolic_pymc.etuple import ExpressionTuple, etuple


def onceo(goal):
    """A non-relational operator that yields only the first result from a relation."""
    def onceo_goal(s):
        nonlocal goal
        g = reify(goal, s)
        g_stream = goaleval(g)(s)
        s = next(g_stream)
        yield s

    return onceo_goal


def tf_graph_applyo(relation, a, b):
    """Construct a `graph_applyo` goal that evaluates a relation only at tensor nodes in a meta graph.

    Parameters
    ----------
    relation: function
      A binary relation/goal constructor function
    a: lvar, meta graph, or etuple
      The left-hand side of the relation.
    b: lvar, meta graph, or etuple
      The right-hand side of the relation
    """

    def _expand_some_nodes(node):
        if isinstance(node, mt.Tensor) and node.op is not None:
            return etuple(node.operator, *node.inputs, eval_obj=node)
        return None

    gapplyo = partial(graph_applyo, relation, preprocess_graph=_expand_some_nodes)
    return gapplyo(a, b)


def shift_squared_terms(in_obj, graph_inputs=[]):
    """Re-center/scale SquaredDifference terms corresponding to hierarchical normals."""

    def shift_squared_subso(in_graph, out_subs):
        """Construct a goal that identifies the SquaredDifference terms we desire."""

        Y_lv, X_lv, mu_lv = var(), var(), var()
        X_denom_lv = var()
        X_form_lv = mt.Placeholder(dtype=var(), shape=var(), name=var())

        sqr_diff_Y_lv = mt.SquaredDifference(Y_lv,
                                             mt.realdiv(X_lv, var(), name=var()),
                                             name=var())

        def Y_sqrdiffo(in_g, out_g):
            return lall(eq(in_g, sqr_diff_Y_lv),
                        # This just makes sure that we're only considering X's
                        # that are Placeholders.
                        eq(X_lv, X_form_lv))

        sqr_diff_X_lv = mt.SquaredDifference(mt.mul(X_denom_lv, X_lv, name=var()),
                                             # mt.realdiv(X_lv, X_denom_lv, name=var()),
                                             mu_lv,
                                             name=var())

        def X_sqrdiffo(in_g, out_g):
            return eq(in_g, sqr_diff_X_lv)

        # X_new_mt = mt.mul(X_denom_lv, mt.add(mu_lv, X_lv))
        X_new_mt = mt.add(mu_lv, mt.mul(X_denom_lv, X_lv))

        res = lall(
            # The first (y - x/a)**2 (anywhere in the graph)
            tf_graph_applyo(Y_sqrdiffo, in_graph, in_graph),
            # The corresponding (x/b - z)**2 (also anywhere else in the graph)
            tf_graph_applyo(X_sqrdiffo, in_graph, in_graph),
            # Not sure if we need this, but we definitely don't want X == Y
            (not_equalo, [Y_lv, X_lv], True),
            # Set the "output"/second argument to the resulting substitution
            # pair
            eq(out_subs, [X_lv, X_new_mt]))

        return res

    # Normalize and convert to a meta graph
    in_obj = mt(normalize_tf_graph(in_obj, graph_inputs=graph_inputs))

    # This run returns all the substitutions found in the graph
    subs_lv = var()
    subs_res = run(0, subs_lv, shift_squared_subso(in_obj, subs_lv))

    def subs_replaceo(in_g, out_g):
        """Create a goal that applies substitutions to a graph."""
        def _subs_replaceo(in_g, out_g):
            x_g = conde(*[[eq(in_g, x), eq(out_g, y)]
                          for x, y in subs_res])
            return x_g

        g = onceo(tf_graph_applyo(_subs_replaceo, in_g, out_g))
        return g

    # Apply each substitution once
    out_graph_lv = var()
    res = run(1, out_graph_lv, reduceo(subs_replaceo, in_obj, out_graph_lv))

    if res:

        def reify_res(graph_res):
            """Reconstruct and/or reify meta object results."""
            from_etuple = graph_res.eval_obj if isinstance(graph_res, ExpressionTuple) else graph_res
            if hasattr(from_etuple, 'reify'):
                return from_etuple.reify()
            else:
                return from_etuple

        res = [reify_res(r) for r in res]

    if len(res) == 1:
        graph_res = res[0]
        # return graph_res, subs_res
        return normalize_tf_graph(graph_res, graph_inputs=graph_inputs), subs_res
#+END_SRC

As a test, we will run our miniKanren relations on the log-likelihood graph for a
normal-normal hierarchical model in Listing [[non-trivial-transform-test-graph]].

#+NAME: non-trivial-transform-test-graph
#+BEGIN_SRC python :exports code :results silent
with graph_mode(), tf.Graph().as_default() as demo_graph:
    X_tfp = tfp.distributions.normal.Normal(0.0, 1.0, name='X')

    x_tf = tf.compat.v1.placeholder(tf.float32, name='value_x',
                                    shape=tf.TensorShape([None]))

    tau_tf = tf.compat.v1.placeholder(tf.float32, name='tau',
                                      shape=tf.TensorShape([None]))

    Y_tfp = tfp.distributions.normal.Normal(x_tf, tau_tf, name='Y')

    y_tf = tf.compat.v1.placeholder(tf.float32, name='value_y',
                                    shape=tf.TensorShape([None]))

    hier_norm_lik = Y_tfp.log_prob(y_tf) + X_tfp.log_prob(x_tf)
    hier_norm_lik = normalize_tf_graph(hier_norm_lik)
#+END_SRC

Listing [[non-trivial-transform-test-graph-print]] shows the form that
a graph representing a hierarchical normal-normal model will generally take
in TFP.

#+NAME: non-trivial-transform-test-graph-print
#+BEGIN_SRC python :exports both :results output :wrap "SRC text :eval never"
tf_dprint(hier_norm_lik)
#+END_SRC

#+RESULTS: non-trivial-transform-test-graph-print
#+begin_SRC text :eval never
Tensor(AddV2):0,	shape=[None]	"add:0"
|  Op(AddV2)	"add"
|  |  Tensor(Sub):0,	shape=[None]	"X_1/log_prob/sub:0"
|  |  |  Op(Sub)	"X_1/log_prob/sub"
|  |  |  |  Tensor(Mul):0,	shape=[None]	"X_1/log_prob/mul:0"
|  |  |  |  |  Op(Mul)	"X_1/log_prob/mul"
|  |  |  |  |  |  Tensor(SquaredDifference):0,	shape=[None]	"X_1/log_prob/SquaredDifference:0"
|  |  |  |  |  |  |  Op(SquaredDifference)	"X_1/log_prob/SquaredDifference"
|  |  |  |  |  |  |  |  Tensor(Mul):0,	shape=[None]	"X_1/log_prob/truediv:0"
|  |  |  |  |  |  |  |  |  Op(Mul)	"X_1/log_prob/truediv"
|  |  |  |  |  |  |  |  |  |  Tensor(Const):0,	shape=[]	"ConstantFolding/X_1/log_prob/truediv_recip:0"
|  |  |  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"value_x:0"
|  |  |  |  |  |  |  |  Tensor(Const):0,	shape=[]	"X_1/log_prob/truediv_1:0"
|  |  |  |  |  |  Tensor(Const):0,	shape=[]	"Y_1/log_prob/mul/x:0"
|  |  |  |  Tensor(Const):0,	shape=[]	"Y_1/log_prob/add/x:0"
|  |  Tensor(Sub):0,	shape=[None]	"Y_1/log_prob/sub:0"
|  |  |  Op(Sub)	"Y_1/log_prob/sub"
|  |  |  |  Tensor(Mul):0,	shape=[None]	"Y_1/log_prob/mul:0"
|  |  |  |  |  Op(Mul)	"Y_1/log_prob/mul"
|  |  |  |  |  |  Tensor(SquaredDifference):0,	shape=[None]	"Y_1/log_prob/SquaredDifference:0"
|  |  |  |  |  |  |  Op(SquaredDifference)	"Y_1/log_prob/SquaredDifference"
|  |  |  |  |  |  |  |  Tensor(RealDiv):0,	shape=[None]	"Y_1/log_prob/truediv:0"
|  |  |  |  |  |  |  |  |  Op(RealDiv)	"Y_1/log_prob/truediv"
|  |  |  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"value_y:0"
|  |  |  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"tau:0"
|  |  |  |  |  |  |  |  Tensor(RealDiv):0,	shape=[None]	"Y_1/log_prob/truediv_1:0"
|  |  |  |  |  |  |  |  |  Op(RealDiv)	"Y_1/log_prob/truediv_1"
|  |  |  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"value_x:0"
|  |  |  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"tau:0"
|  |  |  |  |  |  Tensor(Const):0,	shape=[]	"Y_1/log_prob/mul/x:0"
|  |  |  |  Tensor(AddV2):0,	shape=[None]	"Y_1/log_prob/add:0"
|  |  |  |  |  Op(AddV2)	"Y_1/log_prob/add"
|  |  |  |  |  |  Tensor(Log):0,	shape=[None]	"Y_1/log_prob/Log:0"
|  |  |  |  |  |  |  Op(Log)	"Y_1/log_prob/Log"
|  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"tau:0"
|  |  |  |  |  |  Tensor(Const):0,	shape=[]	"Y_1/log_prob/add/x:0"


#+end_SRC

Listing [[non-trivial-transform-test-apply]] runs our transformation and Listing
[[non-trivial-transform-test-print]] prints the resulting graph.

#+NAME: non-trivial-transform-test-apply
#+BEGIN_SRC python :exports code :results silent
with graph_mode(), demo_graph.as_default():
    test_output_res, test_remaps = shift_squared_terms(hier_norm_lik, graph_inputs=[x_tf, y_tf])
#+END_SRC

#+NAME: non-trivial-transform-test-print
#+BEGIN_SRC python :exports both :results output :wrap "SRC text :eval never"
tf_dprint(test_output_res)
#+END_SRC

#+RESULTS: non-trivial-transform-test-print
#+begin_SRC text :eval never
Tensor(AddV2):0,	shape=[None]	"add_2:0"
|  Op(AddV2)	"add_2"
|  |  Tensor(Sub):0,	shape=[None]	"X_1/log_prob/sub_1:0"
|  |  |  Op(Sub)	"X_1/log_prob/sub_1"
|  |  |  |  Tensor(Mul):0,	shape=[None]	"X_1/log_prob/mul_1:0"
|  |  |  |  |  Op(Mul)	"X_1/log_prob/mul_1"
|  |  |  |  |  |  Tensor(SquaredDifference):0,	shape=[None]	"X_1/log_prob/SquaredDifference_1:0"
|  |  |  |  |  |  |  Op(SquaredDifference)	"X_1/log_prob/SquaredDifference_1"
|  |  |  |  |  |  |  |  Tensor(Const):0,	shape=[]	"X_1/log_prob/truediv_1:0"
|  |  |  |  |  |  |  |  Tensor(Mul):0,	shape=[None]	"X_1/log_prob/truediv_2:0"
|  |  |  |  |  |  |  |  |  Op(Mul)	"X_1/log_prob/truediv_2"
|  |  |  |  |  |  |  |  |  |  Tensor(Add):0,	shape=[None]	"Add_1:0"
|  |  |  |  |  |  |  |  |  |  |  Op(Add)	"Add_1"
|  |  |  |  |  |  |  |  |  |  |  |  Tensor(Mul):0,	shape=[None]	"Mul:0"
|  |  |  |  |  |  |  |  |  |  |  |  |  Op(Mul)	"Mul"
|  |  |  |  |  |  |  |  |  |  |  |  |  |  Tensor(Const):0,	shape=[]	"ConstantFolding/X_1/log_prob/truediv_recip:0"
|  |  |  |  |  |  |  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"value_x:0"
|  |  |  |  |  |  |  |  |  |  |  |  Tensor(Const):0,	shape=[]	"X_1/log_prob/truediv_1:0"
|  |  |  |  |  |  |  |  |  |  Tensor(Const):0,	shape=[]	"ConstantFolding/X_1/log_prob/truediv_recip:0"
|  |  |  |  |  |  Tensor(Const):0,	shape=[]	"Y_1/log_prob/mul/x:0"
|  |  |  |  Tensor(Const):0,	shape=[]	"Y_1/log_prob/add/x:0"
|  |  Tensor(Sub):0,	shape=[None]	"Y_1/log_prob/sub_1:0"
|  |  |  Op(Sub)	"Y_1/log_prob/sub_1"
|  |  |  |  Tensor(Mul):0,	shape=[None]	"Y_1/log_prob/mul_1:0"
|  |  |  |  |  Op(Mul)	"Y_1/log_prob/mul_1"
|  |  |  |  |  |  Tensor(SquaredDifference):0,	shape=[None]	"Y_1/log_prob/SquaredDifference_1:0"
|  |  |  |  |  |  |  Op(SquaredDifference)	"Y_1/log_prob/SquaredDifference_1"
|  |  |  |  |  |  |  |  Tensor(RealDiv):0,	shape=[None]	"Y_1/log_prob/truediv:0"
|  |  |  |  |  |  |  |  |  Op(RealDiv)	"Y_1/log_prob/truediv"
|  |  |  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"value_y:0"
|  |  |  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"tau:0"
|  |  |  |  |  |  |  |  Tensor(RealDiv):0,	shape=[None]	"Y_1/log_prob/truediv_1_1:0"
|  |  |  |  |  |  |  |  |  Op(RealDiv)	"Y_1/log_prob/truediv_1_1"
|  |  |  |  |  |  |  |  |  |  Tensor(Add):0,	shape=[None]	"Add_1:0"
|  |  |  |  |  |  |  |  |  |  |  ...
|  |  |  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"tau:0"
|  |  |  |  |  |  Tensor(Const):0,	shape=[]	"Y_1/log_prob/mul/x:0"
|  |  |  |  Tensor(AddV2):0,	shape=[None]	"Y_1/log_prob/add:0"
|  |  |  |  |  Op(AddV2)	"Y_1/log_prob/add"
|  |  |  |  |  |  Tensor(Log):0,	shape=[None]	"Y_1/log_prob/Log:0"
|  |  |  |  |  |  |  Op(Log)	"Y_1/log_prob/Log"
|  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[None]	"tau:0"
|  |  |  |  |  |  Tensor(Const):0,	shape=[]	"Y_1/log_prob/add/x:0"


#+end_SRC

From Listing [[non-trivial-transform-test-print]] we can see that
src_python[:eval never]{grappler} is not applying enough algebraic simplifications
to reduce the \(\left(\mu + x - \mu \right)^2 \) term.

* Transforming the Log-likelihood Graph

Now, we're ready to apply the transform to the radon model log-likelihood graph.

#+NAME: transform-logpfn
#+BEGIN_SRC python :results silent
with graph_mode(), tf.Graph().as_default() as trans_graph: #logpfn_fg.as_default():
    graph_inputs = [logpfn_fg.get_operation_by_name(i.name).outputs[0]
                    for i in logpfn_cf.structured_input_signature[0]]
    logpfn_trans_tf, logpfn_remaps = shift_squared_terms(logpfn_fg.outputs[0], graph_inputs=graph_inputs)
#+END_SRC

Listing [[print-transformed-remaps]] shows the replacements that were made
throughout the graph.  Two replacements were found and they appear to correspond
to the un-centered normal distribution terms src_python[:eval never]{a}
and src_python[:eval never]{b} in our model--as intended.

#+NAME: print-transformed-remaps
#+BEGIN_SRC python :exports both :results output :wrap "SRC text :eval never" :eval never-export
for r in logpfn_remaps:
    [tf_dprint(i) for i in r]
    print("------")
#+END_SRC

#+RESULTS: print-transformed-remaps
#+begin_SRC text :eval never
Tensor(Placeholder):0,	shape=[]	"values_1:0"
Tensor(Add):0,	shape=[]	"Add_12:0"
|  Op(Add)	"Add"
|  |  Tensor(Const):0,	shape=[]	"add_1/x:0"
|  |  Tensor(Mul):0,	shape=[]	"Mul_4:0"
|  |  |  Op(Mul)	"Mul"
|  |  |  |  Tensor(Const):0,	shape=[]	"exp_3_2/inverse_log_det_jacobian/mul_1:0"
|  |  |  |  Tensor(Placeholder):0,	shape=[]	"values_1:0"
------
Tensor(Placeholder):0,	shape=[]	"values_5:0"
Tensor(Add):0,	shape=[]	"Add_13:0"
|  Op(Add)	"Add"
|  |  Tensor(Const):0,	shape=[]	"add_1/x:0"
|  |  Tensor(Mul):0,	shape=[]	"Mul_5:0"
|  |  |  Op(Mul)	"Mul"
|  |  |  |  Tensor(Const):0,	shape=[]	"exp_3_2/inverse_log_det_jacobian/mul_1:0"
|  |  |  |  Tensor(Placeholder):0,	shape=[]	"values_5:0"
------


#+end_SRC

Likewise, Listing [[show-squared-diff-terms-in-trans]] shows
all src_python[:eval never]{Square}
and src_python[:eval never]{SquaredDifference} subgraphs that appear in the
transformed log-likelihood.

#+NAME: show-squared-diff-terms-in-trans
#+BEGIN_SRC python :exports both :results output :wrap "SRC text :eval never"
square_diff_outs = [o.outputs[0] for o in logpfn_trans_tf.graph.get_operations()
                    if o.type == 'SquaredDifference' or o.type == 'Square']

for t in square_diff_outs[:4]:
    tf_dprint(t)
#+END_SRC

#+RESULTS: show-squared-diff-terms-in-trans
#+begin_SRC text :eval never
Tensor(SquaredDifference):0,	shape=[85]	"SampleNormal_3_1/log_prob/Normal_3/log_prob/SquaredDifference_1:0"
|  Op(SquaredDifference)	"SampleNormal_3_1/log_prob/Normal_3/log_prob/SquaredDifference_1"
|  |  Tensor(RealDiv):0,	shape=[85]	"SampleNormal_3_1/log_prob/Normal_3/log_prob/truediv:0"
|  |  |  Op(RealDiv)	"SampleNormal_3_1/log_prob/Normal_3/log_prob/truediv"
|  |  |  |  Tensor(Reshape):0,	shape=[85]	"SampleNormal_3_1/log_prob/Reshape:0"
|  |  |  |  |  Op(Reshape)	"SampleNormal_3_1/log_prob/Reshape"
|  |  |  |  |  |  Tensor(Placeholder):0,	shape=[85]	"values_3:0"
|  |  |  |  |  |  Tensor(Const):0,	shape=[1]	"SampleNormal_2_1/log_prob/Reshape/shape:0"
|  |  |  |  Tensor(Exp):0,	shape=[]	"exp_2_1/forward/Exp:0"
|  |  |  |  |  Op(Exp)	"exp_2_1/forward/Exp"
|  |  |  |  |  |  Tensor(Placeholder):0,	shape=[]	"values_0:0"
|  |  Tensor(RealDiv):0,	shape=[]	"SampleNormal_3_1/log_prob/Normal_3/log_prob/truediv_1_1:0"
|  |  |  Op(RealDiv)	"SampleNormal_3_1/log_prob/Normal_3/log_prob/truediv_1_1"
|  |  |  |  Tensor(Add):0,	shape=[]	"Add_12:0"
|  |  |  |  |  Op(Add)	"Add_12"
|  |  |  |  |  |  Tensor(Mul):0,	shape=[]	"Mul_4:0"
|  |  |  |  |  |  |  Op(Mul)	"Mul_4"
|  |  |  |  |  |  |  |  Tensor(Const):0,	shape=[]	"exp_3_2/inverse_log_det_jacobian/mul_1:0"
|  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[]	"values_1:0"
|  |  |  |  |  |  Tensor(Const):0,	shape=[]	"add_1/x:0"
|  |  |  |  Tensor(Exp):0,	shape=[]	"exp_2_1/forward/Exp:0"
|  |  |  |  |  ...
Tensor(SquaredDifference):0,	shape=[]	"Normal_1_1/log_prob/SquaredDifference_1:0"
|  Op(SquaredDifference)	"Normal_1_1/log_prob/SquaredDifference_1"
|  |  Tensor(Mul):0,	shape=[]	"Normal_1_1/log_prob/truediv_1:0"
|  |  |  Op(Mul)	"Normal_1_1/log_prob/truediv_1"
|  |  |  |  Tensor(Add):0,	shape=[]	"Add_12:0"
|  |  |  |  |  Op(Add)	"Add_12"
|  |  |  |  |  |  Tensor(Mul):0,	shape=[]	"Mul_4:0"
|  |  |  |  |  |  |  Op(Mul)	"Mul_4"
|  |  |  |  |  |  |  |  Tensor(Const):0,	shape=[]	"exp_3_2/inverse_log_det_jacobian/mul_1:0"
|  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[]	"values_1:0"
|  |  |  |  |  |  Tensor(Const):0,	shape=[]	"add_1/x:0"
|  |  |  |  Tensor(Const):0,	shape=[]	"exp_3_2/inverse_log_det_jacobian/mul_1:0"
|  |  Tensor(Const):0,	shape=[]	"add_1/x:0"
Tensor(SquaredDifference):0,	shape=[85]	"SampleNormal_2_1/log_prob/Normal_2/log_prob/SquaredDifference_1:0"
|  Op(SquaredDifference)	"SampleNormal_2_1/log_prob/Normal_2/log_prob/SquaredDifference_1"
|  |  Tensor(RealDiv):0,	shape=[85]	"SampleNormal_2_1/log_prob/Normal_2/log_prob/truediv:0"
|  |  |  Op(RealDiv)	"SampleNormal_2_1/log_prob/Normal_2/log_prob/truediv"
|  |  |  |  Tensor(Reshape):0,	shape=[85]	"SampleNormal_2_1/log_prob/Reshape:0"
|  |  |  |  |  Op(Reshape)	"SampleNormal_2_1/log_prob/Reshape"
|  |  |  |  |  |  Tensor(Placeholder):0,	shape=[85]	"values_6:0"
|  |  |  |  |  |  Tensor(Const):0,	shape=[1]	"SampleNormal_2_1/log_prob/Reshape/shape:0"
|  |  |  |  Tensor(Exp):0,	shape=[]	"exp_1/forward/Exp:0"
|  |  |  |  |  Op(Exp)	"exp_1/forward/Exp"
|  |  |  |  |  |  Tensor(Placeholder):0,	shape=[]	"values_4:0"
|  |  Tensor(RealDiv):0,	shape=[]	"SampleNormal_2_1/log_prob/Normal_2/log_prob/truediv_1_1:0"
|  |  |  Op(RealDiv)	"SampleNormal_2_1/log_prob/Normal_2/log_prob/truediv_1_1"
|  |  |  |  Tensor(Add):0,	shape=[]	"Add_13:0"
|  |  |  |  |  Op(Add)	"Add_13"
|  |  |  |  |  |  Tensor(Mul):0,	shape=[]	"Mul_5:0"
|  |  |  |  |  |  |  Op(Mul)	"Mul_5"
|  |  |  |  |  |  |  |  Tensor(Const):0,	shape=[]	"exp_3_2/inverse_log_det_jacobian/mul_1:0"
|  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[]	"values_5:0"
|  |  |  |  |  |  Tensor(Const):0,	shape=[]	"add_1/x:0"
|  |  |  |  Tensor(Exp):0,	shape=[]	"exp_1/forward/Exp:0"
|  |  |  |  |  ...
Tensor(SquaredDifference):0,	shape=[]	"Normal_5/log_prob/SquaredDifference_1:0"
|  Op(SquaredDifference)	"Normal_5/log_prob/SquaredDifference_1"
|  |  Tensor(Mul):0,	shape=[]	"Normal_5/log_prob/truediv_1:0"
|  |  |  Op(Mul)	"Normal_5/log_prob/truediv_1"
|  |  |  |  Tensor(Add):0,	shape=[]	"Add_13:0"
|  |  |  |  |  Op(Add)	"Add_13"
|  |  |  |  |  |  Tensor(Mul):0,	shape=[]	"Mul_5:0"
|  |  |  |  |  |  |  Op(Mul)	"Mul_5"
|  |  |  |  |  |  |  |  Tensor(Const):0,	shape=[]	"exp_3_2/inverse_log_det_jacobian/mul_1:0"
|  |  |  |  |  |  |  |  Tensor(Placeholder):0,	shape=[]	"values_5:0"
|  |  |  |  |  |  Tensor(Const):0,	shape=[]	"add_1/x:0"
|  |  |  |  Tensor(Const):0,	shape=[]	"exp_3_2/inverse_log_det_jacobian/mul_1:0"
|  |  Tensor(Const):0,	shape=[]	"add_1/x:0"


#+end_SRC

* Creating a new Log-likelihood Function

Now that we have a transformed version of the original log-likelihood graph
(i.e. src_python[:eval never]{logpfn_trans_tf}), we need to create a
new src_python[:eval never]{FuncGraph} from it.  Listing [[create-new-func-graph]]
provides a simple function that creates a
new src_python[:eval never]{ConcreteFunction} from an updated output node.

#+NAME: create-new-func-graph
#+BEGIN_SRC python :results silent
from tensorflow.python.framework.func_graph import FuncGraph
from tensorflow.python.eager.function import ConcreteFunction
from tensorflow.python.eager.lift_to_graph import lift_to_graph


def new_tf_function(output, orig_cf):
    """Create a new ConcreteFunction by replacing a single output in an existing FuncGraph.

    """
    orig_fg = orig_cf.graph
    # with trans_graph.as_default(): #orig_fg.as_default():

    logpfn_fg_new = FuncGraph('logpfn_new', orig_fg.collections, orig_fg.capture_by_value)

    old_to_new_ops = lift_to_graph([output],
                                    logpfn_fg_new,
                                    add_sources=True,
                                    handle_captures=True)

    logpfn_fg_new.structured_input_signature = orig_fg.structured_input_signature

    new_inputs = [old_to_new_ops.get(output.graph.get_operation_by_name(i.name).outputs[0])
                  for i in orig_cf.structured_input_signature[0]]

    logpfn_fg_new.inputs = new_inputs

    assert all(i is not None for i in logpfn_fg_new.inputs)

    logpfn_fg_new.outputs = [old_to_new_ops[output]]
    logpfn_fg_new.structured_outputs = logpfn_fg_new.outputs[0]

    assert logpfn_fg_new.as_graph_element(logpfn_fg_new.outputs[0]) is not None

    logpfn_new_cf = ConcreteFunction(logpfn_fg_new)
    logpfn_new_cf._arg_keywords = orig_cf._arg_keywords
    logpfn_new_cf._num_positional_args = len(logpfn_fg_new.inputs)

    return logpfn_new_cf
#+END_SRC

#+NAME: create-new-func-graph
#+BEGIN_SRC python :exports code :results silent
logpfn_new_cf = new_tf_function(logpfn_trans_tf, logpfn_cf)
#+END_SRC

The new TF function, src_python[:eval never]{logpfn_new_cf}, in Listing
[[create-new-func-graph]] is the function we are going to use for sampling
from the new log-likelihood.

#+NAME: demo-diff-fgraph-output
#+BEGIN_SRC python :results value :wrap "SRC python :eval never"
_ = logpfn_cf(*init.values()) - logpfn_new_cf(*init.values())
#+END_SRC

#+RESULTS: demo-diff-fgraph-output
#+begin_SRC python :eval never
tf.Tensor(0.0, shape=(), dtype=float32)
#+end_SRC

Listing [[demo-diff-fgraph-output]] shows the difference between a transformed and
non-transformed log-likelihood value given the same inputs.


* Sampling from the new Log-likelihood

In Listing [[sample-transformed-model]], we reproduce the remaining steps
of src_python[:eval never]{pm.inference.sampling.sample} and--unnaturally--force
the PyMC4 machinery to draw samples from our new transformed log-likelihood
function.

#+NAME: hijack-build-logp
#+BEGIN_SRC python :results silent
from importlib import reload


# Let's make sure we save the original function
reload(pm.inference.sampling)
_build_logp_function = pm.inference.sampling.build_logp_function


def _new_build_logp_function(*args, **kwargs):
    return logpfn_new_cf, init

pm.inference.sampling.build_logp_function = _new_build_logp_function
#+END_SRC

#+NAME: sample-transformed-model
#+BEGIN_SRC python :results silent :eval never
az_trace = sample(model)
#+END_SRC

#+NAME: sample-transformed-model-pickle
#+BEGIN_SRC python :eval never-export :exports none :noweb yes :results silent
import os
import pickle


if os.path.exists('az_trans_trace.pkl'):
    with open('az_trans_trace.pkl', 'rb') as f:
        az_trace = pickle.load(f)
else:
    <<sample-transformed-model>>

    with open('az_trans_trace.pkl', 'wb') as f:
        pickle.dump(az_trace, f)
#+END_SRC

# #+HEADER: :post org_fig_wrap(data=*this*, options="[keepaspectratio]", placement="[p!]", caption="")
#+NAME: transformed-model-plot-energy
#+HEADER: :var output_dir=(btw--org-publish-property :figure-dir)
#+BEGIN_SRC python :eval never-export :exports results :results value raw
_ = az.plot_energy(az_trace)
#+END_SRC

#+CALL: generate-python-plots[:results silent :eval never-export](code-block-name="transformed-model-plot-energy")

#+RESULTS:
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 1.0\textwidth :height 1.0\textwidth :float t :options [keepaspectratio] :placement [p!]
#+CAPTION:
#+NAME: fig:transformed-model-plot-energy
[[file:../../figures/transformed-model-plot-energy.png]]


#+NAME: transformed-model-plot-trace
#+HEADER: :var output_dir=(btw--org-publish-property :figure-dir)
#+BEGIN_SRC python :eval never-export :exports results :results value raw
_ = az.plot_trace(az_trace, compact=True)
#+END_SRC

#+CALL: generate-python-plots[:results silent :eval never-export](code-block-name="transformed-model-plot-trace")

#+RESULTS:
#+ATTR_ORG: :width 800
#+ATTR_LATEX: :width 1.0\textwidth :height 1.0\textwidth :float t :options [keepaspectratio] :placement [p!]
#+CAPTION:
#+NAME: fig:transformed-model-plot-trace
[[file:../../figures/transformed-model-plot-trace.png]]


* Discussion

The goals in the two separate src_python[:eval never]{run} calls we used in
Listing [[kanren-shift-squaredo-func]] could have been combined into a
single src_python[:eval never]{run}.  This could've been accomplished using some
"meta" steps (e.g. construct and evaluate a goal on-the-fly within a
miniKanren) or special goals for reading from a
miniKanren-generated src_python[:eval never]{dict}s or association lists.
Goals of this nature are not uncommon (e.g. type inference and inhabitation exmaples),
and serve to demonstrate the great breadth of activity possible within relational
context of miniKanren.

However, the point we want to make doesn't require much sophistication.
Instead, we wanted to demonstrate how a non-trivial "pattern" can be specified
and matched using src_python[:eval never]{symbolic-pymc}, and how easily those results
could be used to transform a graph.

More specifically, our goal src_python[:eval never]{shift_squared_subso} in
[[kanren-shift-squaredo-func]] demonstrates *the way in which we were able to
specify desired structure(s) within a graph*.
We defined one pattern, src_python[:eval never]{Y_sqrdiffo}, to match anywhere
in the graph then another pattern, src_python[:eval never]{X_sqrdiffo}, that
relied on matched terms from src_python[:eval never]{Y_sqrdiffo} and could also
be matched/found anywhere else in the same graph.

Furthermore, our substitutions needed information from both "matched" subgraphs.
Specifically, substitution pairs similar
to src_python[:eval never]{(x, z + x)}.  Within this framework, we could just as
easily have included src_python[:eval never]{y}--or any terms from either
successfully matched subgraph--in the substitution expressions.

In sample-space, the search patterns and substitutions are much easier to specify exactly
because they're single-subgraph patterns that themselves are the subgraphs to be replaced
(i.e. if we find a non-standard normal, replace it with a shifted/scaled standard normal).
In log-space, we chose to find distinct subgraph "chains",
i.e. all src_python[:eval never]{(y - x)**2}
and src_python[:eval never]{(x - z)**2} pairs (i.e. "connected" by an "unknown"
term src_python[:eval never]{x}), since these are produced by the log-likelihood form of
hierarchical normal distributions.

As a result, we had a non-trivial structure/"pattern" to express--and execute.  Using
conventional graph search-and-replace functionality would've required much more orchestration
and resulted considerably less flexible code with little-to-no reusability.
In our case, the goals src_python[:eval never]{onceo} and src_python[:eval never]{tf_graph_applyo}
are universal and the forms in src_python[:eval never]{shift_squared_subso} can be easily
changed to account for more sophisticated (or entirely distinct) patterns and substitutions.

Most related graph manipulation offerings make it easy to find a single subgraph that
matches a pattern, but not potentially "co-dependent" and/or distinct subgraphs.
In the end, the developer will often have to manually implement a "global" state
and orchestrate multiple single-subgraph searches and their results.

For single search-and-replace objectives, this amount of manual developer
intervention/orchestration might be excusable; however, for objectives requiring
the evaluation of multiple graph transformation, this approach is mostly
unmaintainable and extremely difficult to compartmentalize.


This demonstration barely even scratches the surface of what's possible
using miniKanren and relational programming for graph manipulation and
symbolic statistical model optimization.  As the src_python[:eval never]{symbolic-pymc}
project advances, we'll cover examples in which miniKanren's more distinct
offerings are demonstrated.

# Even so, there's a lot of room for performance and usage/API improvements, and those
# improvements are well compartmentalized and conceptually meaningful within the
# miniKanren framework.  For instance, the exact way in which graphs are traversed is
# relegated to the inner workings of goals and many improvements on the implementations used
# here are possible.  These changes can be made without affecting the relations that such goal
# combinations implement exclusively model the high-level math/probability
# concepts.
