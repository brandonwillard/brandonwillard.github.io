<!DOCTYPE html>
<html lang="en"
>
<head>
    <title>More Proximal Estimation - Brandon T. Willard</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="https://brandonwillard.github.io/more-proximal-estimation.html">

        <meta name="author" content="Brandon T. Willard" />
        <meta name="description" content="More Proximal Estimation code{white-space: pre;} div.sourceCode { overflow-x: auto; } table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode { margin: 0; padding: 0; vertical-align: baseline; border: none; } table.sourceCode { width: 100%; line-height: 100%; background-color: #ffffff; color: #1f1c1b; } td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; background-color: #ffffff; color: #a0a0a0; border-right: 1px ..." />

        <meta property="og:site_name" content="Brandon T. Willard" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="More Proximal Estimation"/>
        <meta property="og:url" content="https://brandonwillard.github.io/more-proximal-estimation.html"/>
        <meta property="og:description" content="More Proximal Estimation code{white-space: pre;} div.sourceCode { overflow-x: auto; } table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode { margin: 0; padding: 0; vertical-align: baseline; border: none; } table.sourceCode { width: 100%; line-height: 100%; background-color: #ffffff; color: #1f1c1b; } td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; background-color: #ffffff; color: #a0a0a0; border-right: 1px ..."/>
        <meta property="article:published_time" content="2017-03-06" />
            <meta property="article:section" content="articles" />
            <meta property="article:author" content="Brandon T. Willard" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://brandonwillard.github.io/theme/css/bootstrap.readable.min.css" type="text/css"/>
    <link href="https://brandonwillard.github.io/theme/css/font-awesome.min.css" rel="stylesheet">
    <link href="https://brandonwillard.github.io/theme/css/academicons.min.css" rel="stylesheet">

    <link href="https://brandonwillard.github.io/theme/css/pygments/vim.css" rel="stylesheet">
    <link rel="stylesheet" href="https://brandonwillard.github.io/theme/css/style.css" type="text/css"/>
        <link href="https://brandonwillard.github.io/extra/custom.css" rel="stylesheet">

        <link href="https://brandonwillard.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Brandon T. Willard ATOM Feed"/>
        <link href="https://brandonwillard.github.io/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="Brandon T. Willard RSS Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://brandonwillard.github.io/" class="navbar-brand">
Brandon T. Willard            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                         <li><a href="https://brandonwillard.github.io/pages/about.html">
                             About
                          </a></li>
                         <li><a href="https://brandonwillard.github.io/pages/projects.html">
                             Projects
                          </a></li>
                         <li><a href="https://brandonwillard.github.io/pages/publications.html">
                             Publications
                          </a></li>
                        <li class="active">
                            <a href="https://brandonwillard.github.io/category/articles.html">Articles</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://brandonwillard.github.io/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">

    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="https://brandonwillard.github.io/more-proximal-estimation.html"
                       rel="bookmark"
                       title="Permalink to More Proximal Estimation">
                        More Proximal Estimation
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2017-03-06T00:00:00-06:00"> Mon 06 March 2017</time>
    </span>



    
</footer><!-- /.post-info -->                    </div>
                </div>
                <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Brandon T. Willard" />
  <title>More Proximal Estimation</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #ffffff; color: #1f1c1b; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; background-color: #ffffff; color: #a0a0a0; border-right: 1px solid #a0a0a0; }
td.sourceCode { padding-left: 5px; }
pre, code { color: #1f1c1b; background-color: #ffffff; }
code > span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
code > span.dt { color: #0057ae; } /* DataType */
code > span.dv { color: #b08000; } /* DecVal */
code > span.bn { color: #b08000; } /* BaseN */
code > span.fl { color: #b08000; } /* Float */
code > span.cn { color: #aa5500; } /* Constant */
code > span.ch { color: #924c9d; } /* Char */
code > span.sc { color: #3daee9; } /* SpecialChar */
code > span.st { color: #bf0303; } /* String */
code > span.vs { color: #bf0303; } /* VerbatimString */
code > span.ss { color: #ff5500; } /* SpecialString */
code > span.im { color: #ff5500; } /* Import */
code > span.co { color: #898887; } /* Comment */
code > span.do { color: #607880; } /* Documentation */
code > span.an { color: #ca60ca; } /* Annotation */
code > span.cv { color: #0095ff; } /* CommentVar */
code > span.ot { color: #006e28; } /* Other */
code > span.fu { color: #644a9b; } /* Function */
code > span.va { color: #0057ae; } /* Variable */
code > span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
code > span.op { color: #1f1c1b; } /* Operator */
code > span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
code > span.ex { color: #0095ff; font-weight: bold; } /* Extension */
code > span.pp { color: #006e28; } /* Preprocessor */
code > span.at { color: #0057ae; } /* Attribute */
code > span.re { color: #0057ae; } /* RegionMarker */
code > span.in { color: #b08000; } /* Information */
code > span.wa { color: #bf0303; } /* Warning */
code > span.al { color: #bf0303; font-weight: bold; } /* Alert */
code > span.er { color: #bf0303; text-decoration: underline; } /* Error */
code > span. { color: #1f1c1b; } /* Normal */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<!--  -->
<!-- <div id="header"> -->
<!-- <h1 class="title">More Proximal Estimation</h1> -->
<!--  -->
<!--  -->
<!-- <h2 class="author">Brandon T. Willard</h2> -->
<!--  -->
<!--  -->
<!-- <h3 class="date">2017–03–06</h3> -->
<!--  -->
<!-- </div> -->
<!--  -->
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>The focal point of this short exposition will be an elaboration of the basic <span class="math inline">\(\ell_1\)</span> penalization problem discussed in <span class="citation" data-cites="willard_role_2017">Willard (2017)</span>, <span class="math display">\[\begin{equation}
\operatorname*{argmin}_{\beta} \left\{
  \frac{1}{2} \|y - X \beta\|^2_2
    + \lambda \|\beta\|_1
  \right\}
  \;.
  \label{eq:lasso}
\end{equation}\]</span> We continue our discussion on topics concerning automation and symbolic computation in Theano <span class="citation" data-cites="bergstra_theano_2010">(Bergstra et al. 2010)</span>, as well as the mathematical methodology we believe is suitable for such implementations. Again, our framing of the problem is in terms of “proximal methods” <span class="citation" data-cites="parikh_proximal_2014 combettes_proximal_2011">(Parikh and Boyd 2014; Combettes and Pesquet 2011)</span>. Along the way we propose one simple means of placing the well-known technique of coordinate descent within the scope of proximal methods via a general property of proximal operators. These efforts are a continued outgrowth of our work in <span class="citation" data-cites="polson_proximal_2015">Polson, Scott, and Willard (2015)</span>.</p>
</section>
<section id="proximal-and-computational-components" class="level1">
<h1>Proximal and Computational Components</h1>
<p>First, we [re]-introduce the workhorse of proximal methods: the <em>proximal operator</em>.</p>
<div class="Def" markdown="" env-number="1" title-name="[Proximal Operator]">
<p><span class="math display">\[\begin{equation*}
\operatorname*{prox}_{\phi}(x) =
    \operatorname*{argmin}_{z} \left\{
    \frac{1}{2} \left(z - x\right)^2 + \phi(z)
    \right\}
    \;.
\end{equation*}\]</span></p>
</div>
<p>Inspired by Equation <span class="math inline">\(\eqref{eq:lasso}\)</span>, we produce a toy dataset as follows:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> theano <span class="im">import</span> shared <span class="im">as</span> tt_shared

M <span class="op">=</span> <span class="dv">50</span>
M_nonzero <span class="op">=</span> M <span class="op">*</span> <span class="dv">2</span> <span class="op">//</span> <span class="dv">10</span>

beta_true <span class="op">=</span> np.zeros(M)
beta_true[:M_nonzero] <span class="op">=</span> np.exp(<span class="op">-</span>np.arange(M_nonzero)) <span class="op">*</span> <span class="dv">100</span>

N <span class="op">=</span> <span class="bu">int</span>(np.alen(beta_true) <span class="op">*</span> <span class="fl">0.4</span>)
X <span class="op">=</span> np.random.randn(N, M)
mu_true <span class="op">=</span> X.dot(beta_true)
y <span class="op">=</span> mu_true <span class="op">+</span> sc.stats.norm.rvs(np.zeros(N), scale<span class="op">=</span><span class="dv">10</span>)

X_tt <span class="op">=</span> tt_shared(X, name<span class="op">=</span><span class="st">&#39;X&#39;</span>, borrow<span class="op">=</span><span class="va">True</span>)
y_tt <span class="op">=</span> tt_shared(y, name<span class="op">=</span><span class="st">&#39;y&#39;</span>, borrow<span class="op">=</span><span class="va">True</span>)

<span class="co"># Estimation starting parameters...</span>
beta_0 <span class="op">=</span> np.zeros(X.shape[<span class="dv">1</span>]).astype(<span class="st">&#39;float64&#39;</span>)

<span class="co"># Gradient [starting] step size</span>
alpha_0 <span class="op">=</span> <span class="dv">1</span>. <span class="op">/</span> np.linalg.norm(X, <span class="dv">2</span>)<span class="op">**</span><span class="dv">2</span>
<span class="co"># np.linalg.matrix_rank(X)</span>

<span class="co"># Regularization value heuristic</span>
<span class="co"># beta_ols = np.linalg.lstsq(X, y)[0]</span>
<span class="co"># lambda_max = 0.1 * np.linalg.norm(beta_ols, np.inf)</span>
lambda_max <span class="op">=</span> np.linalg.norm(X.T.dot(y), np.inf)</code></pre></div>
<p>As in <span class="citation" data-cites="willard_role_2017">Willard (2017)</span>, we can start with a model defined within a system like PyMC3 <span class="citation" data-cites="salvatier_probabilistic_2016">(Salvatier, Wiecki, and Fonnesbeck 2016)</span>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">with</span> pm.Model() <span class="im">as</span> lasso_model:
    beta_rv <span class="op">=</span> pm.Laplace(<span class="st">&#39;beta&#39;</span>, mu<span class="op">=</span><span class="dv">0</span>, b<span class="op">=</span><span class="dv">1</span>,
                         shape<span class="op">=</span>X.shape[<span class="dv">1</span>])
    y_rv <span class="op">=</span> pm.Normal(<span class="st">&#39;y&#39;</span>, mu<span class="op">=</span>X_tt.dot(beta_rv), sd<span class="op">=</span><span class="dv">1</span>,
                     shape<span class="op">=</span>y.shape[<span class="dv">0</span>], observed<span class="op">=</span>y_tt)</code></pre></div>
<p>In this setting one might then arrive at the necessary steps toward estimation automatically (i.e. identify the underlying <span class="math inline">\(\ell_1\)</span> estimation problem). We discuss this more in <span class="citation" data-cites="willard_role_2017">Willard (2017)</span>.</p>
<p>For simplicity we’ll just assume that all components of the estimation problem are know–i.e. loss and penalty functions. The proximal operator that arises in this standard example is the <em>soft thresholding</em> operator. In Theano, it can be implemented with the following:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> tt_soft_threshold(beta_, lambda_):
    <span class="cf">return</span> tt.sgn(beta_) <span class="op">*</span> tt.maximum(tt.abs_(beta_) <span class="op">-</span> lambda_, <span class="dv">0</span>)</code></pre></div>
<div class="remark" markdown="" env-number="1" title-name="">
<p>This operator can take other forms, and the one used here is likely not the best. The <code>maximum</code> can be replaced by other conditional-like statements–such as <span class="math display">\[\begin{equation*}
\operatorname{S}(z, \lambda) =
    \begin{cases}
     {\mathop{\mathrm{sgn}}}(\beta) (\beta - \lambda) &amp; \beta &gt; \lambda
     \\
     0 &amp; \text{otherwise}
    \end{cases}
    \;.
\end{equation*}\]</span> If we were to–say–multiply the output of this operator with another, more difficult to compute result, then we might also wish to extend this multiplication into the definition of the operator and avoid its computation in the <span class="math inline">\(\beta \leq \lambda\)</span> case.</p>
<p>Barring any reuses of this quantity, or a need to preserve undefined results produced by an expensive product with zero, we would ideally like a “compiler” to make such an optimization itself. It isn’t clear how a standard compiler–or interpreter/hybrid–could safely make this optimization, whereas it does seem more reasonable as a symbolic/Theano optimization.</p>
<p>Optimizations like this are–I think–a necessary step to enable expressive, generalized methods, truly rapid prototyping at the math level.</p>
</div>
<p>Now, assuming that we’ve obtained the relevant loss and penalty functions–for example, in PyMC3–then we can proceed to setting up the exact context of our proximal problem.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> theano <span class="im">import</span> clone <span class="im">as</span> tt_clone

<span class="co"># Clone the negative log-likelihood of our observation model.</span>
nlogl_rv <span class="op">=</span> <span class="op">-</span>lasso_model.observed_RVs[<span class="dv">0</span>].logpt
nlogl <span class="op">=</span> tt_clone(nlogl_rv)
nlogl.name <span class="op">=</span> <span class="st">&quot;-logl&quot;</span>
beta_tt <span class="op">=</span> tt_inputs([nlogl])[<span class="dv">4</span>]</code></pre></div>
</section>
<section id="proximal-gradient" class="level1">
<h1>Proximal Gradient</h1>
<p>In what follows it will be convenient to generalize a bit and work in terms of arbitrary loss and penalty functions <span class="math inline">\(l\)</span> and <span class="math inline">\(\phi\)</span>, respectively, which in our case corresponds to <span class="math display">\[\begin{equation*}
\begin{gathered}
  l(\beta) = \frac12 \|y - X \beta\|^2_2, \quad
  \text{and}\;
  \phi(\beta) = \|\beta\|_1
  \;.\end{gathered}
\end{equation*}\]</span></p>
<p>The proximal gradient <span class="citation" data-cites="combettes_proximal_2011">(Combettes and Pesquet 2011)</span> algorithm is a staple of the proximal framework that provides solutions to problems of the form <span class="math display">\[\begin{equation*}
\operatorname*{argmin}_\beta \left\{
    l(\beta) + \lambda \phi(\beta)
  \right\}
  \;.
\end{equation*}\]</span> when both <span class="math inline">\(l\)</span> and <span class="math inline">\(\phi\)</span> are lower semi-continuous convex functions, and <span class="math inline">\(l\)</span> is differentiable with Lipschitz gradient.</p>
<p>The solution is given as the following fixed-point: <span class="math display">\[\begin{equation}
\beta = \operatorname*{prox}_{\alpha \lambda \phi}(\beta - \alpha \nabla l(\beta))
  \;.
  \label{eq:forward-backward}
\end{equation}\]</span> The constant step size <span class="math inline">\(\alpha\)</span> is related to the Lipschitz constant of <span class="math inline">\(\nabla l\)</span>, but can more generally be a sequence obeying certain constraints. Since our <span class="math inline">\(l\)</span> under consideration is <span class="math inline">\(\ell_2\)</span>, we have the incredibly standard <span class="math inline">\(\nabla l(\beta) = X^\top (X \beta - y)\)</span>.</p>
<section id="implementation" class="level2">
<h2>Implementation</h2>
<p>As in <span class="citation" data-cites="willard_role_2017">Willard (2017)</span>, we provide an implementation of a proximal gradient step.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> theano <span class="im">import</span> function <span class="im">as</span> tt_function
<span class="im">from</span> theano.<span class="bu">compile</span>.nanguardmode <span class="im">import</span> NanGuardMode

tt_func_mode <span class="op">=</span> NanGuardMode(nan_is_error<span class="op">=</span><span class="va">True</span>,
                            inf_is_error<span class="op">=</span><span class="va">False</span>,
                            big_is_error<span class="op">=</span><span class="va">False</span>)


<span class="kw">def</span> prox_gradient_step(loss, beta_tt, prox_func,
                       alpha_tt<span class="op">=</span><span class="va">None</span>, lambda_tt<span class="op">=</span><span class="va">None</span>,
                       return_loss_grad<span class="op">=</span><span class="va">False</span>,
                       tt_func_kwargs<span class="op">=</span>{<span class="st">&#39;mode&#39;</span>: tt_func_mode}
                       ):
    <span class="co">r&quot;&quot;&quot; Creates a function that produces a proximal gradient step.</span>

<span class="co">    Arguments</span>
<span class="co">    =========</span>
<span class="co">    loss: TensorVariable</span>
<span class="co">        Continuously differentiable &quot;loss&quot; function in the objective</span>
<span class="co">        function.</span>
<span class="co">    beta_tt: TensorVariable</span>
<span class="co">        Variable argument of the loss function.</span>
<span class="co">    prox_fn: function</span>
<span class="co">        Function that computes the proximal operator for the &quot;penalty&quot;</span>
<span class="co">        function.  Must take two parameters: the first a</span>
<span class="co">TensorVariable</span>
<span class="co">        of the gradient step, the second a float or Scalar value.</span>
<span class="co">    alpha_tt: float, Scalar (optional)</span>
<span class="co">        Gradient step size.</span>
<span class="co">    lambda_tt: float, Scalar (optional)</span>
<span class="co">        Additional scalar value passed to `prox_fn`.</span>
<span class="co">        </span><span class="al">TODO</span><span class="co">: Not sure if this should be here; is redundant.</span>
<span class="co">    &quot;&quot;&quot;</span>
    loss_grad <span class="op">=</span> tt.grad(loss, wrt<span class="op">=</span>beta_tt)
    loss_grad.name <span class="op">=</span> <span class="st">&quot;loss_grad&quot;</span>

    <span class="cf">if</span> alpha_tt <span class="kw">is</span> <span class="va">None</span>:
        alpha_tt <span class="op">=</span> tt.scalar(name<span class="op">=</span><span class="st">&#39;alpha&#39;</span>)
        alpha_tt.tag.test_value <span class="op">=</span> <span class="dv">1</span>
    <span class="cf">if</span> lambda_tt <span class="kw">is</span> <span class="va">None</span>:
        lambda_tt <span class="op">=</span> tt.scalar(name<span class="op">=</span><span class="st">&#39;lambda&#39;</span>)
        lambda_tt.tag.test_value <span class="op">=</span> <span class="dv">1</span>

    beta_grad_step <span class="op">=</span> beta_tt <span class="op">-</span> alpha_tt <span class="op">*</span> loss_grad
    beta_grad_step.name <span class="op">=</span> <span class="st">&quot;beta_grad_step&quot;</span>

    prox_grad_step <span class="op">=</span> prox_func(beta_grad_step, lambda_tt <span class="op">*</span> alpha_tt)
    prox_grad_step.name <span class="op">=</span> <span class="st">&quot;prox_grad_step&quot;</span>

    inputs <span class="op">=</span> []
    updates <span class="op">=</span> <span class="va">None</span>
    <span class="cf">if</span> <span class="bu">isinstance</span>(beta_tt, tt.sharedvar.SharedVariable):
        updates <span class="op">=</span> [(beta_tt, prox_grad_step)]
    <span class="cf">else</span>:
        inputs <span class="op">+=</span> [beta_tt]
    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(alpha_tt, tt.sharedvar.SharedVariable):
        inputs <span class="op">+=</span> [alpha_tt]
    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(lambda_tt, tt.sharedvar.SharedVariable):
        inputs <span class="op">+=</span> [lambda_tt]

    prox_grad_step_fn <span class="op">=</span> tt_function(inputs,
                                    prox_grad_step,
                                    updates<span class="op">=</span>updates,
                                    <span class="op">**</span>tt_func_kwargs)

    res <span class="op">=</span> (prox_grad_step_fn,)
    <span class="cf">if</span> return_loss_grad:
        res <span class="op">+=</span> (loss_grad,)

    <span class="cf">return</span> res</code></pre></div>
<p>This function could also be implemented in a less “stateful” fashion, in which the terms are given as arguments to each function call–instead of shared variable.</p>
</section>
<section id="step-sizes" class="level2">
<h2>Step Sizes</h2>
<p>A critical aspect of the proximal gradient approach–and most optimization–involves the use of appropriate step sizes, <span class="math inline">\(\alpha\)</span>. They needn’t always be fixed values, and, because of this, we can search for a suitable value during estimation. Furthermore, in some cases, step sizes can be sequences amenable to acceleration techniques <span class="citation" data-cites="beck_fast_2014">(Beck and Teboulle 2014)</span>.</p>
<p>These values have obvious connections to the performance of an optimization method–beyond basic guarantees of convergence, so the power of any implementation will depend on how much support it has for various types of step size sequences.</p>
<p>Often acceptible ranges of step size values are derived from Lipschitz and related properties of the functions involved–and/or their gradients. Similar considerations underlie the classical line-search methods in optimization, and give meaning to what some call “tuning parameters”. These connections between function-analytic properties and “tuning parameters” themselves highlight the need for more mathematical coverage within implementations–by which we imply their place in a fully computational, symbolic setting.</p>
<p>In this spirit, one particularly relevant direction of work can be found in Theano’s experimental matrix “Hints”. The ideas behind <code>theano.sandbox.linalg.ops.{psd, spectral_radius_bound}</code> encompass some of the machinery needed to automatically determine applicable and efficient <span class="math inline">\(\alpha\)</span> constants and sequences.</p>
<p>In our example, we use the standard backtracking line-search.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> backtracking_search(beta_, alpha_,
                        prox_fn, loss_fn, loss_grad_fn,
                        lambda_<span class="op">=</span><span class="dv">1</span>, bt_rate<span class="op">=</span><span class="fl">0.5</span>, obj_tol<span class="op">=</span><span class="fl">1e-5</span>):
    <span class="co"># alpha_start = alpha_</span>
    z <span class="op">=</span> beta_
    beta_start_ <span class="op">=</span> beta_
    loss_start_ <span class="op">=</span> loss_fn(beta_)
    loss_grad_start_ <span class="op">=</span> loss_grad_fn(beta_)
    <span class="cf">while</span> <span class="va">True</span>:

        beta_ <span class="op">=</span> beta_start_ <span class="op">-</span> alpha_ <span class="op">*</span> loss_grad_start_
        z <span class="op">=</span> prox_fn(beta_, alpha_ <span class="op">*</span> lambda_)

        loss_z <span class="op">=</span> loss_fn(z)
        step_diff <span class="op">=</span> z <span class="op">-</span> beta_start_
        loss_diff <span class="op">=</span> loss_z <span class="op">-</span> loss_start_
        line_diff <span class="op">=</span> alpha_ <span class="op">*</span> (loss_diff <span class="op">-</span>
loss_grad_start_.T.dot(step_diff))
        line_diff <span class="op">-=</span> step_diff.T.dot(step_diff) <span class="op">/</span> <span class="dv">2</span>.

        <span class="cf">if</span> line_diff <span class="op">&lt;=</span> obj_tol:
            <span class="cf">return</span> z, alpha_, loss_z

        alpha_ <span class="op">*=</span> bt_rate
        <span class="cf">assert</span> alpha_ <span class="op">&gt;=</span> <span class="dv">0</span>, <span class="st">&#39;invalid step size: </span><span class="sc">{}</span><span class="st">&#39;</span>.<span class="bu">format</span>(alpha_)</code></pre></div>
<div class="remark" markdown="" env-number="2" title-name="">
<p>Routines like this that make use of the gradient and other quantities might also be good candidates for execution in Theano, if only because of the graph optimizations that are able to remedy obviously redundant computations.</p>
<p>In this vein, we could consider performing the line-search, and/or the entire optimization loop, within a Theano <code>scan</code> operation. We could also create <code>Op</code>s that represents gradient and line-search step. These might make graph construction much simpler, and be more suited for the current optimization framework.</p>
<p>Although <code>scan</code> and tighter Theano integration may not on average produce better results than our current use of its compiled functions, we still wish to emphasize the possibilities.</p>
<p>Likewise, an <code>Op</code> for the proximal operator might also be necessary for solving proximal operators automatically in closed-form (when possible) within a graph. This is based on the standard use of lookup tables combined with sets of algebraic relationships and identities used in symbolic algebra libraries for automatic differentiation and integration. The same can be done to extend the coverage of known closed-form solutions to proximal operators in an automated setting.</p>
</div>
</section>
</section>
<section id="examples" class="level1">
<h1>Examples</h1>
<p>First, we need to set up the basic functions, which–in this case–are constructed from the Theano graphs.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">lambda_tt <span class="op">=</span> tt.scalar(<span class="st">&#39;lambda&#39;</span>)
lambda_tt.tag.test_value <span class="op">=</span> <span class="dv">1</span>

prox_fn <span class="op">=</span> tt_function([beta_tt, lambda_tt],
                      tt_soft_threshold(beta_tt, lambda_tt))

prox_grad_step_fn, loss_grad <span class="op">=</span> prox_gradient_step(
    nlogl, beta_tt, tt_soft_threshold,
    return_loss_grad<span class="op">=</span><span class="va">True</span>)

loss_fn <span class="op">=</span> tt_function([beta_tt], nlogl)
loss_grad_fn <span class="op">=</span> tt_function([beta_tt], loss_grad)

cols_fns <span class="op">=</span> [
    (<span class="kw">lambda</span> i, b: i, <span class="vs">r&#39;$i$&#39;</span>),
    (<span class="kw">lambda</span> i, b: np.asscalar(loss_fn(b)),
        <span class="vs">r&#39;$l(\beta^{(i)})$&#39;</span>),
    (<span class="kw">lambda</span> i, b: np.linalg.norm(b <span class="op">-</span> beta_true, <span class="dv">2</span>),
        <span class="vs">r&#39;$\|\beta^{(i)} - \beta^*\|^2_2$&#39;</span>)
]</code></pre></div>
<p>For a baseline comparison–and sanity check–we’ll use the <code>cvxpy</code> library <span class="citation" data-cites="diamond_cvxpy:_2016">(Diamond and Boyd 2016)</span>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> cvxpy <span class="im">as</span> cvx

beta_var_cvx <span class="op">=</span> cvx.Variable(M, name<span class="op">=</span><span class="st">&#39;beta&#39;</span>)
lambda_cvx <span class="op">=</span> <span class="fl">1e-2</span> <span class="op">*</span> lambda_max <span class="op">*</span> N

cvx_obj <span class="op">=</span> cvx.Minimize(<span class="fl">0.5</span> <span class="op">*</span> cvx.sum_squares(y <span class="op">-</span> X <span class="op">*</span> beta_var_cvx)
                       <span class="op">+</span> lambda_cvx <span class="op">*</span> cvx.norm(beta_var_cvx, <span class="dv">1</span>) )
cvx_prob <span class="op">=</span> cvx.Problem(cvx_obj)

_ <span class="op">=</span> cvx_prob.solve(solver<span class="op">=</span>cvx.CVXOPT, verbose<span class="op">=</span><span class="va">True</span>)

beta_cvx <span class="op">=</span> np.asarray(beta_var_cvx.value).squeeze()
loss_cvx <span class="op">=</span> loss_fn(beta_cvx)
beta_cvx_err <span class="op">=</span> np.linalg.norm(beta_cvx <span class="op">-</span> beta_true, <span class="dv">2</span>)</code></pre></div>
<p>We now have the necessary pieces to perform an example estimation. We’ll start with an exceedingly large step size and let backtracking line-search find a good value.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> ProxGradient(<span class="bu">object</span>):

    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, y, X, beta_0,
                 prox_fn_, loss_fn_, loss_grad_fn_,
                 alpha_0):

        <span class="va">self</span>.y <span class="op">=</span> y
        <span class="va">self</span>.X <span class="op">=</span> X
        <span class="va">self</span>.alpha_val <span class="op">=</span> alpha_0
        <span class="va">self</span>.beta_0 <span class="op">=</span> beta_0
        <span class="va">self</span>.N, <span class="va">self</span>.M <span class="op">=</span> X.shape
        <span class="va">self</span>.prox_fn_ <span class="op">=</span> prox_fn_
        <span class="va">self</span>.loss_fn_ <span class="op">=</span> loss_fn_
        <span class="va">self</span>.loss_grad_fn_ <span class="op">=</span> loss_grad_fn_

    <span class="kw">def</span> step(<span class="va">self</span>, beta):
        beta_val <span class="op">=</span> np.copy(beta)

        beta_val, <span class="va">self</span>.alpha_val, _ <span class="op">=</span> backtracking_search(
            beta_val, <span class="va">self</span>.alpha_val,
            <span class="va">self</span>.prox_fn_, <span class="va">self</span>.loss_fn_, <span class="va">self</span>.loss_grad_fn_)

        <span class="cf">return</span> beta_val</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">beta_0 <span class="op">=</span> np.zeros(M).astype(<span class="st">&#39;float64&#39;</span>)
lambda_val <span class="op">=</span> <span class="fl">1e-2</span> <span class="op">*</span> lambda_max
pg_step <span class="op">=</span> ProxGradient(y, X, beta_0,
                       <span class="kw">lambda</span> x, a: prox_fn(x, N <span class="op">*</span> lambda_val <span class="op">*</span> a),
                       loss_fn, loss_grad_fn, <span class="dv">10</span>)

pg_cols_fns <span class="op">=</span> cols_fns <span class="op">+</span> [(<span class="kw">lambda</span> <span class="op">*</span>args, <span class="op">**</span>kwargs: pg_step.alpha_val,
<span class="vs">r&#39;$\alpha$&#39;</span>)]
pg_est_data, _ <span class="op">=</span> iterative_run(pg_step, loss_fn, pg_cols_fns)
pg_ls_data <span class="op">=</span> pd.DataFrame(pg_est_data)
<span class="co"># pg_ls_data = pg_ls_data.append(pg_est_data, ignore_index=True)</span></code></pre></div>
<p><span id="fig:pg_ls_plot"><span id="fig:pg_ls_plot_span" style="display:none;visibility:hidden"><span class="math display">\[\begin{equation}\tag{1}\label{fig:pg_ls_plot}\end{equation}\]</span></span><img src="https://brandonwillard.github.io/figures/more_proximal_estimation_pg_ls_plot_1.png" title="fig:" alt="Minimization by proximal gradient with backtracking line-search." /></span></p>
<p>Figure <span class="math inline">\(\ref{fig:pg_ls_plot}\)</span> shows a couple convergence measures for proximal gradient steps alongside the step size changes due to backtracking line-search. Regarding the latter, in our example a sufficient step size is found within the first few iterations, so the overall result isn’t too interesting. Fortunately, this sort of behaviour isn’t uncommon, which makes line-search quite effective in practice.</p>
</section>
<section id="coordinate-wise-estimation" class="level1">
<h1>Coordinate-wise Estimation</h1>
<p>Given that our loss is a composition of <span class="math inline">\(\ell_2\)</span> and a linear operator of finite dimension, we can conveniently exploit some conditional separability to obtain simple estimation steps in each coordinate. This effectively characterizes coordinate–or cyclic–descent in our case, and it shows up as a common technique in the estimation of <span class="math inline">\(\ell_1\)</span> models <span class="citation" data-cites="friedman_pathwise_2007 mazumder_regularization_2009 scikit-learn_sklearn.linear_model.elasticnet_2017">(Friedman et al. 2007; Mazumder, Hastie, and Tibshirani 2009; scikit-learn 2017)</span>.</p>
<p>From a more statistical perspective, the basics of coordinate-wise methods begin with the “partial residuals”, <span class="math inline">\(r_{-m} \in {{\mathbb{R}}}^{N}\)</span>, discussed in <span class="citation" data-cites="friedman_pathwise_2007">Friedman et al. (2007)</span> and implicitly defined for our problem by <span class="math display">\[\begin{equation}
\begin{aligned}
    \beta^*
    &amp;= \operatorname*{argmin}_{\beta} \left\{
      \frac12
      \|
    y - X(\beta - e_m \beta_m)
        - X e_m \cdot \beta_{m}\|^2_2
      + \lambda \left|\beta_m\right|
      + \lambda \sum_{m^\prime \neq m} \left|\beta_{m^\prime}\right|
      \right\}
    \\
    &amp;= \operatorname*{argmin}_{\beta} \left\{
      \frac12
      \|r_{-m} - X e_m \cdot \beta_{m}\|^2_2
      + \lambda \sum_{m^\prime \neq m} \left|\beta_{m^\prime}\right|
    \right\}
  \;.
  \end{aligned}
  \label{eq:partial_resid}
\end{equation}\]</span> The last expression hints at the most basic idea behind the coordinate-wise approach: conditional minimization in each <span class="math inline">\(m\)</span>. Its exact solution in each coordinate is given by the aforementioned soft thresholding function, which–as we’ve already stated–is a proximal operator. In symbols, <span class="math inline">\(\operatorname*{prox}_{\lambda \left|\cdot\right|}(x) = \operatorname{S}_\lambda(x)\)</span>, where the latter is the soft thresholding operator.</p>
<p>Now, if we wanted to relate this type of coordinate descent to the much more general statement of the proximal gradient solution in Equation <span class="math inline">\(\eqref{eq:forward-backward}\)</span>, we would use a result like the following:</p>
<div id="eq:prox_grad_descent" class="proposition" markdown="" env-number="1" title-name="">
<p><span id="eq:prox_grad_descent_span" style="display:none;visibility:hidden"><span class="math display">\[\begin{equation}\tag{1}\label{eq:prox_grad_descent}\end{equation}\]</span></span></p>
<p>For <span class="math inline">\(X\)</span> such that <span class="math inline">\({{\bf 1}}^\top X e_m = 0\)</span> and <span class="math inline">\(e^\top_m X^\top X e_m = 1\)</span>, <span class="math inline">\(m \in \{1, \dots, M\}\)</span>, the coordinate-wise step of the Lasso in <span class="citation" data-cites="friedman_pathwise_2007">Friedman et al. (2007 Equation (9))</span>, <span class="math display">\[\begin{equation*}
\beta_m = \operatorname{S}_{\lambda}\left[
      \sum_{n}^N X_{n,m} \left(
      y_n - \sum^M_{m^\prime \neq m} X_{n,m^\prime} \beta_{m^\prime}
      \right)
    \right]
    \;,
\end{equation*}\]</span> has a proximal gradient fixed-point solution under a Euclidean basis decomposition with the form <span class="math display">\[\begin{equation*}
\beta =
    \sum^M_m \operatorname*{prox}_{\alpha \lambda \phi}\left[
      e^\top_m \left(\beta - \alpha \nabla l(\beta)\right)
    \right] e_m
    \;.
\end{equation*}\]</span></p>
<p>We start with an expansion of the terms in <span class="math inline">\(\operatorname*{prox}_{\lambda \phi} \equiv \operatorname{S}_\lambda\)</span>. After simplifying the notation with <span class="math display">\[\begin{equation*}
\begin{gathered}
    \sum^N_{n} X_{n,m} z_n = e^\top_m X^\top z, \quad \text{and} \quad
    \sum^M_{m^\prime \neq m} X_{n,m^\prime} \beta_{m^\prime} =
    X \left(\beta - \beta_m e_m \right)
    \;,
  \end{gathered}
\end{equation*}\]</span> the expanded argument of <span class="math inline">\(\operatorname{S}\)</span> reduces to <span class="math display">\[\begin{equation*}
\begin{aligned}
      e^\top_m X^\top \left(y - X\left( \beta - e_m \beta_m\right)\right)
      &amp;= e^\top_m X^\top X e_m \beta_m + e^\top_m X^\top \left(y - X \beta\right)
      \\
      &amp;= \beta_m + e^\top_m X^\top \left(y - X \beta\right)
      \\
      &amp;= e^\top_m \left(\beta + X^\top \left(y - X \beta\right)\right)
    \end{aligned}
\end{equation*}\]</span> where the last step follows from <span class="math inline">\(X\)</span> standardization. This establishes the relationship with only component-wise. The connection to full vector <span class="math inline">\(\beta\)</span> iterations in comes from the following orthogonal basis property of proximal operators: <span class="math display">\[\begin{equation}
\operatorname*{prox}_{\lambda \phi \circ e^\top_m}(z) =
    \sum^M_m \operatorname*{prox}_{\lambda \phi}\left(e^\top_m z\right) e_m
    \;.
    \label{eq:prox_ortho_basis}
\end{equation}\]</span> This together with <span class="math inline">\(z = \beta - \alpha \nabla l(\beta)\)</span> yields the proximal gradient fixed-point statement, i.e. <span class="math display">\[\begin{equation*}
\begin{aligned}
      \beta
      &amp;=
      \sum^M_m \operatorname*{prox}_{\alpha \lambda \phi}\left[
    e^\top_m \left(\beta - \alpha \nabla l(\beta)\right)
      \right] e_m
      \\
      &amp;=
      \sum^M_m \operatorname*{prox}_{\alpha \lambda \phi}\left(
      \beta_m + \alpha e_m^\top X^\top \left(y - X \beta \right)
      \right) e_m
      \;.
    \end{aligned}
\end{equation*}\]</span></p>
</div>
<div id="rem:bases" class="remark" markdown="" env-number="3" title-name="">
<p><span id="rem:bases_span" style="display:none;visibility:hidden"><span class="math display">\[\begin{equation}\tag{3}\label{rem:bases}\end{equation}\]</span></span></p>
<p>The property in can be extended to any other orthonormal bases and provide quite a robust means of deriving methods for certain classes of problems <span class="citation" data-cites="chaux_variational_2007">(Chaux et al. 2007)</span>. More specifically, this property is really a nice way to use <span class="math inline">\(X\)</span>-based orthogonalizations of a regression problem and implement different forms of sparsity on <span class="math inline">\(\beta\)</span> estimates.</p>
</div>
<section id="implementation-1" class="level2">
<h2>Implementation</h2>
<p>The following performs a standard form of coordinate descent:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> CoordDescent(<span class="bu">object</span>):

    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, y, X, beta_0, prox_fn_, col_seq<span class="op">=</span><span class="va">None</span>):

        <span class="va">self</span>.y <span class="op">=</span> y
        <span class="va">self</span>.X <span class="op">=</span> X
        <span class="va">self</span>.beta_0 <span class="op">=</span> beta_0
        <span class="va">self</span>.N, <span class="va">self</span>.M <span class="op">=</span> X.shape
        <span class="va">self</span>.Xb <span class="op">=</span> np.dot(<span class="va">self</span>.X, <span class="va">self</span>.beta_0)
        <span class="va">self</span>.prox_fn_ <span class="op">=</span> prox_fn_

        <span class="co"># (Inverse) 2-norm of each column/feature, i.e.</span>
        <span class="co">#   np.reciprocal(np.diag(np.dot(X.T, X)))</span>
        <span class="va">self</span>.alpha_vals <span class="op">=</span> np.reciprocal((<span class="va">self</span>.X<span class="op">**</span><span class="dv">2</span>).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>))

        <span class="cf">if</span> col_seq <span class="kw">is</span> <span class="va">None</span>:
            <span class="va">self</span>.col_seq <span class="op">=</span> np.arange(<span class="va">self</span>.M)

    <span class="kw">def</span> reset(<span class="va">self</span>):
        <span class="va">self</span>.Xb <span class="op">=</span> np.dot(<span class="va">self</span>.X, <span class="va">self</span>.beta_0)

    <span class="kw">def</span> step(<span class="va">self</span>, beta):
        beta_val <span class="op">=</span> np.copy(beta)

        <span class="cf">for</span> j <span class="kw">in</span> <span class="va">self</span>.col_seq:
            X_j <span class="op">=</span> <span class="va">self</span>.X[:, j]
            alpha_val <span class="op">=</span> <span class="va">self</span>.alpha_vals[j]

            <span class="co"># A little cheaper to just subtract the column&#39;s</span>
contribution...
            <span class="va">self</span>.Xb <span class="op">-=</span> X_j <span class="op">*</span> beta_val[j]

            Xt_r <span class="op">=</span> np.dot(X_j.T, <span class="va">self</span>.y <span class="op">-</span> <span class="va">self</span>.Xb) <span class="op">*</span> alpha_val
            beta_val[j] <span class="op">=</span> <span class="va">self</span>.prox_fn_(np.atleast_1d(Xt_r),
alpha_val)

            <span class="co"># ...and add the updated column back.</span>
            <span class="va">self</span>.Xb <span class="op">+=</span> X_j <span class="op">*</span> beta_val[j]

        <span class="va">self</span>.beta_last <span class="op">=</span> beta_val

        <span class="cf">return</span> beta_val</code></pre></div>
<p>Our example run randomizes the order of coordinates to demonstrate some of the variation introduced by this approach.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">beta_0 <span class="op">=</span> np.zeros(M).astype(<span class="st">&#39;float64&#39;</span>)
lambda_val <span class="op">=</span> <span class="fl">1e-2</span> <span class="op">*</span> lambda_max
cd_step <span class="op">=</span> CoordDescent(y, X, beta_0,
                       <span class="kw">lambda</span> x, a: prox_fn(x, N <span class="op">*</span> lambda_val <span class="op">*</span> a))

cd_cols_fns <span class="op">=</span> cols_fns <span class="op">+</span> [(<span class="kw">lambda</span> <span class="op">*</span>args, <span class="op">**</span>kwargs: j, <span class="st">&quot;replication&quot;</span>)]

pg_coord_data <span class="op">=</span> pd.DataFrame()
<span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">15</span>):
    est_data, _ <span class="op">=</span> iterative_run(cd_step, loss_fn, cd_cols_fns)
    pg_coord_data <span class="op">=</span> pg_coord_data.append(est_data,
                                         ignore_index<span class="op">=</span><span class="va">True</span>)
    <span class="co"># Reset internal state of our step method, since we&#39;re</span>
    <span class="co"># running multiple replications.</span>
    cd_step.reset()
    np.random.shuffle(cd_step.col_seq)</code></pre></div>
<p><span id="fig:pg_coord_plot"><span id="fig:pg_coord_plot_span" style="display:none;visibility:hidden"><span class="math display">\[\begin{equation}\tag{2}\label{fig:pg_coord_plot}\end{equation}\]</span></span><img src="https://brandonwillard.github.io/figures/more_proximal_estimation_pg_coord_plot_1.png" title="fig:" alt="Minimization by coordinate descent." /></span></p>
<p>Figure <span class="math inline">\(\ref{fig:pg_coord_plot}\)</span> shows the distance measures for each randomized coordinate order. The number of [average] iterations between coordinate descent and “batch” proximal gradient is fairly noticeable in this example, yet both reach effectively the same limits in parameter distance and minimum objective value as <code>cvx</code>.</p>
<div class="remark" markdown="" env-number="4" title-name="">
<p>The same ideas behind batched vs. non-batched steps and block sampling found within the Gibbs sampling literature <span class="citation" data-cites="roberts_updating_1997">(Roberts and Sahu 1997)</span> likely explain variation due to coordinate order and the relative efficiency of coordinate descent. There also appear to be some connections with our comments in and, to some extent, stochastic gradient descent (SGD) <span class="citation" data-cites="bertsekas_incremental_2010">(Bertsekas 2010)</span>, as well.</p>
<p>Simply put, in these situations, the [spectral] properties of <span class="math inline">\(l\)</span>/<span class="math inline">\(\nabla l\)</span> and <span class="math inline">\(X\)</span> fundamentally determine the extent to which steps sizes can be increased or accelerated, and the bases, frames, or partitions introduced by coordinate descent, blocking and SGD further act upon those properties</p>
</div>
<section id="regularization-paths" class="level3">
<h3>Regularization Paths</h3>
<p>Also, due to the relatively fast convergence of coordinate descent, the method is a little more suitable for the computation of regularization paths– i.e. varying <span class="math inline">\(\lambda\)</span> between iterations. There is much more to this topic, but for simplicity let’s just note that each <span class="math inline">\(\lambda\)</span> step has a “warm-start” from the previous descent iteration–which helps–and that we’re otherwise fine with the solution provided by this approach.</p>
<p>Next, we make a small extension to demonstrate the computation of regularization paths–using <code>lasso_path</code> for comparison.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> sklearn.linear_model <span class="im">import</span> lasso_path, enet_path

beta_0 <span class="op">=</span> np.zeros(M).astype(<span class="st">&#39;float64&#39;</span>)

lambda_path, beta_path, _ <span class="op">=</span> lasso_path(X, y)
path_len <span class="op">=</span> np.alen(lambda_path)

beta_last <span class="op">=</span> beta_0
pg_path_data <span class="op">=</span> pd.DataFrame()
<span class="cf">for</span> i, lambda_ <span class="kw">in</span> <span class="bu">enumerate</span>(lambda_path):
    cd_path_step <span class="op">=</span> CoordDescent(y, X, beta_last,
                        <span class="kw">lambda</span> x, a: prox_fn(x, N <span class="op">*</span> lambda_ <span class="op">*</span> a))

    cd_cols_fns <span class="op">=</span> cols_fns[<span class="dv">1</span>:] <span class="op">+</span> [
        (<span class="kw">lambda</span> <span class="op">*</span>args, <span class="op">**</span>kwargs: lambda_, <span class="vs">r&#39;$\lambda$&#39;</span>)]
    est_data, beta_last <span class="op">=</span> iterative_run(cd_path_step, loss_fn,
                                        cd_cols_fns,
                                        stop_tol<span class="op">=</span><span class="fl">1e-4</span>,
                                        stop_loss<span class="op">=</span><span class="va">True</span>)

    pg_path_data <span class="op">=</span> pg_path_data.append(est_data.iloc[<span class="op">-</span><span class="dv">1</span>, :],
                                       ignore_index<span class="op">=</span><span class="va">True</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">cd_cols_fns <span class="op">=</span> cols_fns[<span class="dv">1</span>:] <span class="op">+</span> [
    (<span class="kw">lambda</span> <span class="op">*</span>args, <span class="op">**</span>kwargs: lambda_path[args[<span class="dv">0</span>]], <span class="vs">r&#39;$\lambda$&#39;</span>)]

iter_values <span class="op">=</span> []
<span class="cf">for</span> i, beta_ <span class="kw">in</span> <span class="bu">enumerate</span>(beta_path.T):
    iter_values.append([col_fn(i, beta_)
                        <span class="cf">for</span> col_fn, _ <span class="kw">in</span> cd_cols_fns])

sklearn_path_data <span class="op">=</span> pd.DataFrame(iter_values,
                                 columns<span class="op">=</span><span class="bu">zip</span>(<span class="op">*</span>cd_cols_fns)[<span class="dv">1</span>])
sklearn_path_data <span class="op">=</span> sklearn_path_data.assign(
    replication<span class="op">=</span><span class="va">None</span>, <span class="bu">type</span><span class="op">=</span><span class="st">&#39;sklearn&#39;</span>)

pg_path_data <span class="op">=</span> pg_path_data.assign(<span class="bu">type</span><span class="op">=</span><span class="st">&#39;pg&#39;</span>)
pg_path_data <span class="op">=</span> pg_path_data.append(sklearn_path_data,
                                   ignore_index<span class="op">=</span><span class="va">True</span>)</code></pre></div>
<p><span id="fig:pg_path_plot"><span id="fig:pg_path_plot_span" style="display:none;visibility:hidden"><span class="math display">\[\begin{equation}\tag{3}\label{fig:pg_path_plot}\end{equation}\]</span></span><img src="https://brandonwillard.github.io/figures/more_proximal_estimation_pg_path_plot_1.png" title="fig:" alt="Regularization paths via coordinate descent." /></span></p>
</section>
</section>
</section>
<section id="discussion" class="level1">
<h1>Discussion</h1>
<p>Maybe small steps in this direction could even motivate much larger changes in our standard tools–like full support for sub-differentials and set-valued results, instead of the overly restrictive point-wise characterizations currently ubiquitous. A similar idea is present in the symbolic calculation of limits addressed using filters <span class="citation" data-cites="beeson_meaning_2005">(Beeson and Wiedijk 2005)</span>, and is somewhat analogous to the more modern jump from matrix and linear algebra libraries to tensor libraries. Our use of the proximal framework is, in part, motivated by its near seamless use <em>and</em> simultaneous bypassing of set-valued maps–in implementation, at least. In a sense, frameworks like these could be minor abstractions to libraries with set-valued support.</p>
<p>The value provided by the symbolic tools we’ve discussed are not <em>just</em> their ability to act as compilers at a “math level”, but more for their ability to concretely encode mathematical characterizations of optimization problems and methods. Work in this direction is not new by any means; however, the combination of open-source tools and industry interest in algorithms that fall under the broad class of proximal methods (e.g. gradient descent, ADMM, EM, etc.) provides a more immediate reason to pursue these abstractions in code and automate their use.</p>
<p><span class="citation" data-cites="wytock_new_2016">(Wytock et al. 2016)</span> discusses a similar approach to optimization (i.e. symbolic and with close coupling to useful mathematical abstractions), and there are other good examples <span class="citation" data-cites="diamond_cvxpy:_2016">(Diamond and Boyd 2016)</span> of effective mathematical abstractions applied in code. In most cases, these examples do not–however–attempt to place their implementations upon a symbolic foundation and then realize their relevant methodologies in that context. Most often, the mathematical abstractions–or just the methods–are directly implemented at the highest levels of abstraction possible (e.g. individual functions for ADMM, forward-backward/proximal gradient and Douglas-Rachford <span class="citation" data-cites="svaiter_pyprox_2017">(svaiter 2017)</span>). This is most common and it makes sense in terms of simplicity, but offers none of the extensibility, generalization, or possibly efficiency provided by shared efforts across related projects. For example, in the context described here, implementations immediately benefit from Theano’s code conversion, parallelization and relevant improvements to its basic graph optimizations. The latter covers both low-level implementation improvements–including automatic use of relevant BLAS functions–as well as high-level tensor algebra simplifications. In a development community that builds from such tools, related efficiency and performance gains could occur much more often and be much more specific to certain areas of mathematics.</p>
<p>The utility of these encodings may manifest as–say–Theano optimizations that make direct use of the orthonormal basis property in Equation <span class="math inline">\(\eqref{eq:prox_ortho_basis}\)</span>, or the Moreau-Fenchel theorem, and automate consideration for multiple estimation methods via splitting (e.g. ADMM, Douglas-Rachford, etc.)–perhaps by making decisions based on operator/matrix properties one could reasonably specific in this context. In future installments we’ll attempt to delve into the details of these features.</p>
</section>
<section id="bibliography" class="level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-beck_fast_2014">
<p>Beck, Amir, and Marc Teboulle. 2014. “A Fast Dual Proximal Gradient Algorithm for Convex Minimization and Applications.” <em>Operations Research Letters</em> 42 (1): 1–6. <a href="http://www.sciencedirect.com/science/article/pii/S0167637713001454" class="uri">http://www.sciencedirect.com/science/article/pii/S0167637713001454</a>.</p>
</div>
<div id="ref-beeson_meaning_2005">
<p>Beeson, Michael, and Freek Wiedijk. 2005. “The Meaning of Infinity in Calculus and Computer Algebra Systems.” <em>Journal of Symbolic Computation</em>, Automated reasoning and computer algebra systems (ar-ca)AR-ca, 39 (5): 523–38. doi:<a href="https://doi.org/10.1016/j.jsc.2004.12.002">10.1016/j.jsc.2004.12.002</a>.</p>
</div>
<div id="ref-bergstra_theano_2010">
<p>Bergstra, James, Olivier Breuleux, Frédéric Bastien, Pascal Lamblin, Razvan Pascanu, Guillaume Desjardins, Joseph Turian, David Warde-Farley, and Yoshua Bengio. 2010. “Theano: A CPU and GPU Math Expression Compiler.” In <em>Proceedings of the Python for Scientific Computing Conference (SciPy)</em>. Austin, TX.</p>
</div>
<div id="ref-bertsekas_incremental_2010">
<p>Bertsekas, Dimitri P. 2010. “Incremental Gradient, Subgradient, and Proximal Methods for Convex Optimization: A Survey.” <a href="http://web.mit.edu/dimitrib/www/Incremental_Survey_LIDS.pdf" class="uri">http://web.mit.edu/dimitrib/www/Incremental_Survey_LIDS.pdf</a>.</p>
</div>
<div id="ref-chaux_variational_2007">
<p>Chaux, Caroline, Patrick L Combettes, Jean-Christophe Pesquet, and Valérie R Wajs. 2007. “A Variational Formulation for Frame-Based Inverse Problems.” <em>Inverse Problems</em> 23 (4): 1495.</p>
</div>
<div id="ref-combettes_proximal_2011">
<p>Combettes, Patrick L, and Jean-Christophe Pesquet. 2011. “Proximal Splitting Methods in Signal Processing.” <em>Fixed-Point Algorithms for Inverse Problems in Science and Engineering</em>, 185–212.</p>
</div>
<div id="ref-diamond_cvxpy:_2016">
<p>Diamond, Steven, and Stephen Boyd. 2016. “CVXPY: A Python-Embedded Modeling Language for Convex Optimization.” <em>Journal of Machine Learning Research</em> 17 (83): 1–5.</p>
</div>
<div id="ref-friedman_pathwise_2007">
<p>Friedman, Jerome, Trevor Hastie, Holger Höfling, Robert Tibshirani, and others. 2007. “Pathwise Coordinate Optimization.” <em>The Annals of Applied Statistics</em> 1 (2): 302–32. <a href="http://projecteuclid.org/euclid.aoas/1196438020" class="uri">http://projecteuclid.org/euclid.aoas/1196438020</a>.</p>
</div>
<div id="ref-mazumder_regularization_2009">
<p>Mazumder, Rahul, Trevor Hastie, and Rob Tibshirani. 2009. “Regularization Methods for Learning Incomplete Matrices.” <em>arXiv Preprint arXiv:0906.2034</em>. <a href="https://arxiv.org/abs/0906.2034" class="uri">https://arxiv.org/abs/0906.2034</a>.</p>
</div>
<div id="ref-parikh_proximal_2014">
<p>Parikh, Neal, and Stephen Boyd. 2014. “Proximal Algorithms.” <em>Foundations and Trends in Optimization</em> 1 (3): 123–231. doi:<a href="https://doi.org/10.1561/2400000003">10.1561/2400000003</a>.</p>
</div>
<div id="ref-polson_proximal_2015">
<p>Polson, Nicholas G., James G. Scott, and Brandon T. Willard. 2015. “Proximal Algorithms in Statistics and Machine Learning.” <em>Statistical Science</em> 30 (4): 559–81. doi:<a href="https://doi.org/10.1214/15-STS530">10.1214/15-STS530</a>.</p>
</div>
<div id="ref-roberts_updating_1997">
<p>Roberts, Gareth O., and Sujit K. Sahu. 1997. “Updating Schemes, Correlation Structure, Blocking and Parameterization for the Gibbs Sampler.” <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em> 59 (2): 291–317. <a href="http://onlinelibrary.wiley.com/doi/10.1111/1467-9868.00070/abstract" class="uri">http://onlinelibrary.wiley.com/doi/10.1111/1467-9868.00070/abstract</a>.</p>
</div>
<div id="ref-salvatier_probabilistic_2016">
<p>Salvatier, John, Thomas V. Wiecki, and Christopher Fonnesbeck. 2016. “Probabilistic Programming in Python Using PyMC3.” <em>PeerJ Computer Science</em> 2 (April): e55. doi:<a href="https://doi.org/10.7717/peerj-cs.55">10.7717/peerj-cs.55</a>.</p>
</div>
<div id="ref-scikit-learn_sklearn.linear_model.elasticnet_2017">
<p>scikit-learn. 2017. “Sklearn.Linear_model.ElasticNet Scikit-Learn 0.19.Dev0 Documentation.” <a href="http://scikit-learn.org/dev/modules/generated/sklearn.linear_model.ElasticNet.html\#sklearn-linear-model-elasticnet" class="uri">http://scikit-learn.org/dev/modules/generated/sklearn.linear_model.ElasticNet.html\#sklearn-linear-model-elasticnet</a>.</p>
</div>
<div id="ref-svaiter_pyprox_2017">
<p>svaiter. 2017. “Pyprox.” <a href="https://github.com/svaiter/pyprox" class="uri">https://github.com/svaiter/pyprox</a>.</p>
</div>
<div id="ref-willard_role_2017">
<p>Willard, Brandon T. 2017. “A Role for Symbolic Computation in the General Estimation of Statistical Models.” <a href="https://brandonwillard.github.io/a-role-for-symbolic-computation-in-the-general-estimation-of-statistical-models.html" class="uri">https://brandonwillard.github.io/a-role-for-symbolic-computation-in-the-general-estimation-of-statistical-models.html</a>.</p>
</div>
<div id="ref-wytock_new_2016">
<p>Wytock, Matt, Steven Diamond, Felix Heide, and Stephen Boyd. 2016. “A New Architecture for Optimization Modeling Frameworks.” <em>arXiv Preprint arXiv:1609.03488</em>. <a href="https://arxiv.org/abs/1609.03488" class="uri">https://arxiv.org/abs/1609.03488</a>.</p>
</div>
</div>
</section>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  CommonHTML: { linebreaks: { automatic: true } },
  "HTML-CSS": { linebreaks: { automatic: true } },
  SVG: { linebreaks: { automatic: true } },
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
</body>
</html>

            </div>
            <!-- /.entry-content -->
    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'brandonwillard-github-io'; // required: replace example with your forum shortname

                    var disqus_identifier = 'more-proximal-estimation';
                var disqus_url = 'https://brandonwillard.github.io/more-proximal-estimation.html';

            var disqus_config = function () {
                this.language = "en";
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
        </article>
    </section>

        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>
<div id="aboutme">
        <p>
            <img width="100%" class="img-thumbnail" src="/images/profile-pic.png"/>
        </p>
    <p>
        <strong>About Brandon T. Willard</strong><br/>
        applied math/stats person
    </p>
</div>
<section class="well well-sm">
    <ul class="list-group list-group-flush">
            <li class="list-group-item"><h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Social</span></h4>
              <ul class="list-group" id="social">
                <li class="list-group-item"><a href="http://linkedin.com/pub/brandon-willard/10/bb4/468/"><i class="fa fa-linkedin-square fa-lg"></i> linkedin</a></li>
                <li class="list-group-item"><a href="https://scholar.google.com/citations?user=g0oUxG4AAAAJ&hl=en"><i class="ai ai-google-scholar-square ai-lg"></i> google scholar</a></li>
                <li class="list-group-item"><a href="https://plus.google.com/+brandonwillard"><i class="fa fa-google-plus-square fa-lg"></i> google+</a></li>
                <li class="list-group-item"><a href="https://bitbucket.org/brandonwillard"><i class="fa fa-bitbucket-square fa-lg"></i> bitbucket</a></li>
                <li class="list-group-item"><a href="https://github.com/brandonwillard"><i class="fa fa-github-square fa-lg"></i> github</a></li>
              </ul>
            </li>



            <li class="list-group-item"><a href="https://brandonwillard.github.io/"><h4><i class="fa fa-tags fa-lg"></i><span class="icon-label">Tags</span></h4></a>
                <ul class="list-group " id="tags">
                </ul>
            </li>
    </ul>
</section>
            </aside>
        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2017 Brandon T. Willard
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>              <p><small>  <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-nc/4.0/80x15.png" /></a>
    Content
  licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="https://brandonwillard.github.io/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://brandonwillard.github.io/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="https://brandonwillard.github.io/theme/js/respond.min.js"></script>

    <!-- Disqus -->
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'brandonwillard-github-io'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script');
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <!-- End Disqus Code -->
    <!-- Google Analytics Universal -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-91585967-1', '');
        ga('send', 'pageview');
    </script>
    <!-- End Google Analytics Universal Code -->

</body>
</html>