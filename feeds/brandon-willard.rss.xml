<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Brandon T. Willard</title><link>https://brandonwillard.github.io/</link><description></description><lastBuildDate>Thu, 27 Oct 2016 00:00:00 -0500</lastBuildDate><item><title>SymPy Expression Tree Manipulation</title><link>https://brandonwillard.github.io/sympy-expression-tree-manipulation.html</link><description>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
  &lt;meta http-equiv="Content-Style-Type" content="text/css" /&gt;
  &lt;meta name="generator" content="pandoc" /&gt;
  &lt;meta name="author" content="Brandon Willard" /&gt;
  &lt;title&gt;SymPy Expression Tree Manipulation&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #ffffff; color: #1f1c1b; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; background-color: #ffffff; color: #a0a0a0; border-right: 1px solid #a0a0a0; }
td.sourceCode { padding-left: 5px; }
pre, code { color: #1f1c1b; background-color: #ffffff; }
code &gt; span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
code &gt; span.dt { color: #0057ae; } /* DataType */
code &gt; span.dv { color: #b08000; } /* DecVal */
code &gt; span.bn { color: #b08000; } /* BaseN */
code &gt; span.fl { color: #b08000; } /* Float */
code &gt; span.cn { color: #aa5500; } /* Constant */
code &gt; span.ch { color: #924c9d; } /* Char */
code &gt; span.sc { color: #3daee9; } /* SpecialChar */
code &gt; span.st { color: #bf0303; } /* String */
code &gt; span.vs { color: #bf0303; } /* VerbatimString */
code &gt; span.ss { color: #ff5500; } /* SpecialString */
code &gt; span.im { color: #ff5500; } /* Import */
code &gt; span.co { color: #898887; } /* Comment */
code &gt; span.do { color: #607880; } /* Documentation */
code &gt; span.an { color: #ca60ca; } /* Annotation */
code &gt; span.cv { color: #0095ff; } /* CommentVar */
code &gt; span.ot { color: #006e28; } /* Other */
code &gt; span.fu { color: #644a9b; } /* Function */
code &gt; span.va { color: #0057ae; } /* Variable */
code &gt; span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
code &gt; span.op { color: #1f1c1b; } /* Operator */
code &gt; span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
code &gt; span.ex { color: #0095ff; font-weight: bold; } /* Extension */
code &gt; span.pp { color: #006e28; } /* Preprocessor */
code &gt; span.at { color: #0057ae; } /* Attribute */
code &gt; span.re { color: #0057ae; } /* RegionMarker */
code &gt; span.in { color: #b08000; } /* Information */
code &gt; span.wa { color: #bf0303; } /* Warning */
code &gt; span.al { color: #bf0303; font-weight: bold; } /* Alert */
code &gt; span.er { color: #bf0303; text-decoration: underline; } /* Error */
code &gt; span. { color: #1f1c1b; } /* Normal */
  &lt;/style&gt;
  &lt;script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--  --&gt;
&lt;!-- &lt;div id="header"&gt; --&gt;
&lt;!-- &lt;h1 class="title"&gt;SymPy Expression Tree Manipulation&lt;/h1&gt; --&gt;
&lt;!--  --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;h2 class="author"&gt;Brandon Willard&lt;/h2&gt; --&gt;
&lt;!--  --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;h3 class="date"&gt;2016–10–27&lt;/h3&gt; --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;/div&gt; --&gt;
&lt;!--  --&gt;
&lt;p&gt;I’ve been working on some extensions to our special function computations in &lt;a href="https://arxiv.org/abs/1605.04796"&gt;Prediction risk for global-local shrinkage regression&lt;/a&gt; and decided to employ &lt;a href="https://github.com/sympy/sympy"&gt;SymPy&lt;/a&gt; as much as possible. Out of this came an &lt;a href="https://bitbucket.org/bayes-horseshoe-plus/hsplus-python-pkg/src/master/hsplus/horn_symbolic.py"&gt;implementation&lt;/a&gt; of a bivariate confluent hypergeometric function: the &lt;a href="https://en.wikipedia.org/wiki/Humbert_series"&gt;Humbert&lt;/a&gt; &lt;span class="math inline"&gt;\(\Phi_1\)&lt;/span&gt;. This, and some numeric implementations, are available in a &lt;a href="https://bitbucket.org/bayes-horseshoe-plus/hsplus-python-pkg"&gt;Python package&lt;/a&gt; and an &lt;a href="https://bitbucket.org/bayes-horseshoe-plus/hsplus-r-pkg"&gt;R package&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the course of this work there are expectations that appear as ratios of &lt;span class="math inline"&gt;\(\Phi_1\)&lt;/span&gt; functions, so it’s helpful to have a symbolic replacement routine to identify them. &lt;a href="http://docs.sympy.org/dev/modules/core.html#sympy.core.basic.Basic.match"&gt;Pattern matching&lt;/a&gt;, &lt;a href="http://docs.sympy.org/dev/modules/core.html#sympy.core.basic.Basic.find"&gt;finding&lt;/a&gt;, substitution and &lt;a href="http://docs.sympy.org/dev/modules/core.html#sympy.core.basic.Basic.replace"&gt;replacement&lt;/a&gt; are fairly standard in SymPy, so nothing special there; however, when you want something specific, it can get rather tricky.&lt;/p&gt;
&lt;p&gt;Personally, I’ve found the approach offered by the &lt;a href="https://github.com/sympy/sympy/tree/master/sympy/strategies"&gt;&lt;code&gt;sympy.strategies&lt;/code&gt;&lt;/a&gt; and &lt;a href="https://github.com/sympy/sympy/tree/master/sympy/unify"&gt;&lt;code&gt;sympy.unify&lt;/code&gt;&lt;/a&gt; frameworks the most appealing. See the original discussion &lt;a href="https://groups.google.com/d/msg/sympy/fspCavhbd9I/vrzUitvgiuYJ"&gt;here&lt;/a&gt;. The reason for their appeal is mostly due to their organization of the processes behind expression tree traversal and manipulation. It’s much easier to see how a very specific and non-trivial simplification or replacement could be accomplished and iteratively improved. These points are made very well in the posts &lt;a href="http://matthewrocklin.com/blog/tags.html#SymPy-ref"&gt;here&lt;/a&gt;, so check them out.&lt;/p&gt;
&lt;p&gt;Let’s say we want to write a function &lt;code&gt;as_expectations&lt;/code&gt; that takes a &lt;code&gt;sympy.Expr&lt;/code&gt; and replaces ratios of &lt;span class="math inline"&gt;\(\Phi_1\)&lt;/span&gt; functions according to the following pattern: &lt;span class="math display"&gt;\[\begin{equation}
E[X^n] = \frac{\Phi_1(\alpha, \beta, \gamma + n; x, y)}{\Phi_1(\alpha, \beta, \gamma; x, y)}
\;.
\label{eq:expectation}
\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;As an example, let’s set up a situation in which &lt;code&gt;as_expectations&lt;/code&gt; would be used, and, from there, attempt to construct our function. Naturally, this will involve a test expression with terms that we know match Equation &lt;span class="math inline"&gt;\(\eqref{eq:expectation}\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; sympy &lt;span class="im"&gt;as&lt;/span&gt; sp

&lt;span class="im"&gt;from&lt;/span&gt; hsplus.horn_symbolic &lt;span class="im"&gt;import&lt;/span&gt; HornPhi1

a, b, g, z_1, z_2 &lt;span class="op"&gt;=&lt;/span&gt; sp.symbols(&lt;span class="st"&gt;&amp;#39;a, b, g, z_1, z_2&amp;#39;&lt;/span&gt;, real&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
phi1_1 &lt;span class="op"&gt;=&lt;/span&gt; HornPhi1((a, b), (g,), z_1, z_2)

n &lt;span class="op"&gt;=&lt;/span&gt; sp.Dummy(&lt;span class="st"&gt;&amp;#39;n&amp;#39;&lt;/span&gt;, integer&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;, positive&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)
i &lt;span class="op"&gt;=&lt;/span&gt; sp.Dummy(&lt;span class="st"&gt;&amp;#39;i&amp;#39;&lt;/span&gt;, integer&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;, nonnegative&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)

phi1_2 &lt;span class="op"&gt;=&lt;/span&gt; HornPhi1((a, b), (g &lt;span class="op"&gt;+&lt;/span&gt; n,), z_1, z_2)
phi1_3 &lt;span class="op"&gt;=&lt;/span&gt; HornPhi1((a, b), (g &lt;span class="op"&gt;+&lt;/span&gt; n &lt;span class="op"&gt;-&lt;/span&gt; i,), z_1, z_2)

r_1 &lt;span class="op"&gt;=&lt;/span&gt; phi1_2&lt;span class="op"&gt;/&lt;/span&gt;phi1_1
r_2 &lt;span class="op"&gt;=&lt;/span&gt; phi1_3&lt;span class="op"&gt;/&lt;/span&gt;phi1_1

expr &lt;span class="op"&gt;=&lt;/span&gt; a &lt;span class="op"&gt;*&lt;/span&gt; r_1 &lt;span class="op"&gt;-&lt;/span&gt; b &lt;span class="op"&gt;*&lt;/span&gt; r_1 &lt;span class="op"&gt;/&lt;/span&gt; g &lt;span class="op"&gt;+&lt;/span&gt; sp.Sum(z_1&lt;span class="op"&gt;/&lt;/span&gt;z_2 &lt;span class="op"&gt;*&lt;/span&gt; r_2 &lt;span class="op"&gt;-&lt;/span&gt; &lt;span class="dv"&gt;3&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; r_2, (i, &lt;span class="dv"&gt;0&lt;/span&gt;,
n))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Our test expression &lt;code&gt;expr&lt;/code&gt; looks like this&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(sp.latex(expr, mode&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;equation*&amp;#39;&lt;/span&gt;, itex&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{equation*}
\frac{a \operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad n + g,
\quad z_{1}, \quad z_{2}\right
)\right)}}{\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad g,
\quad z_{1}, \quad z_{2}\right )\right)}} + \sum_{i=0}^{n}
\left(\frac{z_{1} \operatorname{\Phi_1}{\left(\left ( a, \quad b,
\quad - i + n + g, \quad z_{1}, \quad z_{2}\right )\right)}}{z_{2}
\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad g, \quad z_{1},
\quad z_{2}\right )\right)}} - \frac{3
\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad - i + n + g,
\quad z_{1}, \quad z_{2}\right
)\right)}}{\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad g,
\quad z_{1}, \quad z_{2}\right )\right)}}\right) - \frac{b
\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad n + g, \quad
z_{1}, \quad z_{2}\right )\right)}}{g
\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad g, \quad z_{1},
\quad z_{2}\right )\right)}}
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The ratios &lt;code&gt;r_1&lt;/code&gt; and &lt;code&gt;r_2&lt;/code&gt; should both be replaced by a symbol for &lt;span class="math inline"&gt;\(E[X^m]\)&lt;/span&gt;, for &lt;span class="math inline"&gt;\(m = n\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(m = n - i\)&lt;/span&gt; when &lt;span class="math inline"&gt;\(i &amp;lt; n\)&lt;/span&gt; respectively. We could allow &lt;span class="math inline"&gt;\(E[X^0]\)&lt;/span&gt;, I suppose, but–for a more interesting discussion–let’s not.&lt;/p&gt;
&lt;p&gt;We start by creating a SymPy pattern that expresses the mathematical form of &lt;span class="math inline"&gt;\(E[X^m]\)&lt;/span&gt; in Equation &lt;span class="math inline"&gt;\(\eqref{eq:expectation}\)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;pnames &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="st"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;z_1&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;z_2&amp;#39;&lt;/span&gt;)
phi1_wild_args_n &lt;span class="op"&gt;=&lt;/span&gt; sp.symbols(&lt;span class="st"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;.join(n_ &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;_w&amp;#39;&lt;/span&gt; &lt;span class="cf"&gt;for&lt;/span&gt; n_ &lt;span class="kw"&gt;in&lt;/span&gt; pnames),
                              cls&lt;span class="op"&gt;=&lt;/span&gt;sp.Wild, real&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)

n_w &lt;span class="op"&gt;=&lt;/span&gt; sp.Wild(&lt;span class="st"&gt;&amp;#39;n_w&amp;#39;&lt;/span&gt;,
              properties&lt;span class="op"&gt;=&lt;/span&gt;(&lt;span class="kw"&gt;lambda&lt;/span&gt; x: x.is_integer &lt;span class="kw"&gt;and&lt;/span&gt; x.is_positive,),
              exclude&lt;span class="op"&gt;=&lt;/span&gt;(phi1_wild_args_n[&lt;span class="dv"&gt;2&lt;/span&gt;],))

phi1_wild_d &lt;span class="op"&gt;=&lt;/span&gt; HornPhi1(phi1_wild_args_n[&lt;span class="dv"&gt;0&lt;/span&gt;:&lt;span class="dv"&gt;2&lt;/span&gt;],
                       phi1_wild_args_n[&lt;span class="dv"&gt;2&lt;/span&gt;:&lt;span class="dv"&gt;3&lt;/span&gt;],
                       &lt;span class="op"&gt;*&lt;/span&gt;phi1_wild_args_n[&lt;span class="dv"&gt;3&lt;/span&gt;:&lt;span class="dv"&gt;5&lt;/span&gt;])

phi1_wild_n &lt;span class="op"&gt;=&lt;/span&gt; HornPhi1(phi1_wild_args_n[&lt;span class="dv"&gt;0&lt;/span&gt;:&lt;span class="dv"&gt;2&lt;/span&gt;],
                       (phi1_wild_args_n[&lt;span class="dv"&gt;2&lt;/span&gt;] &lt;span class="op"&gt;+&lt;/span&gt; n_w,),
                       &lt;span class="op"&gt;*&lt;/span&gt;phi1_wild_args_n[&lt;span class="dv"&gt;3&lt;/span&gt;:&lt;span class="dv"&gt;5&lt;/span&gt;])

C_w &lt;span class="op"&gt;=&lt;/span&gt; sp.Wild(&lt;span class="st"&gt;&amp;#39;C_w&amp;#39;&lt;/span&gt;, exclude&lt;span class="op"&gt;=&lt;/span&gt;[sp.S.Zero])
E_pattern &lt;span class="op"&gt;=&lt;/span&gt; phi1_wild_n &lt;span class="op"&gt;/&lt;/span&gt; phi1_wild_d

E_fn &lt;span class="op"&gt;=&lt;/span&gt; sp.Function(&lt;span class="st"&gt;&amp;quot;E&amp;quot;&lt;/span&gt;, real&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When we find an &lt;span class="math inline"&gt;\(E[X^m]\)&lt;/span&gt; we’ll replace it with the symbolic function &lt;code&gt;E_fn&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If we focus on only one of the terms (one we know matches &lt;code&gt;E_pattern&lt;/code&gt;), &lt;code&gt;r_1&lt;/code&gt;, we should find that our pattern suffices:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; r_1.match(E_pattern)
{n_w_: _n, z_2_w_: z_2, z_1_w_: z_1, a_w_: a, g_w_: g, b_w_: b}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, building up to the complexity of &lt;code&gt;expr&lt;/code&gt;, we see that a simple product doesn’t:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; (a &lt;span class="op"&gt;*&lt;/span&gt; r_1).match(E_pattern)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, the product has introduced some problems that arise from associativity. Here are the details for the root expression tree:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; (a &lt;span class="op"&gt;*&lt;/span&gt; r_1).func
&lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;sympy.core.mul.Mul&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; (a &lt;span class="op"&gt;*&lt;/span&gt; r_1).args
(a, &lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;/&lt;/span&gt;HornPhi1(a, b, g, z_1, z_2), HornPhi1(a, b, _n &lt;span class="op"&gt;+&lt;/span&gt; g, z_1, z_2))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The root operation is multiplication and the operation’s arguments are all terms in the product/division.&lt;/p&gt;
&lt;p&gt;Any complete search for matches to &lt;code&gt;E_pattern&lt;/code&gt; would have to consider all possible combinations of terms in &lt;code&gt;(a * r_1).args&lt;/code&gt;, i.e. all possible groupings that arise due to associativity. The simple inclusion of another &lt;code&gt;Wild&lt;/code&gt; term causes the match to succeed, since SymPy’s basic pattern matching does account for associativity in this case.&lt;/p&gt;
&lt;p&gt;Here are a few explicit ways to make the match work:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; (a &lt;span class="op"&gt;*&lt;/span&gt; r_1).match(C_w &lt;span class="op"&gt;*&lt;/span&gt; E_pattern)
{a_w_: a, n_w_: _n, g_w_: g, z_2_w_: z_2, C_w_: a, b_w_: b, z_1_w_:
z_1}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or as a replacement:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res &lt;span class="op"&gt;=&lt;/span&gt; (a &lt;span class="op"&gt;*&lt;/span&gt; r_1).replace(C_w &lt;span class="op"&gt;*&lt;/span&gt; E_pattern, C_w &lt;span class="op"&gt;*&lt;/span&gt; E_fn(n_w,
&lt;span class="op"&gt;*&lt;/span&gt;phi1_wild_args_n))
&lt;span class="bu"&gt;print&lt;/span&gt;(sp.latex(res, mode&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;equation*&amp;#39;&lt;/span&gt;, itex&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{equation*}
a E{\left (n,a,b,g,z_{1},z_{2} \right )}
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;and via &lt;code&gt;rewriterule&lt;/code&gt;:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from&lt;/span&gt; sympy.unify.rewrite &lt;span class="im"&gt;import&lt;/span&gt; rewriterule
rl &lt;span class="op"&gt;=&lt;/span&gt; rewriterule(C_w &lt;span class="op"&gt;*&lt;/span&gt; E_pattern,
                 C_w &lt;span class="op"&gt;*&lt;/span&gt; E_fn(n_w, &lt;span class="op"&gt;*&lt;/span&gt;phi1_wild_args_n),
                 phi1_wild_args_n &lt;span class="op"&gt;+&lt;/span&gt; (n_w, C_w))
res &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;list&lt;/span&gt;(rl(a &lt;span class="op"&gt;*&lt;/span&gt; r_1))
&lt;span class="bu"&gt;print&lt;/span&gt;(sp.latex(res, mode&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;equation*&amp;#39;&lt;/span&gt;, itex&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{equation*}
\left [ a E{\left (n,a,b,g,z_{1},z_{2} \right )}\right ]
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The advantage in using &lt;code&gt;rewriterule&lt;/code&gt; is that multiple matches will be returned. If we add another &lt;span class="math inline"&gt;\(\Phi_1\)&lt;/span&gt; in the numerator, so there are multiple possible &lt;span class="math inline"&gt;\(E[X^m]\)&lt;/span&gt;, we get&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;phi1_4 &lt;span class="op"&gt;=&lt;/span&gt; HornPhi1((a, b), (g &lt;span class="op"&gt;+&lt;/span&gt; n &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;,), z_1, z_2)

res &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;list&lt;/span&gt;(rl(a &lt;span class="op"&gt;*&lt;/span&gt; r_1 &lt;span class="op"&gt;*&lt;/span&gt; phi1_4))
&lt;span class="bu"&gt;print&lt;/span&gt;(sp.latex(res, mode&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;equation*&amp;#39;&lt;/span&gt;, itex&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{equation*}
\left [ a \operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad n +
g, \quad z_{1}, \quad z_{2}\right )\right)} E{\left (n +
1,a,b,g,z_{1},z_{2} \right )}, \quad a
\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad n + g, \quad
z_{1}, \quad z_{2}\right )\right)} E{\left (n + 1,a,b,g,z_{1},z_{2}
\right )}, \quad a \operatorname{\Phi_1}{\left(\left ( a, \quad b,
\quad n + g + 1, \quad z_{1}, \quad z_{2}\right )\right)} E{\left
(n,a,b,g,z_{1},z_{2} \right )}, \quad a
\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad n + g, \quad
z_{1}, \quad z_{2}\right )\right)} E{\left (n + 1,a,b,g,z_{1},z_{2}
\right )}, \quad a \operatorname{\Phi_1}{\left(\left ( a, \quad b,
\quad n + g, \quad z_{1}, \quad z_{2}\right )\right)} E{\left (n +
1,a,b,g,z_{1},z_{2} \right )}, \quad a
\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad n + g + 1, \quad
z_{1}, \quad z_{2}\right )\right)} E{\left (n,a,b,g,z_{1},z_{2} \right
)}\right ]
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;FYI: the associativity of terms inside the function arguments is causing the seemingly duplicate results.&lt;/p&gt;
&lt;p&gt;Naive use of &lt;code&gt;Expr.replace&lt;/code&gt; doesn’t give all results; instead, it does something likely unexpected:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res &lt;span class="op"&gt;=&lt;/span&gt; (a &lt;span class="op"&gt;*&lt;/span&gt; r_1 &lt;span class="op"&gt;*&lt;/span&gt; phi1_4).replace(C_w &lt;span class="op"&gt;*&lt;/span&gt; E_pattern,
                                 C_w &lt;span class="op"&gt;*&lt;/span&gt; E_fn(n_w, &lt;span class="op"&gt;*&lt;/span&gt;phi1_wild_args_n))
&lt;span class="bu"&gt;print&lt;/span&gt;(sp.latex(res, mode&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;equation*&amp;#39;&lt;/span&gt;, itex&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{equation*}
a E{\left (n,a,b,g,z_{1},z_{2} \right )} E{\left (n +
1,a,b,g,z_{1},z_{2} \right )} \operatorname{\Phi_1}{\left(\left ( a,
\quad b, \quad g, \quad z_{1}, \quad z_{2}\right )\right)}
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Returning to our more complicated &lt;code&gt;expr&lt;/code&gt;…Just because we can match products doesn’t mean we’re finished, since we still need a good way to traverse the entire expression tree and match the sub-trees. More importantly, adding the multiplicative &lt;code&gt;Wild&lt;/code&gt; term &lt;code&gt;C_w&lt;/code&gt; is more of a hack than a direct solution, since we don’t want the matched contents of &lt;code&gt;C_w&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Although &lt;code&gt;Expr.replace/xreplace&lt;/code&gt; will match sub-expressions, we found above that it produces some odd results. Those results persist when applied to more complicated expressions:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res &lt;span class="op"&gt;=&lt;/span&gt; expr.replace(C_w &lt;span class="op"&gt;*&lt;/span&gt; E_pattern, C_w &lt;span class="op"&gt;*&lt;/span&gt; E_fn(n_w,
&lt;span class="op"&gt;*&lt;/span&gt;phi1_wild_args_n))
&lt;span class="bu"&gt;print&lt;/span&gt;(sp.latex(res, mode&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;equation*&amp;#39;&lt;/span&gt;, itex&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{equation*}
a E{\left (n,a,b,g,z_{1},z_{2} \right )} - \frac{b}{g} E{\left
(n,a,b,g,z_{1},z_{2} \right )} + \sum_{i=0}^{n} \left(\frac{z_{1}
E{\left (n,a,b,- i + g,z_{1},z_{2} \right )}
\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad - i + g, \quad
z_{1}, \quad z_{2}\right )\right)}}{z_{2}
\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad g, \quad z_{1},
\quad z_{2}\right )\right)}} - \frac{3 E{\left (n,a,b,- i +
g,z_{1},z_{2} \right )} \operatorname{\Phi_1}{\left(\left ( a, \quad
b, \quad - i + g, \quad z_{1}, \quad z_{2}\right
)\right)}}{\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad g,
\quad z_{1}, \quad z_{2}\right )\right)}}\right)
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Again, it looks like the matching was a little too liberal and introduced extra &lt;code&gt;E&lt;/code&gt; and &lt;code&gt;HornPhi1&lt;/code&gt; terms. This is to be expected from the &lt;code&gt;Wild&lt;/code&gt; matching in SymPy; it needs us to specify what &lt;em&gt;not&lt;/em&gt; to match, as well. Our “fix” that introduced &lt;code&gt;C_w&lt;/code&gt; is the exact source of the problem, but we can tell it not to match &lt;code&gt;HornPhi1&lt;/code&gt; terms and get better results:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;C_w &lt;span class="op"&gt;=&lt;/span&gt; sp.Wild(&lt;span class="st"&gt;&amp;#39;C_w&amp;#39;&lt;/span&gt;, exclude&lt;span class="op"&gt;=&lt;/span&gt;[sp.S.Zero, HornPhi1])
res &lt;span class="op"&gt;=&lt;/span&gt; expr.replace(C_w &lt;span class="op"&gt;*&lt;/span&gt; E_pattern, C_w &lt;span class="op"&gt;*&lt;/span&gt; E_fn(n_w,
&lt;span class="op"&gt;*&lt;/span&gt;phi1_wild_args_n))
&lt;span class="bu"&gt;print&lt;/span&gt;(sp.latex(res, mode&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;equation*&amp;#39;&lt;/span&gt;, itex&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{equation*}
a E{\left (n,a,b,g,z_{1},z_{2} \right )} - \frac{b}{g} E{\left
(n,a,b,g,z_{1},z_{2} \right )} + \sum_{i=0}^{n} \left(\frac{z_{1}
\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad - i + n + g,
\quad z_{1}, \quad z_{2}\right )\right)}}{z_{2}
\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad g, \quad z_{1},
\quad z_{2}\right )\right)}} - \frac{3
\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad - i + n + g,
\quad z_{1}, \quad z_{2}\right
)\right)}}{\operatorname{\Phi_1}{\left(\left ( a, \quad b, \quad g,
\quad z_{1}, \quad z_{2}\right )\right)}}\right)
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We’ve stopped it from introducing those superfluous &lt;code&gt;E&lt;/code&gt; terms, but we’re still not getting replacements for the &lt;code&gt;HornPhi1&lt;/code&gt; ratios in the sums. Let’s single out those terms and see what’s going on:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;res &lt;span class="op"&gt;=&lt;/span&gt; r_2.find(C_w &lt;span class="op"&gt;*&lt;/span&gt; E_pattern)
&lt;span class="bu"&gt;print&lt;/span&gt;(sp.latex(res, mode&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;equation*&amp;#39;&lt;/span&gt;, itex&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{equation*}
\left\{\right\}
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The constrained integer &lt;code&gt;Wild&lt;/code&gt; term, &lt;code&gt;n_w&lt;/code&gt;, probably isn’t matching. Given the form of our pattern, &lt;code&gt;n_w&lt;/code&gt; should match &lt;code&gt;n - i&lt;/code&gt;, but &lt;code&gt;n - i&lt;/code&gt; isn’t strictly positive, as required:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; (n &lt;span class="op"&gt;-&lt;/span&gt; i).is_positive &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="va"&gt;True&lt;/span&gt;
&lt;span class="va"&gt;False&lt;/span&gt;
&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; sp.ask(sp.Q.positive(n &lt;span class="op"&gt;-&lt;/span&gt; i)) &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="va"&gt;True&lt;/span&gt;
&lt;span class="va"&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since &lt;span class="math inline"&gt;\(n &amp;gt; 0\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(i &amp;gt;= 0\)&lt;/span&gt;, the only missing piece is that &lt;span class="math inline"&gt;\(n &amp;gt; i\)&lt;/span&gt;. The most relevant mechanism in SymPy to assess this information is the &lt;a href="http://docs.sympy.org/dev/modules/assumptions/index.html"&gt;&lt;code&gt;sympy.assumptions&lt;/code&gt;&lt;/a&gt; interface. We could add and retrieve the assumption &lt;code&gt;sympy.Q.is_true(n &amp;gt; i)&lt;/code&gt; via &lt;code&gt;sympy.assume.global_assumptions&lt;/code&gt;, or perform these operations inside of a Python &lt;code&gt;with&lt;/code&gt; block, etc. This context management, via &lt;code&gt;sympy.assumptions.assume.AssumptionsContext&lt;/code&gt;, would have to be performed manually, since I am not aware of any such mechanism offered by &lt;code&gt;Sum&lt;/code&gt; and/or &lt;code&gt;Basic.replace&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Unfortunately, these ideas sound good, but aren’t implemented:&lt;/p&gt;
&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; sp.ask(sp.Q.positive(n &lt;span class="op"&gt;-&lt;/span&gt; i), sp.Q.is_true(n &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; i)) &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="va"&gt;True&lt;/span&gt;
&lt;span class="va"&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;See the documentation for &lt;code&gt;sympy.assumptions.ask.ask&lt;/code&gt;; it explicitely states that inequalities aren’t handled, yet.&lt;/p&gt;
&lt;p&gt;We could probably perform a manual reworking of &lt;code&gt;sympy.Q.is_true(n &amp;gt; i)&lt;/code&gt; to &lt;code&gt;sympy.Q.is_true(n - i &amp;gt; 0)&lt;/code&gt;, which is of course equivalent to &lt;code&gt;sympy.Q.positive(n - i)&lt;/code&gt;: the result we want.&lt;/p&gt;
&lt;p&gt;If one were to provide this functionality, there’s still the question of how the relevant &lt;code&gt;AssumptionsContext&lt;/code&gt;s would be created and passed around/nested during the subexpression replacements. There is no apparent means of adding this sort of functionality through the &lt;code&gt;Basic.replace&lt;/code&gt; interface, so this path looks less appealing. However, nesting &lt;code&gt;with&lt;/code&gt; blocks from strategies in &lt;code&gt;sympy.strategies&lt;/code&gt; does seem quite possible. For example, in &lt;code&gt;sympy.strategies.traverse.sall&lt;/code&gt;, one could possibly wrap the &lt;code&gt;return&lt;/code&gt; statement after the &lt;code&gt;map(rule, ...)&lt;/code&gt; call in a &lt;code&gt;with sympy.assuming(...):&lt;/code&gt; block that contains the assumptions for any variables arising as, say, the index of a &lt;code&gt;Sum&lt;/code&gt;–like in our case. In this scenario, code in the subexpressions would be able to ask questions like &lt;code&gt;sympy.Q.is_true(n &amp;gt; i)&lt;/code&gt; without altering the global assumptions context or the objects involved.&lt;/p&gt;
&lt;p&gt;Anyway, that’s all I wanted to cover here. Perhaps later I’ll post a hack for the assumptions approach, but–at the very least–I’ll try to follow up with a more direct solution that uses &lt;code&gt;sympy.strategies&lt;/code&gt;.&lt;/p&gt;
&lt;script type="text/x-mathjax-config"&gt;
MathJax.Hub.Config({
  CommonHTML: { linebreaks: { automatic: true } },
  "HTML-CSS": { linebreaks: { automatic: true } },
  SVG: { linebreaks: { automatic: true } },
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Brandon Willard</dc:creator><pubDate>Thu, 27 Oct 2016 00:00:00 -0500</pubDate><guid isPermaLink="false">tag:brandonwillard.github.io,2016-10-27:sympy-expression-tree-manipulation.html</guid></item></channel></rss>