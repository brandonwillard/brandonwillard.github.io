<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Brandon T. Willard - Brandon T. Willard</title><link href="https://brandonwillard.github.io/" rel="alternate"></link><link href="https://brandonwillard.github.io/feeds/brandon-t-willard.atom.xml" rel="self"></link><id>https://brandonwillard.github.io/</id><updated>2018-12-28T00:00:00-06:00</updated><entry><title>Random Variables in Theano</title><link href="https://brandonwillard.github.io/random-variables-in-theano.html" rel="alternate"></link><published>2018-12-28T00:00:00-06:00</published><updated>2018-12-28T00:00:00-06:00</updated><author><name>Brandon T. Willard</name></author><id>tag:brandonwillard.github.io,2018-12-28:/random-variables-in-theano.html</id><summary type="html"></summary><content type="html">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
  &lt;meta http-equiv="Content-Style-Type" content="text/css" /&gt;
  &lt;meta name="generator" content="pandoc" /&gt;
  &lt;meta name="author" content="Brandon T. Willard" /&gt;
  &lt;title&gt;Random Variables in Theano&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  &lt;/style&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--  --&gt;
&lt;!-- &lt;div id="header"&gt; --&gt;
&lt;!-- &lt;h1 class="title"&gt;Random Variables in Theano&lt;/h1&gt; --&gt;
&lt;!--  --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;h2 class="author"&gt;Brandon T. Willard&lt;/h2&gt; --&gt;
&lt;!--  --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;h3 class="date"&gt;2018–12–28&lt;/h3&gt; --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;/div&gt; --&gt;
&lt;!--  --&gt;
&lt;div class="abstract"&gt;
&lt;p&gt;Continuing from &lt;sup id="24875a2c31fa7f94ce562adddedc0bf8"&gt;&lt;a href="#WillardSymbolicMathPyMC32018" title="@misc{WillardSymbolicMathPyMC32018, title = {Symbolic {{Math}} in {{PyMC3}}}, urldate = {2018-12-27}, url = {https://brandonwillard.github.io/symbolic-math-in-pymc3.html}, author = {Willard, Brandon T.}, month = dec, year = {2018}, file = {/home/bwillard/Zotero/storage/6VVT4UNF/symbolic-math-in-pymc3.html} }"&gt;WillardSymbolicMathPyMC32018&lt;/a&gt;&lt;/sup&gt;, we’ll attempt to improve upon &lt;code&gt;RandomFunction&lt;/code&gt; and make a case for a similar &lt;code&gt;Op&lt;/code&gt; in PyMC3.&lt;/p&gt;
&lt;/div&gt;
&lt;section id="a-new-random-variable-op" class="level1"&gt;
&lt;h1&gt;A &lt;strong&gt;new&lt;/strong&gt; Random Variable &lt;code&gt;Op&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;We’ll call this new &lt;code&gt;Op&lt;/code&gt; &lt;code&gt;RandomVariable&lt;/code&gt;, since random variables are the abstraction we’re primarily targeting. &lt;code&gt;RandomVariable&lt;/code&gt; will provide the functionality of &lt;code&gt;Distribution&lt;/code&gt;, &lt;code&gt;FreeRV&lt;/code&gt; and &lt;code&gt;ObservedRV&lt;/code&gt;, and, by working at the &lt;code&gt;Op&lt;/code&gt; level, it will be much more capable of leveraging existing Theano functionality.&lt;/p&gt;
&lt;p&gt;Specifically, by using the &lt;code&gt;Op&lt;/code&gt; interface, we’re able to do the following:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;&lt;p&gt;Reduce/remove the need for an explicitly specified shape parameter.&lt;/p&gt;
&lt;div class="example" data-markdown=""&gt;
&lt;p&gt;For example, definitions like&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="cf"&gt;with&lt;/span&gt; pm.Model():&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;    X_rv &lt;span class="op"&gt;=&lt;/span&gt; pm.Normal(&lt;span class="st"&gt;&amp;#39;X_rv&amp;#39;&lt;/span&gt;, mu_X, sd&lt;span class="op"&gt;=&lt;/span&gt;sd_X, shape&lt;span class="op"&gt;=&lt;/span&gt;(&lt;span class="dv"&gt;1&lt;/span&gt;,))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reduce to&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="cf"&gt;with&lt;/span&gt; pm.Model():&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;    X_rv &lt;span class="op"&gt;=&lt;/span&gt; pm.Normal(&lt;span class="st"&gt;&amp;#39;X_rv&amp;#39;&lt;/span&gt;, mu_X, sd&lt;span class="op"&gt;=&lt;/span&gt;sd_X)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;Random variable nodes created by an &lt;code&gt;Op&lt;/code&gt; automatically implement &lt;code&gt;Distribution.default&lt;/code&gt;/&lt;code&gt;Distribution.get_test_val&lt;/code&gt; functionality and remove the reliance on initial values during random variable instantiation. &lt;code&gt;Op&lt;/code&gt; automatically uses &lt;code&gt;Op.perform&lt;/code&gt;, which will draw a sample as a test value &lt;strong&gt;and&lt;/strong&gt; propagate it throughout the graph to derived/down-stream tensor variables.&lt;/li&gt;
&lt;li&gt;Log-densities can be generated as secondary outputs of &lt;code&gt;Op.make_node&lt;/code&gt;, which removes the need for &lt;code&gt;Distribution.logp*&lt;/code&gt; methods.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;pymc.distribution.draw_values&lt;/code&gt; and related methods are no longer necessary; their functionality is already covered within Theano’s existing graph machinery–in the same way as &lt;code&gt;pymc.distribution.Distribution.default/get_test_val&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The main points of entry in our &lt;code&gt;Op&lt;/code&gt;, are &lt;code&gt;Op.make_node&lt;/code&gt; and &lt;code&gt;Op.perform&lt;/code&gt;. &lt;code&gt;Op.make_node&lt;/code&gt; is used during symbolic graph creation and provides immediate access to the &lt;code&gt;Op&lt;/code&gt;’s symbolic inputs–serving a purpose similar to &lt;code&gt;Distribution.__init__&lt;/code&gt;. &lt;code&gt;Op.make_node&lt;/code&gt; is where shape inference tasks (e.g. &lt;a href="https://github.com/pymc-devs/pymc3/pull/1125"&gt;PyMC3 PR 1125&lt;/a&gt;) are more suitably addressed; however, &lt;code&gt;Op&lt;/code&gt; provides additional means of shape inference and management (e.g. &lt;code&gt;Op.infer_shape&lt;/code&gt;) occurring at different phases of graph compilation that aren’t readily accessible outside of the &lt;code&gt;Op&lt;/code&gt; framework.&lt;/p&gt;
&lt;section id="implementation" class="level2"&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;div class="sourceCode" id="import_theano_pymc3"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="import_theano_pymc3-1" title="1"&gt;&lt;span class="im"&gt;import&lt;/span&gt; sys&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-2" title="2"&gt;&lt;span class="im"&gt;import&lt;/span&gt; os&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-4" title="4"&gt;&lt;span class="im"&gt;from&lt;/span&gt; pprint &lt;span class="im"&gt;import&lt;/span&gt; pprint&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-6" title="6"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-8" title="8"&gt;os.environ[&lt;span class="st"&gt;&amp;#39;MKL_THREADING_LAYER&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;GNU&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-9" title="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-10" title="10"&gt;&lt;span class="im"&gt;import&lt;/span&gt; theano&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-11" title="11"&gt;&lt;span class="im"&gt;import&lt;/span&gt; theano.tensor &lt;span class="im"&gt;as&lt;/span&gt; tt&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-12" title="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-13" title="13"&gt;theano.config.mode &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;FAST_COMPILE&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-14" title="14"&gt;theano.config.exception_verbosity &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;high&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-15" title="15"&gt;theano.config.compute_test_value &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;raise&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-16" title="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="import_theano_pymc3-17" title="17"&gt;&lt;span class="im"&gt;import&lt;/span&gt; pymc3 &lt;span class="im"&gt;as&lt;/span&gt; pm&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="supp_shape_fn"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="supp_shape_fn-1" title="1"&gt;&lt;span class="im"&gt;from&lt;/span&gt; collections.abc &lt;span class="im"&gt;import&lt;/span&gt; Iterable, ByteString&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-2" title="2"&gt;&lt;span class="im"&gt;from&lt;/span&gt; warnings &lt;span class="im"&gt;import&lt;/span&gt; warn&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-3" title="3"&gt;&lt;span class="im"&gt;from&lt;/span&gt; copy &lt;span class="im"&gt;import&lt;/span&gt; copy&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-5" title="5"&gt;&lt;span class="im"&gt;from&lt;/span&gt; theano.tensor.raw_random &lt;span class="im"&gt;import&lt;/span&gt; (RandomFunction, RandomStateType,&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-6" title="6"&gt;                                      _infer_ndim_bcast)&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-8" title="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-9" title="9"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; matched_supp_shape_fn(ndim_supp, ndims_params, dist_params,&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-10" title="10"&gt;                          param_shapes&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-11" title="11"&gt;    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;A function for extracting a random variable&amp;#39;s support shape/dimensions&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-12" title="12"&gt;&lt;span class="co"&gt;    from other (e.g. distribution parameters) shape information.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-13" title="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-14" title="14"&gt;&lt;span class="co"&gt;    This default implementation uses the first non-independent/replicated&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-15" title="15"&gt;&lt;span class="co"&gt;    dimension of the first distribution parameter.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-16" title="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-17" title="17"&gt;&lt;span class="co"&gt;    For example, with a normal random variable, the shape of the mean parameter&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-18" title="18"&gt;&lt;span class="co"&gt;    along the first dimension will be used; dimensions after that, if any,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-19" title="19"&gt;&lt;span class="co"&gt;    determine the mean parameters for other *independent* normal variables.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-20" title="20"&gt;&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-21" title="21"&gt;    &lt;span class="co"&gt;# XXX: Gotta be careful slicing Theano variables, the `Subtensor` Op isn&amp;#39;t&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-22" title="22"&gt;    &lt;span class="co"&gt;# handled by `tensor.get_scalar_constant_value`!&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-23" title="23"&gt;    &lt;span class="co"&gt;# E.g.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-24" title="24"&gt;    &lt;span class="co"&gt;#     test_val = tt.as_tensor_variable([[1], [4]])&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-25" title="25"&gt;    &lt;span class="co"&gt;#     tt.get_scalar_constant_value(test_val.shape[-1]) # works&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-26" title="26"&gt;    &lt;span class="co"&gt;#     tt.get_scalar_constant_value(test_val.shape[0]) # doesn&amp;#39;t&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-27" title="27"&gt;    &lt;span class="co"&gt;#     tt.get_scalar_constant_value(test_val.shape[:-1]) # doesn&amp;#39;t&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-28" title="28"&gt;    &lt;span class="cf"&gt;if&lt;/span&gt; param_shapes &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-29" title="29"&gt;        &lt;span class="co"&gt;# return param_shapes[0][-self.ndim_supp:]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-30" title="30"&gt;        &lt;span class="cf"&gt;return&lt;/span&gt; (param_shapes[&lt;span class="dv"&gt;0&lt;/span&gt;][&lt;span class="op"&gt;-&lt;/span&gt;ndim_supp],)&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-31" title="31"&gt;    &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-32" title="32"&gt;        ref_shape &lt;span class="op"&gt;=&lt;/span&gt; tt.shape(dist_params[&lt;span class="dv"&gt;0&lt;/span&gt;])&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-33" title="33"&gt;        &lt;span class="co"&gt;# return ref_shape[-self.ndim_supp:]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="supp_shape_fn-34" title="34"&gt;        &lt;span class="cf"&gt;return&lt;/span&gt; (ref_shape[&lt;span class="op"&gt;-&lt;/span&gt;ndim_supp],)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="new_rv_op"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="new_rv_op-1" title="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; RandomVariable(tt.gof.Op):&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-2" title="2"&gt;    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;This is essentially `RandomFunction`, except that it removes the `outtype`&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-3" title="3"&gt;&lt;span class="co"&gt;    dependency and handles shape dimension information more directly.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-4" title="4"&gt;&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-5" title="5"&gt;    __props__ &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="st"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;dtype&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;ndim_supp&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;inplace&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;ndims_params&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-6" title="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-7" title="7"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; &lt;span class="fu"&gt;__init__&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;, name, ndim_supp, ndims_params, rng_fn, &lt;span class="op"&gt;*&lt;/span&gt;args,&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-8" title="8"&gt;                 supp_shape_fn&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;, dtype&lt;span class="op"&gt;=&lt;/span&gt;theano.config.floatX, inplace&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-9" title="9"&gt;                 &lt;span class="op"&gt;**&lt;/span&gt;kwargs):&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-10" title="10"&gt;        &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Create a random variable `Op`.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-11" title="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-12" title="12"&gt;&lt;span class="co"&gt;        Parameters&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-13" title="13"&gt;&lt;span class="co"&gt;        ==========&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-14" title="14"&gt;&lt;span class="co"&gt;        ndim_supp: int&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-15" title="15"&gt;&lt;span class="co"&gt;            Dimension of the support.  This value is used to infer the exact&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-16" title="16"&gt;&lt;span class="co"&gt;            shape of the support and independent terms from ``dist_params``.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-17" title="17"&gt;&lt;span class="co"&gt;        ndims_params: tuple (int)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-18" title="18"&gt;&lt;span class="co"&gt;            Number of dimensions for each parameter in ``dist_params``&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-19" title="19"&gt;&lt;span class="co"&gt;            for a single variate.  Used to determine the shape of the&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-20" title="20"&gt;&lt;span class="co"&gt;            independent variate space.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-21" title="21"&gt;&lt;span class="co"&gt;        rng_fn: function or str&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-22" title="22"&gt;&lt;span class="co"&gt;            Sampler function.  Can be the string name of a method provided by&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-23" title="23"&gt;&lt;span class="co"&gt;            `numpy.random.RandomState`.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-24" title="24"&gt;&lt;span class="co"&gt;        supp_shape_fn: callable&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-25" title="25"&gt;&lt;span class="co"&gt;            Function used to determine the exact shape of the distribution&amp;#39;s&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-26" title="26"&gt;&lt;span class="co"&gt;            support. It must take arguments ndim_supp, ndims_params,&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-27" title="27"&gt;&lt;span class="co"&gt;            dist_params (i.e. an collection of the distribution parameters) and an&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-28" title="28"&gt;&lt;span class="co"&gt;            optional param_shapes (i.e. tuples containing the size of each&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-29" title="29"&gt;&lt;span class="co"&gt;            dimension for each distribution parameter).&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-30" title="30"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-31" title="31"&gt;&lt;span class="co"&gt;            Defaults to `supp_shape_fn`&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-32" title="32"&gt;&lt;span class="co"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-33" title="33"&gt;        &lt;span class="bu"&gt;super&lt;/span&gt;().&lt;span class="fu"&gt;__init__&lt;/span&gt;(&lt;span class="op"&gt;*&lt;/span&gt;args, &lt;span class="op"&gt;**&lt;/span&gt;kwargs)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-34" title="34"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-35" title="35"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.name &lt;span class="op"&gt;=&lt;/span&gt; name&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-36" title="36"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.inplace &lt;span class="op"&gt;=&lt;/span&gt; inplace&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-37" title="37"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.dtype &lt;span class="op"&gt;=&lt;/span&gt; dtype&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-38" title="38"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-39" title="39"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.supp_shape_fn &lt;span class="op"&gt;=&lt;/span&gt; supp_shape_fn &lt;span class="kw"&gt;or&lt;/span&gt; matched_supp_shape_fn&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-40" title="40"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-41" title="41"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.ndim_supp &lt;span class="op"&gt;=&lt;/span&gt; ndim_supp&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-42" title="42"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-43" title="43"&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="bu"&gt;isinstance&lt;/span&gt;(ndims_params, Iterable):&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-44" title="44"&gt;            &lt;span class="cf"&gt;raise&lt;/span&gt; &lt;span class="pp"&gt;ValueError&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;Parameter ndims_params must be iterable.&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-45" title="45"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-46" title="46"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.ndims_params &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;tuple&lt;/span&gt;(ndims_params)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-47" title="47"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-48" title="48"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.default_output &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-49" title="49"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-50" title="50"&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="bu"&gt;isinstance&lt;/span&gt;(rng_fn, (&lt;span class="bu"&gt;str&lt;/span&gt;, ByteString)):&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-51" title="51"&gt;            &lt;span class="va"&gt;self&lt;/span&gt;.rng_fn &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;getattr&lt;/span&gt;(np.random.RandomState, rng_fn)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-52" title="52"&gt;        &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-53" title="53"&gt;            &lt;span class="va"&gt;self&lt;/span&gt;.rng_fn &lt;span class="op"&gt;=&lt;/span&gt; rng_fn&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-54" title="54"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-55" title="55"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; &lt;span class="fu"&gt;__str__&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;):&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-56" title="56"&gt;        &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;&lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;_rv&amp;#39;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;.name)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-57" title="57"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-58" title="58"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; _infer_shape(&lt;span class="va"&gt;self&lt;/span&gt;, size, dist_params, param_shapes&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-59" title="59"&gt;        &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Compute shapes and broadcasts properties.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-60" title="60"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-61" title="61"&gt;&lt;span class="co"&gt;        Inspired by `tt.add.get_output_info`.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-62" title="62"&gt;&lt;span class="co"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-63" title="63"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-64" title="64"&gt;        size_len &lt;span class="op"&gt;=&lt;/span&gt; tt.get_vector_length(size)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-65" title="65"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-66" title="66"&gt;        dummy_params &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;tuple&lt;/span&gt;(p &lt;span class="cf"&gt;if&lt;/span&gt; n &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="cf"&gt;else&lt;/span&gt; tt.ones(&lt;span class="bu"&gt;tuple&lt;/span&gt;(p.shape)[:&lt;span class="op"&gt;-&lt;/span&gt;n])&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-67" title="67"&gt;                             &lt;span class="cf"&gt;for&lt;/span&gt; p, n &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;zip&lt;/span&gt;(dist_params, &lt;span class="va"&gt;self&lt;/span&gt;.ndims_params))&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-68" title="68"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-69" title="69"&gt;        _, out_bcasts, bcastd_inputs &lt;span class="op"&gt;=&lt;/span&gt; tt.add.get_output_info(&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-70" title="70"&gt;            tt.DimShuffle, &lt;span class="op"&gt;*&lt;/span&gt;dummy_params)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-71" title="71"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-72" title="72"&gt;        &lt;span class="co"&gt;# _, out_bcasts, bcastd_inputs = tt.add.get_output_info(tt.DimShuffle, *dist_params)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-73" title="73"&gt;        &lt;span class="co"&gt;# .tag.test_value&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-74" title="74"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-75" title="75"&gt;        bcast_ind, &lt;span class="op"&gt;=&lt;/span&gt; out_bcasts&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-76" title="76"&gt;        ndim_ind &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;len&lt;/span&gt;(bcast_ind)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-77" title="77"&gt;        shape_ind &lt;span class="op"&gt;=&lt;/span&gt; bcastd_inputs[&lt;span class="dv"&gt;0&lt;/span&gt;].shape&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-78" title="78"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-79" title="79"&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.ndim_supp &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-80" title="80"&gt;            shape_supp &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;tuple&lt;/span&gt;()&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-81" title="81"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-82" title="82"&gt;            &lt;span class="co"&gt;# In the scalar case, `size` corresponds to the entire result&amp;#39;s&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-83" title="83"&gt;            &lt;span class="co"&gt;# shape. This implies the following:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-84" title="84"&gt;            &lt;span class="co"&gt;#     shape_ind[-ndim_ind] == size[:ndim_ind]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-85" title="85"&gt;            &lt;span class="co"&gt;# &lt;/span&gt;&lt;span class="al"&gt;TODO&lt;/span&gt;&lt;span class="co"&gt;: How do we add this constraint/check symbolically?&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-86" title="86"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-87" title="87"&gt;            ndim_reps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;max&lt;/span&gt;(size_len &lt;span class="op"&gt;-&lt;/span&gt; ndim_ind, &lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-88" title="88"&gt;            shape_reps &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;tuple&lt;/span&gt;(size)[ndim_ind:]&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-89" title="89"&gt;        &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-90" title="90"&gt;            shape_supp &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.supp_shape_fn(&lt;span class="va"&gt;self&lt;/span&gt;.ndim_supp,&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-91" title="91"&gt;                                            &lt;span class="va"&gt;self&lt;/span&gt;.ndims_params,&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-92" title="92"&gt;                                            dist_params,&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-93" title="93"&gt;                                            param_shapes&lt;span class="op"&gt;=&lt;/span&gt;param_shapes)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-94" title="94"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-95" title="95"&gt;            ndim_reps &lt;span class="op"&gt;=&lt;/span&gt; size_len&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-96" title="96"&gt;            shape_reps &lt;span class="op"&gt;=&lt;/span&gt; size&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-97" title="97"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-98" title="98"&gt;        ndim_shape &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.ndim_supp &lt;span class="op"&gt;+&lt;/span&gt; ndim_ind &lt;span class="op"&gt;+&lt;/span&gt; ndim_reps&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-99" title="99"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-100" title="100"&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; ndim_shape &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-101" title="101"&gt;            shape &lt;span class="op"&gt;=&lt;/span&gt; tt.constant([], dtype&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;int64&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-102" title="102"&gt;        &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-103" title="103"&gt;            shape &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;tuple&lt;/span&gt;(shape_reps) &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;tuple&lt;/span&gt;(shape_ind) &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="bu"&gt;tuple&lt;/span&gt;(shape_supp)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-104" title="104"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-105" title="105"&gt;        &lt;span class="co"&gt;# if shape is None:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-106" title="106"&gt;        &lt;span class="co"&gt;#     raise tt.ShapeError()&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-107" title="107"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-108" title="108"&gt;        &lt;span class="cf"&gt;return&lt;/span&gt; shape&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-109" title="109"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-110" title="110"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; make_node(&lt;span class="va"&gt;self&lt;/span&gt;, &lt;span class="op"&gt;*&lt;/span&gt;dist_params, size&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;, rng&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;, name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-111" title="111"&gt;        &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;This will be the &amp;quot;constructor&amp;quot; called by users.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-112" title="112"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-113" title="113"&gt;&lt;span class="co"&gt;        Parameters&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-114" title="114"&gt;&lt;span class="co"&gt;        ==========&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-115" title="115"&gt;&lt;span class="co"&gt;        dist_params: list&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-116" title="116"&gt;&lt;span class="co"&gt;            Distribution parameters.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-117" title="117"&gt;&lt;span class="co"&gt;        size: Iterable or None&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-118" title="118"&gt;&lt;span class="co"&gt;            Numpy-like size of the output (i.e. replications).&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-119" title="119"&gt;&lt;span class="co"&gt;        rng: RandomState or None&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-120" title="120"&gt;&lt;span class="co"&gt;            Existing Theano `RandomState` object to be used.  Creates a&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-121" title="121"&gt;&lt;span class="co"&gt;            new one, if `None`.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-122" title="122"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-123" title="123"&gt;&lt;span class="co"&gt;        Results&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-124" title="124"&gt;&lt;span class="co"&gt;        =======&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-125" title="125"&gt;&lt;span class="co"&gt;        An `Apply` node with rng state and sample tensor outputs.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-126" title="126"&gt;&lt;span class="co"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-127" title="127"&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; (size &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt; &lt;span class="kw"&gt;or&lt;/span&gt; &lt;span class="bu"&gt;isinstance&lt;/span&gt;(size, Iterable)):&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-128" title="128"&gt;            &lt;span class="cf"&gt;raise&lt;/span&gt; &lt;span class="pp"&gt;ValueError&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;Parameter size must be None or iterable&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-129" title="129"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-130" title="130"&gt;        dist_params &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;tuple&lt;/span&gt;(tt.as_tensor_variable(p)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-131" title="131"&gt;                            &lt;span class="cf"&gt;for&lt;/span&gt; p &lt;span class="kw"&gt;in&lt;/span&gt; dist_params)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-132" title="132"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-133" title="133"&gt;        dtype &lt;span class="op"&gt;=&lt;/span&gt; tt.scal.upcast(&lt;span class="va"&gt;self&lt;/span&gt;.dtype, &lt;span class="op"&gt;*&lt;/span&gt;[p.dtype &lt;span class="cf"&gt;for&lt;/span&gt; p &lt;span class="kw"&gt;in&lt;/span&gt; dist_params])&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-134" title="134"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-135" title="135"&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; rng &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-136" title="136"&gt;            rng &lt;span class="op"&gt;=&lt;/span&gt; theano.shared(np.random.RandomState())&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-137" title="137"&gt;        &lt;span class="cf"&gt;elif&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="bu"&gt;isinstance&lt;/span&gt;(rng.&lt;span class="bu"&gt;type&lt;/span&gt;, RandomStateType):&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-138" title="138"&gt;            warn(&lt;span class="st"&gt;&amp;#39;The type of rng should be an instance of RandomStateType&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-139" title="139"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-140" title="140"&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; size &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-141" title="141"&gt;            size &lt;span class="op"&gt;=&lt;/span&gt; tt.constant([], dtype&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;int64&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-142" title="142"&gt;        &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-143" title="143"&gt;            size &lt;span class="op"&gt;=&lt;/span&gt; tt.as_tensor_variable(size, ndim&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-144" title="144"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-145" title="145"&gt;        &lt;span class="cf"&gt;assert&lt;/span&gt; size.dtype &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;int64&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-146" title="146"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-147" title="147"&gt;        shape &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;._infer_shape(size, dist_params)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-148" title="148"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-149" title="149"&gt;        &lt;span class="co"&gt;# Let&amp;#39;s try to do a better job than `_infer_ndim_bcast` when&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-150" title="150"&gt;        &lt;span class="co"&gt;# dimension sizes are symbolic.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-151" title="151"&gt;        bcast &lt;span class="op"&gt;=&lt;/span&gt; []&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-152" title="152"&gt;        &lt;span class="cf"&gt;for&lt;/span&gt; s &lt;span class="kw"&gt;in&lt;/span&gt; shape:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-153" title="153"&gt;            &lt;span class="cf"&gt;try&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-154" title="154"&gt;                &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="bu"&gt;isinstance&lt;/span&gt;(s.owner.op, tt.Subtensor) &lt;span class="kw"&gt;and&lt;/span&gt; &lt;span class="op"&gt;\&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-155" title="155"&gt;                   s.owner.inputs[&lt;span class="dv"&gt;0&lt;/span&gt;].owner &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-156" title="156"&gt;                    &lt;span class="co"&gt;# Handle a special case in which&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-157" title="157"&gt;                    &lt;span class="co"&gt;# `tensor.get_scalar_constant_value` doesn&amp;#39;t really work.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-158" title="158"&gt;                    s_x, s_idx &lt;span class="op"&gt;=&lt;/span&gt; s.owner.inputs&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-159" title="159"&gt;                    s_idx &lt;span class="op"&gt;=&lt;/span&gt; tt.get_scalar_constant_value(s_idx)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-160" title="160"&gt;                    &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="bu"&gt;isinstance&lt;/span&gt;(s_x.owner.op, tt.Shape):&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-161" title="161"&gt;                        x_obj, &lt;span class="op"&gt;=&lt;/span&gt; s_x.owner.inputs&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-162" title="162"&gt;                        s_val &lt;span class="op"&gt;=&lt;/span&gt; x_obj.&lt;span class="bu"&gt;type&lt;/span&gt;.broadcastable[s_idx]&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-163" title="163"&gt;                    &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-164" title="164"&gt;                        &lt;span class="co"&gt;# &lt;/span&gt;&lt;span class="al"&gt;TODO&lt;/span&gt;&lt;span class="co"&gt;: Could go for an existing broadcastable here, too, no?&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-165" title="165"&gt;                        s_val &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;False&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-166" title="166"&gt;                &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-167" title="167"&gt;                    s_val &lt;span class="op"&gt;=&lt;/span&gt; tt.get_scalar_constant_value(s)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-168" title="168"&gt;            &lt;span class="cf"&gt;except&lt;/span&gt; tt.NotScalarConstantError:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-169" title="169"&gt;                s_val &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;False&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-170" title="170"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-171" title="171"&gt;            bcast &lt;span class="op"&gt;+=&lt;/span&gt; [s_val &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-172" title="172"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-173" title="173"&gt;        outtype &lt;span class="op"&gt;=&lt;/span&gt; tt.TensorType(dtype&lt;span class="op"&gt;=&lt;/span&gt;dtype, broadcastable&lt;span class="op"&gt;=&lt;/span&gt;bcast)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-174" title="174"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-175" title="175"&gt;        out_var &lt;span class="op"&gt;=&lt;/span&gt; outtype(name&lt;span class="op"&gt;=&lt;/span&gt;name)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-176" title="176"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-177" title="177"&gt;        inputs &lt;span class="op"&gt;=&lt;/span&gt; (rng, size) &lt;span class="op"&gt;+&lt;/span&gt; dist_params&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-178" title="178"&gt;        outputs &lt;span class="op"&gt;=&lt;/span&gt; (rng.&lt;span class="bu"&gt;type&lt;/span&gt;(), out_var)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-179" title="179"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-180" title="180"&gt;        &lt;span class="cf"&gt;return&lt;/span&gt; theano.gof.Apply(&lt;span class="va"&gt;self&lt;/span&gt;, inputs, outputs)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-181" title="181"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-182" title="182"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; infer_shape(&lt;span class="va"&gt;self&lt;/span&gt;, node, input_shapes):&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-183" title="183"&gt;        size &lt;span class="op"&gt;=&lt;/span&gt; node.inputs[&lt;span class="dv"&gt;1&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-184" title="184"&gt;        dist_params &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;tuple&lt;/span&gt;(node.inputs[&lt;span class="dv"&gt;2&lt;/span&gt;:])&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-185" title="185"&gt;        shape &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;._infer_shape(size, dist_params,&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-186" title="186"&gt;                                  param_shapes&lt;span class="op"&gt;=&lt;/span&gt;input_shapes[&lt;span class="dv"&gt;2&lt;/span&gt;:])&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-187" title="187"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-188" title="188"&gt;        &lt;span class="cf"&gt;return&lt;/span&gt; [&lt;span class="va"&gt;None&lt;/span&gt;, [s &lt;span class="cf"&gt;for&lt;/span&gt; s &lt;span class="kw"&gt;in&lt;/span&gt; shape]]&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-189" title="189"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-190" title="190"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; perform(&lt;span class="va"&gt;self&lt;/span&gt;, node, inputs, outputs):&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-191" title="191"&gt;        &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Uses `self.rng_fn` to draw random numbers.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-192" title="192"&gt;        rng_out, smpl_out &lt;span class="op"&gt;=&lt;/span&gt; outputs&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-193" title="193"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-194" title="194"&gt;        &lt;span class="co"&gt;# Draw from `rng` if `self.inplace` is `True`, and from a&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-195" title="195"&gt;        &lt;span class="co"&gt;# copy of `rng` otherwise.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-196" title="196"&gt;        rng, size, args &lt;span class="op"&gt;=&lt;/span&gt; inputs[&lt;span class="dv"&gt;0&lt;/span&gt;], inputs[&lt;span class="dv"&gt;1&lt;/span&gt;], inputs[&lt;span class="dv"&gt;2&lt;/span&gt;:]&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-197" title="197"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-198" title="198"&gt;        &lt;span class="cf"&gt;assert&lt;/span&gt; &lt;span class="bu"&gt;type&lt;/span&gt;(rng) &lt;span class="op"&gt;==&lt;/span&gt; np.random.RandomState, (&lt;span class="bu"&gt;type&lt;/span&gt;(rng), rng)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-199" title="199"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-200" title="200"&gt;        rng_out[&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; rng&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-201" title="201"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-202" title="202"&gt;        &lt;span class="co"&gt;# The symbolic output variable corresponding to value produced here.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-203" title="203"&gt;        out_var &lt;span class="op"&gt;=&lt;/span&gt; node.outputs[&lt;span class="dv"&gt;1&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-204" title="204"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-205" title="205"&gt;        &lt;span class="co"&gt;# If `size == []`, that means no size is enforced, and NumPy is&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-206" title="206"&gt;        &lt;span class="co"&gt;# trusted to draw the appropriate number of samples, NumPy uses&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-207" title="207"&gt;        &lt;span class="co"&gt;# `size=None` to represent that.  Otherwise, NumPy expects a tuple.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-208" title="208"&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; np.size(size) &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-209" title="209"&gt;            size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-210" title="210"&gt;        &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-211" title="211"&gt;            size &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;tuple&lt;/span&gt;(size)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-212" title="212"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-213" title="213"&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.inplace:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-214" title="214"&gt;            rng &lt;span class="op"&gt;=&lt;/span&gt; copy(rng)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-215" title="215"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-216" title="216"&gt;        smpl_val &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.rng_fn(rng, &lt;span class="op"&gt;*&lt;/span&gt;(args &lt;span class="op"&gt;+&lt;/span&gt; [size]))&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-217" title="217"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-218" title="218"&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; (&lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="bu"&gt;isinstance&lt;/span&gt;(smpl_val, np.ndarray) &lt;span class="kw"&gt;or&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-219" title="219"&gt;            &lt;span class="bu"&gt;str&lt;/span&gt;(smpl_val.dtype) &lt;span class="op"&gt;!=&lt;/span&gt; out_var.&lt;span class="bu"&gt;type&lt;/span&gt;.dtype):&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-220" title="220"&gt;            smpl_val &lt;span class="op"&gt;=&lt;/span&gt; theano._asarray(smpl_val, dtype&lt;span class="op"&gt;=&lt;/span&gt;out_var.&lt;span class="bu"&gt;type&lt;/span&gt;.dtype)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-221" title="221"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-222" title="222"&gt;        &lt;span class="co"&gt;# When `size` is `None`, NumPy has a tendency to unexpectedly&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-223" title="223"&gt;        &lt;span class="co"&gt;# return a scalar instead of a higher-dimension array containing&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-224" title="224"&gt;        &lt;span class="co"&gt;# only one element. This value should be reshaped&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-225" title="225"&gt;        &lt;span class="co"&gt;# &lt;/span&gt;&lt;span class="al"&gt;TODO&lt;/span&gt;&lt;span class="co"&gt;: Really?  Why shouldn&amp;#39;t the output correctly correspond to&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-226" title="226"&gt;        &lt;span class="co"&gt;# the returned NumPy value?  Sounds more like a mis-specification of&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-227" title="227"&gt;        &lt;span class="co"&gt;# the symbolic output variable.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-228" title="228"&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; size &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt; &lt;span class="kw"&gt;and&lt;/span&gt; smpl_val.ndim &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="kw"&gt;and&lt;/span&gt; out_var.ndim &lt;span class="op"&gt;&amp;gt;&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-229" title="229"&gt;            smpl_val &lt;span class="op"&gt;=&lt;/span&gt; smpl_val.reshape([&lt;span class="dv"&gt;1&lt;/span&gt;] &lt;span class="op"&gt;*&lt;/span&gt; out_var.ndim)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-230" title="230"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-231" title="231"&gt;        smpl_out[&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; smpl_val&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-232" title="232"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-233" title="233"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; grad(&lt;span class="va"&gt;self&lt;/span&gt;, inputs, outputs):&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-234" title="234"&gt;        &lt;span class="cf"&gt;return&lt;/span&gt; [theano.gradient.grad_undefined(&lt;span class="va"&gt;self&lt;/span&gt;, k, inp,&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-235" title="235"&gt;                                               &lt;span class="st"&gt;&amp;#39;No gradient defined through raw random numbers op&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-236" title="236"&gt;                &lt;span class="cf"&gt;for&lt;/span&gt; k, inp &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(inputs)]&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-237" title="237"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-238" title="238"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; R_op(&lt;span class="va"&gt;self&lt;/span&gt;, inputs, eval_points):&lt;/a&gt;
&lt;a class="sourceLine" id="new_rv_op-239" title="239"&gt;        &lt;span class="cf"&gt;return&lt;/span&gt; [&lt;span class="va"&gt;None&lt;/span&gt; &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; eval_points]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="example" data-markdown=""&gt;
&lt;p&gt;Here are some examples of &lt;code&gt;RandomVariable&lt;/code&gt; in action.&lt;/p&gt;
&lt;div class="sourceCode" id="random_variable_example"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="random_variable_example-1" title="1"&gt;NormalRV &lt;span class="op"&gt;=&lt;/span&gt; RandomVariable(&lt;span class="st"&gt;&amp;#39;normal&amp;#39;&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;, [&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;], &lt;span class="st"&gt;&amp;#39;normal&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="random_variable_example-2" title="2"&gt;MvNormalRV &lt;span class="op"&gt;=&lt;/span&gt; RandomVariable(&lt;span class="st"&gt;&amp;#39;multivariate_normal&amp;#39;&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;, [&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;], &lt;span class="st"&gt;&amp;#39;multivariate_normal&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="random_variable_example-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="random_variable_example-4" title="4"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;NormalRV([0., 100.], 30, size=[4, 2]):&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(&lt;/a&gt;
&lt;a class="sourceLine" id="random_variable_example-5" title="5"&gt;    NormalRV([&lt;span class="fl"&gt;0.&lt;/span&gt;, &lt;span class="fl"&gt;100.&lt;/span&gt;], &lt;span class="dv"&gt;30&lt;/span&gt;, size&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;4&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;]).&lt;span class="bu"&gt;eval&lt;/span&gt;()))&lt;/a&gt;
&lt;a class="sourceLine" id="random_variable_example-6" title="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="random_variable_example-7" title="7"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;MvNormalRV([0, 1e2, 2e3], np.diag([1, 1, 1]), size=[3, 2, 3]):&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(&lt;/a&gt;
&lt;a class="sourceLine" id="random_variable_example-8" title="8"&gt;    MvNormalRV([&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="fl"&gt;1e2&lt;/span&gt;, &lt;span class="fl"&gt;2e3&lt;/span&gt;], np.diag([&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;]), size&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;]).&lt;span class="bu"&gt;eval&lt;/span&gt;()))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb3-1" title="1"&gt;NormalRV([&lt;span class="fl"&gt;0.&lt;/span&gt;, &lt;span class="fl"&gt;100.&lt;/span&gt;], &lt;span class="dv"&gt;30&lt;/span&gt;, size&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;4&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;]):&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" title="2"&gt;[[ &lt;span class="fl"&gt;27.43632901&lt;/span&gt;  &lt;span class="fl"&gt;93.39441318&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" title="3"&gt; [ &lt;span class="fl"&gt;15.85959218&lt;/span&gt; &lt;span class="fl"&gt;133.70107347&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" title="4"&gt; [ &lt;span class="fl"&gt;-9.36097104&lt;/span&gt;  &lt;span class="fl"&gt;68.13953575&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" title="5"&gt; [ &lt;span class="fl"&gt;13.41389074&lt;/span&gt; &lt;span class="fl"&gt;102.36908493&lt;/span&gt;]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" title="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" title="7"&gt;MvNormalRV([&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="fl"&gt;1e2&lt;/span&gt;, &lt;span class="fl"&gt;2e3&lt;/span&gt;], np.diag([&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;]), size&lt;span class="op"&gt;=&lt;/span&gt;[&lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;]):&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" title="8"&gt;[[[[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;1.95386446e+00&lt;/span&gt;  &lt;span class="fl"&gt;1.00395353e+02&lt;/span&gt;  &lt;span class="fl"&gt;2.00061885e+03&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" title="9"&gt;   [ &lt;span class="fl"&gt;1.05345467e-02&lt;/span&gt;  &lt;span class="fl"&gt;1.00488854e+02&lt;/span&gt;  &lt;span class="fl"&gt;2.00075391e+03&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" title="10"&gt;   [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;2.96094820e-01&lt;/span&gt;  &lt;span class="fl"&gt;9.97791115e+01&lt;/span&gt;  &lt;span class="fl"&gt;2.00039472e+03&lt;/span&gt;]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-11" title="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-12" title="12"&gt;  [[ &lt;span class="fl"&gt;1.09725296e+00&lt;/span&gt;  &lt;span class="fl"&gt;1.00481658e+02&lt;/span&gt;  &lt;span class="fl"&gt;2.00168402e+03&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-13" title="13"&gt;   [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;5.97706814e-01&lt;/span&gt;  &lt;span class="fl"&gt;9.84007224e+01&lt;/span&gt;  &lt;span class="fl"&gt;1.99998250e+03&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-14" title="14"&gt;   [ &lt;span class="fl"&gt;6.05551705e-01&lt;/span&gt;  &lt;span class="fl"&gt;1.00905256e+02&lt;/span&gt;  &lt;span class="fl"&gt;1.99904533e+03&lt;/span&gt;]]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-15" title="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-16" title="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-17" title="17"&gt; [[[ &lt;span class="fl"&gt;3.13777265e-01&lt;/span&gt;  &lt;span class="fl"&gt;9.73407662e+01&lt;/span&gt;  &lt;span class="fl"&gt;1.99854117e+03&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-18" title="18"&gt;   [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;8.54227150e-01&lt;/span&gt;  &lt;span class="fl"&gt;1.01332597e+02&lt;/span&gt;  &lt;span class="fl"&gt;1.99945623e+03&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-19" title="19"&gt;   [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;4.71493054e-01&lt;/span&gt;  &lt;span class="fl"&gt;9.98134334e+01&lt;/span&gt;  &lt;span class="fl"&gt;2.00121111e+03&lt;/span&gt;]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-20" title="20"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-21" title="21"&gt;  [[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;3.61516595e-01&lt;/span&gt;  &lt;span class="fl"&gt;9.99772061e+01&lt;/span&gt;  &lt;span class="fl"&gt;1.99853933e+03&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-22" title="22"&gt;   [ &lt;span class="fl"&gt;5.17271791e-01&lt;/span&gt;  &lt;span class="fl"&gt;9.74970520e+01&lt;/span&gt;  &lt;span class="fl"&gt;2.00052296e+03&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-23" title="23"&gt;   [ &lt;span class="fl"&gt;2.15904894e-01&lt;/span&gt;  &lt;span class="fl"&gt;9.99694385e+01&lt;/span&gt;  &lt;span class="fl"&gt;2.00021462e+03&lt;/span&gt;]]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-24" title="24"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-25" title="25"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-26" title="26"&gt; [[[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;9.61903721e-01&lt;/span&gt;  &lt;span class="fl"&gt;1.00569645e+02&lt;/span&gt;  &lt;span class="fl"&gt;1.99858826e+03&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-27" title="27"&gt;   [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;6.72526622e-01&lt;/span&gt;  &lt;span class="fl"&gt;1.00277177e+02&lt;/span&gt;  &lt;span class="fl"&gt;2.00036283e+03&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-28" title="28"&gt;   [ &lt;span class="fl"&gt;2.58608351e-01&lt;/span&gt;  &lt;span class="fl"&gt;1.01020520e+02&lt;/span&gt;  &lt;span class="fl"&gt;1.99866678e+03&lt;/span&gt;]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-29" title="29"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-30" title="30"&gt;  [[ &lt;span class="fl"&gt;8.70002780e-02&lt;/span&gt;  &lt;span class="fl"&gt;1.01020608e+02&lt;/span&gt;  &lt;span class="fl"&gt;1.99975983e+03&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-31" title="31"&gt;   [ &lt;span class="fl"&gt;8.56671014e-01&lt;/span&gt;  &lt;span class="fl"&gt;9.97595247e+01&lt;/span&gt;  &lt;span class="fl"&gt;2.00094824e+03&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-32" title="32"&gt;   [ &lt;span class="fl"&gt;6.17426596e-01&lt;/span&gt;  &lt;span class="fl"&gt;1.01919972e+02&lt;/span&gt;  &lt;span class="fl"&gt;1.99914348e+03&lt;/span&gt;]]]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-33" title="33"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;As we’ve mentioned, there are a few difficulties surrounding the use and determination of shape information in PyMC3. &lt;code&gt;RandomVariable&lt;/code&gt; doesn’t suffer the same limitations.&lt;/p&gt;
&lt;div class="example" data-markdown="" data-title-name=""&gt;
&lt;p&gt;A multivariate normal random variable cannot be created without explicit shape information.&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb4-1" title="1"&gt;&lt;span class="im"&gt;import&lt;/span&gt; traceback&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" title="3"&gt;test_mean &lt;span class="op"&gt;=&lt;/span&gt; tt.vector(&lt;span class="st"&gt;&amp;#39;test_mean&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" title="4"&gt;test_mean.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.asarray([&lt;span class="dv"&gt;1&lt;/span&gt;])&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-6" title="6"&gt;test_cov &lt;span class="op"&gt;=&lt;/span&gt; tt.matrix(&lt;span class="st"&gt;&amp;#39;test_cov&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-7" title="7"&gt;test_cov.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.asarray([[&lt;span class="dv"&gt;1&lt;/span&gt;]])&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-8" title="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-9" title="9"&gt;&lt;span class="cf"&gt;try&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-10" title="10"&gt;  &lt;span class="cf"&gt;with&lt;/span&gt; pm.Model():&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-11" title="11"&gt;    test_rv &lt;span class="op"&gt;=&lt;/span&gt; pm.MvNormal(&lt;span class="st"&gt;&amp;#39;test_rv&amp;#39;&lt;/span&gt;, test_mean, test_cov)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-12" title="12"&gt;&lt;span class="cf"&gt;except&lt;/span&gt; &lt;span class="pp"&gt;Exception&lt;/span&gt; &lt;span class="im"&gt;as&lt;/span&gt; e:&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-13" title="13"&gt;  &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt;.join(traceback.format_exception_only(&lt;span class="bu"&gt;type&lt;/span&gt;(e), e)))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb5-1" title="1"&gt;&lt;span class="pp"&gt;ValueError&lt;/span&gt;: Invalid dimension &lt;span class="cf"&gt;for&lt;/span&gt; value: &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" title="2"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb6-1" title="1"&gt;&lt;span class="cf"&gt;try&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" title="2"&gt;  &lt;span class="cf"&gt;with&lt;/span&gt; pm.Model():&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" title="3"&gt;    test_rv &lt;span class="op"&gt;=&lt;/span&gt; pm.MvNormal(&lt;span class="st"&gt;&amp;#39;test_rv&amp;#39;&lt;/span&gt;, test_mean, test_cov, shape&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" title="4"&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;test_rv.distribution.shape = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(test_rv.distribution.shape))&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" title="5"&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;test_rv.tag.test_value = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(test_rv.tag.test_value))&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" title="6"&gt;&lt;span class="cf"&gt;except&lt;/span&gt; &lt;span class="pp"&gt;Exception&lt;/span&gt; &lt;span class="im"&gt;as&lt;/span&gt; e:&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" title="7"&gt;  &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt;.join(traceback.format_exception_only(&lt;span class="bu"&gt;type&lt;/span&gt;(e), e)))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb7-1" title="1"&gt;test_rv.distribution.shape &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="dv"&gt;1&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" title="2"&gt;test_rv.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="fl"&gt;1.&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" title="3"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using &lt;code&gt;RandomVariable&lt;/code&gt;, we do not have to specify a shape, nor implement any sampling code outside of &lt;code&gt;RandomVariable.perform&lt;/code&gt; to draw random variables and generate valid test values.&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb8-1" title="1"&gt;test_mv_rv &lt;span class="op"&gt;=&lt;/span&gt; MvNormalRV(test_mean, test_cov)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" title="2"&gt;test_mv_rv_2 &lt;span class="op"&gt;=&lt;/span&gt; MvNormalRV(test_mv_rv, test_cov)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" title="4"&gt;&lt;span class="co"&gt;# Observe the automatically generated test values&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" title="5"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;test_mv_rv.tag.test_value = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(test_mv_rv.tag.test_value))&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" title="6"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;test_mv_rv_2.tag.test_value = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(test_mv_rv_2.tag.test_value))&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" title="8"&gt;&lt;span class="co"&gt;# Sample some values under specific parameter values&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-9" title="9"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;test_mv_rv.eval() = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(test_mv_rv.&lt;span class="bu"&gt;eval&lt;/span&gt;(&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-10" title="10"&gt;    {test_mean: [&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;], test_cov: np.diag([&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;])})))&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-11" title="11"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;test_mv_rv_2.eval() = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(test_mv_rv_2.&lt;span class="bu"&gt;eval&lt;/span&gt;(&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-12" title="12"&gt;    {test_mean: [&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;], test_cov: np.diag([&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="dv"&gt;70&lt;/span&gt;])})))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb9-1" title="1"&gt;test_mv_rv.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="fl"&gt;0.90661799&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" title="2"&gt;test_mv_rv_2.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="fl"&gt;1.10201953&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" title="3"&gt;test_mv_rv.&lt;span class="bu"&gt;eval&lt;/span&gt;() &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;1.90184227&lt;/span&gt;  &lt;span class="fl"&gt;1.8679379&lt;/span&gt; ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" title="4"&gt;test_mv_rv_2.&lt;span class="bu"&gt;eval&lt;/span&gt;() &lt;span class="op"&gt;=&lt;/span&gt; [ &lt;span class="fl"&gt;2.05659828&lt;/span&gt; &lt;span class="fl"&gt;-1.33638943&lt;/span&gt;  &lt;span class="fl"&gt;3.85355663&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" title="5"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="a-problem-with-pymc3-broadcast-dimensions" class="level1"&gt;
&lt;h1&gt;A Problem with PyMC3 Broadcast Dimensions&lt;/h1&gt;
&lt;p&gt;As in &lt;sup id="24875a2c31fa7f94ce562adddedc0bf8"&gt;&lt;a href="#WillardSymbolicMathPyMC32018" title="@misc{WillardSymbolicMathPyMC32018, title = {Symbolic {{Math}} in {{PyMC3}}}, urldate = {2018-12-27}, url = {https://brandonwillard.github.io/symbolic-math-in-pymc3.html}, author = {Willard, Brandon T.}, month = dec, year = {2018}, file = {/home/bwillard/Zotero/storage/6VVT4UNF/symbolic-math-in-pymc3.html} }"&gt;WillardSymbolicMathPyMC32018&lt;/a&gt;&lt;/sup&gt;, we can create mappings between existing PyMC3 random variables and their new &lt;code&gt;RandomVariable&lt;/code&gt; equivalents.&lt;/p&gt;
&lt;div class="sourceCode" id="pymc_theano_rv_equivs"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="pymc_theano_rv_equivs-1" title="1"&gt;pymc_theano_rv_equivs &lt;span class="op"&gt;=&lt;/span&gt; {&lt;/a&gt;
&lt;a class="sourceLine" id="pymc_theano_rv_equivs-2" title="2"&gt;    pm.Normal:&lt;/a&gt;
&lt;a class="sourceLine" id="pymc_theano_rv_equivs-3" title="3"&gt;    &lt;span class="kw"&gt;lambda&lt;/span&gt; dist, rand_state:&lt;/a&gt;
&lt;a class="sourceLine" id="pymc_theano_rv_equivs-4" title="4"&gt;    (&lt;span class="va"&gt;None&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="pymc_theano_rv_equivs-5" title="5"&gt;     &lt;span class="co"&gt;# PyMC3 shapes aren&amp;#39;t NumPy-like size parameters, so we attempt to&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="pymc_theano_rv_equivs-6" title="6"&gt;     &lt;span class="co"&gt;# adjust for that.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="pymc_theano_rv_equivs-7" title="7"&gt;     NormalRV(dist.mu, dist.sd, size&lt;span class="op"&gt;=&lt;/span&gt;dist.shape[&lt;span class="dv"&gt;1&lt;/span&gt;:], rng&lt;span class="op"&gt;=&lt;/span&gt;rand_state)),&lt;/a&gt;
&lt;a class="sourceLine" id="pymc_theano_rv_equivs-8" title="8"&gt;    pm.MvNormal:&lt;/a&gt;
&lt;a class="sourceLine" id="pymc_theano_rv_equivs-9" title="9"&gt;    &lt;span class="kw"&gt;lambda&lt;/span&gt; dist, rand_state:&lt;/a&gt;
&lt;a class="sourceLine" id="pymc_theano_rv_equivs-10" title="10"&gt;    (&lt;span class="va"&gt;None&lt;/span&gt;, NormalRV(dist.mu, dist.cov, size&lt;span class="op"&gt;=&lt;/span&gt;dist.shape[&lt;span class="dv"&gt;1&lt;/span&gt;:], rng&lt;span class="op"&gt;=&lt;/span&gt;rand_state)),&lt;/a&gt;
&lt;a class="sourceLine" id="pymc_theano_rv_equivs-11" title="11"&gt;}&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, if we attempt the same PymC3 graph conversion approach as before (i.e. convert a PyMC3 model to a Theano &lt;code&gt;FunctionGraph&lt;/code&gt; using &lt;code&gt;model_graph&lt;/code&gt;, then replace PyMC3 random variable nodes with our new random variable types using &lt;code&gt;create_theano_rvs&lt;/code&gt;), we’re likely to run into a problem involving mismatching broadcastable dimensions.&lt;/p&gt;
&lt;p&gt;The problem arises because &lt;strong&gt;PyMC3 “knows” more broadcast information than it should&lt;/strong&gt;, since it uses the Theano variables’ test values in order to obtain concrete shapes for the random variables it creates. Using concrete, non-symbolic shapes, it can exactly determine what would otherwise be ambiguous &lt;a href="http://deeplearning.net/software/theano/library/tensor/basic.html?highlight=broadcastable#theano.tensor.TensorType.broadcastable"&gt;broadcastable dimensions&lt;/a&gt; at the symbolic level.&lt;/p&gt;
&lt;p&gt;More specifically, broadcast information is required during the construction of a Theano &lt;code&gt;TensorType&lt;/code&gt;, so PyMC3 random variable types can be inconsistent (unnecessarily restrictive, really) causing Theano to complain when we try to construct a &lt;code&gt;FunctionGraph&lt;/code&gt;.&lt;/p&gt;
&lt;div class="example" data-markdown=""&gt;
&lt;p&gt;Consider the following example; it constructs two purely symbolic Theano vectors: one with broadcasting and one without.&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb10-1" title="1"&gt;y_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.row(&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" title="2"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;y_tt.broadcastable = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(y_tt.broadcastable))&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" title="3"&gt;x_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.matrix(&lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" title="4"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;x_tt.broadcastable = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(x_tt.broadcastable))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb11-1" title="1"&gt;y_tt.broadcastable &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="va"&gt;True&lt;/span&gt;, &lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" title="2"&gt;x_tt.broadcastable &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="va"&gt;False&lt;/span&gt;, &lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" title="3"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice that it–by default–signifies no broadcasting on its first and only dimension.&lt;/p&gt;
&lt;p&gt;If we wish–or if &lt;a href="http://deeplearning.net/software/theano/library/config.html#config.compute_test_value"&gt;Theano’s configuration demands&lt;/a&gt; it–we can assign the symbolic vector arbitrary test values, as long as they’re consistent with its type (i.e. a vector, or 1-dimensional array).&lt;/p&gt;
&lt;p&gt;In the following, we assign both a broadcastable (i.e. first–and only–dimension has size 1) and non-broadcastable test value.&lt;/p&gt;
&lt;p&gt;Test value is broadcastable:&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb12-1" title="1"&gt;x_tt.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([[&lt;span class="dv"&gt;5&lt;/span&gt;]])&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" title="2"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;test_value.broadcastable = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" title="3"&gt;    tt.as_tensor_variable(x_tt.tag.test_value).broadcastable))&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" title="4"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;x_tt.broadcastable = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(x_tt.broadcastable))&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-6" title="6"&gt;&lt;span class="co"&gt;# Compute this to run internal checks&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-7" title="7"&gt;&lt;span class="cf"&gt;try&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-8" title="8"&gt;    x_tt.shape&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-9" title="9"&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;shape checks out!&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-10" title="10"&gt;&lt;span class="cf"&gt;except&lt;/span&gt; &lt;span class="pp"&gt;TypeError&lt;/span&gt; &lt;span class="im"&gt;as&lt;/span&gt; e:&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-11" title="11"&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="bu"&gt;str&lt;/span&gt;(e))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb13-1" title="1"&gt;test_value.broadcastable &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="va"&gt;True&lt;/span&gt;, &lt;span class="va"&gt;True&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" title="2"&gt;x_tt.broadcastable &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="va"&gt;False&lt;/span&gt;, &lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" title="3"&gt;shape checks out&lt;span class="op"&gt;!&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" title="4"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb14-1" title="1"&gt;y_tt.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([[&lt;span class="dv"&gt;5&lt;/span&gt;]])&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" title="2"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;test_value.broadcastable = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" title="3"&gt;    tt.as_tensor_variable(y_tt.tag.test_value).broadcastable))&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" title="4"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;y_tt.broadcastable = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(y_tt.broadcastable))&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-6" title="6"&gt;&lt;span class="co"&gt;# Compute this to run internal checks&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-7" title="7"&gt;&lt;span class="cf"&gt;try&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-8" title="8"&gt;    y_tt.shape&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-9" title="9"&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;shape checks out!&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-10" title="10"&gt;&lt;span class="cf"&gt;except&lt;/span&gt; &lt;span class="pp"&gt;TypeError&lt;/span&gt; &lt;span class="im"&gt;as&lt;/span&gt; e:&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-11" title="11"&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="bu"&gt;str&lt;/span&gt;(e))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb15-1" title="1"&gt;test_value.broadcastable &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="va"&gt;True&lt;/span&gt;, &lt;span class="va"&gt;True&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" title="2"&gt;y_tt.broadcastable &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="va"&gt;True&lt;/span&gt;, &lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" title="3"&gt;shape checks out&lt;span class="op"&gt;!&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" title="4"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Test value is &lt;strong&gt;not&lt;/strong&gt; broadcastable:&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb16-1" title="1"&gt;x_tt.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([[&lt;span class="dv"&gt;5&lt;/span&gt;, &lt;span class="dv"&gt;4&lt;/span&gt;]])&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" title="2"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;test_value.broadcastable = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-3" title="3"&gt;    tt.as_tensor_variable(x_tt.tag.test_value).broadcastable))&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-4" title="4"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;x_tt.broadcastable = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(x_tt.broadcastable))&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-6" title="6"&gt;&lt;span class="co"&gt;# Compute this to run internal checks&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-7" title="7"&gt;&lt;span class="cf"&gt;try&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-8" title="8"&gt;    x_tt.shape&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-9" title="9"&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;shape checks out!&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-10" title="10"&gt;&lt;span class="cf"&gt;except&lt;/span&gt; &lt;span class="pp"&gt;TypeError&lt;/span&gt; &lt;span class="im"&gt;as&lt;/span&gt; e:&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-11" title="11"&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="bu"&gt;str&lt;/span&gt;(e))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb17-1" title="1"&gt;test_value.broadcastable &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="va"&gt;True&lt;/span&gt;, &lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-2" title="2"&gt;x_tt.broadcastable &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="va"&gt;False&lt;/span&gt;, &lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-3" title="3"&gt;shape checks out&lt;span class="op"&gt;!&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb17-4" title="4"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb18-1" title="1"&gt;y_tt.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([[&lt;span class="dv"&gt;5&lt;/span&gt;, &lt;span class="dv"&gt;4&lt;/span&gt;], [&lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;]])&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-2" title="2"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;test_value.broadcastable = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-3" title="3"&gt;    tt.as_tensor_variable(y_tt.tag.test_value).broadcastable))&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-4" title="4"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;y_tt.broadcastable = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;quot;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(y_tt.broadcastable))&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-6" title="6"&gt;&lt;span class="co"&gt;# Compute this to run internal checks&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-7" title="7"&gt;&lt;span class="cf"&gt;try&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-8" title="8"&gt;    y_tt.shape&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-9" title="9"&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;shape checks out!&amp;quot;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-10" title="10"&gt;&lt;span class="cf"&gt;except&lt;/span&gt; &lt;span class="pp"&gt;TypeError&lt;/span&gt; &lt;span class="im"&gt;as&lt;/span&gt; e:&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-11" title="11"&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="bu"&gt;str&lt;/span&gt;(e))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb19-1" title="1"&gt;test_value.broadcastable &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="va"&gt;False&lt;/span&gt;, &lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-2" title="2"&gt;y_tt.broadcastable &lt;span class="op"&gt;=&lt;/span&gt; (&lt;span class="va"&gt;True&lt;/span&gt;, &lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-3" title="3"&gt;For compute_test_value, one &lt;span class="bu"&gt;input&lt;/span&gt; test value does &lt;span class="kw"&gt;not&lt;/span&gt; have the requested &lt;span class="bu"&gt;type&lt;/span&gt;.&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-5" title="5"&gt;Backtrace when that variable &lt;span class="kw"&gt;is&lt;/span&gt; created:&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-6" title="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-7" title="7"&gt;  File &lt;span class="st"&gt;&amp;quot;/home/bwillard/apps/anaconda3/envs/github-website/lib/python3.6/site-packages/IPython/terminal/interactiveshell.py&amp;quot;&lt;/span&gt;, line &lt;span class="dv"&gt;485&lt;/span&gt;, &lt;span class="kw"&gt;in&lt;/span&gt; mainloop&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-8" title="8"&gt;    &lt;span class="va"&gt;self&lt;/span&gt;.interact()&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-9" title="9"&gt;  File &lt;span class="st"&gt;&amp;quot;/home/bwillard/apps/anaconda3/envs/github-website/lib/python3.6/site-packages/IPython/terminal/interactiveshell.py&amp;quot;&lt;/span&gt;, line &lt;span class="dv"&gt;476&lt;/span&gt;, &lt;span class="kw"&gt;in&lt;/span&gt; interact&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-10" title="10"&gt;    &lt;span class="va"&gt;self&lt;/span&gt;.run_cell(code, store_history&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-11" title="11"&gt;  File &lt;span class="st"&gt;&amp;quot;/home/bwillard/apps/anaconda3/envs/github-website/lib/python3.6/site-packages/IPython/core/interactiveshell.py&amp;quot;&lt;/span&gt;, line &lt;span class="dv"&gt;2662&lt;/span&gt;, &lt;span class="kw"&gt;in&lt;/span&gt; run_cell&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-12" title="12"&gt;    raw_cell, store_history, silent, shell_futures)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-13" title="13"&gt;  File &lt;span class="st"&gt;&amp;quot;/home/bwillard/apps/anaconda3/envs/github-website/lib/python3.6/site-packages/IPython/core/interactiveshell.py&amp;quot;&lt;/span&gt;, line &lt;span class="dv"&gt;2785&lt;/span&gt;, &lt;span class="kw"&gt;in&lt;/span&gt; _run_cell&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-14" title="14"&gt;    interactivity&lt;span class="op"&gt;=&lt;/span&gt;interactivity, compiler&lt;span class="op"&gt;=&lt;/span&gt;compiler, result&lt;span class="op"&gt;=&lt;/span&gt;result)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-15" title="15"&gt;  File &lt;span class="st"&gt;&amp;quot;/home/bwillard/apps/anaconda3/envs/github-website/lib/python3.6/site-packages/IPython/core/interactiveshell.py&amp;quot;&lt;/span&gt;, line &lt;span class="dv"&gt;2909&lt;/span&gt;, &lt;span class="kw"&gt;in&lt;/span&gt; run_ast_nodes&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-16" title="16"&gt;    &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.run_code(code, result):&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-17" title="17"&gt;  File &lt;span class="st"&gt;&amp;quot;/home/bwillard/apps/anaconda3/envs/github-website/lib/python3.6/site-packages/IPython/core/interactiveshell.py&amp;quot;&lt;/span&gt;, line &lt;span class="dv"&gt;2963&lt;/span&gt;, &lt;span class="kw"&gt;in&lt;/span&gt; run_code&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-18" title="18"&gt;    &lt;span class="bu"&gt;exec&lt;/span&gt;(code_obj, &lt;span class="va"&gt;self&lt;/span&gt;.user_global_ns, &lt;span class="va"&gt;self&lt;/span&gt;.user_ns)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-19" title="19"&gt;  File &lt;span class="st"&gt;&amp;quot;&amp;lt;ipython-input-163-7eec6ac09cb0&amp;gt;&amp;quot;&lt;/span&gt;, line &lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;module&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-20" title="20"&gt;    __org_babel_python_fname &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;/tmp/user/1000/babel-f5w2XO/python-Cjuz3L&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;;&lt;/span&gt; __org_babel_python_fh &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;open&lt;/span&gt;(__org_babel_python_fname)&lt;span class="op"&gt;;&lt;/span&gt; &lt;span class="bu"&gt;exec&lt;/span&gt;(&lt;span class="bu"&gt;compile&lt;/span&gt;(__org_babel_python_fh.read(), __org_babel_python_fname, &lt;span class="st"&gt;&amp;#39;exec&amp;#39;&lt;/span&gt;))&lt;span class="op"&gt;;&lt;/span&gt; __org_babel_python_fh.close()&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-21" title="21"&gt;  File &lt;span class="st"&gt;&amp;quot;/tmp/user/1000/babel-f5w2XO/python-Cjuz3L&amp;quot;&lt;/span&gt;, line &lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;module&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-22" title="22"&gt;    y_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.row(&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-23" title="23"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-24" title="24"&gt;The error when converting the test value to that variable &lt;span class="bu"&gt;type&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-25" title="25"&gt;Non&lt;span class="op"&gt;-&lt;/span&gt;unit value on shape on a broadcastable dimension.&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-26" title="26"&gt;(&lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-27" title="27"&gt;(&lt;span class="va"&gt;True&lt;/span&gt;, &lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-28" title="28"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Simply put: non-broadcastable Theano tensor variable types can take broadcastable and non-broadcastable values, while broadcastable types can only take broadcastable values.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;What we can take from the example above is that if we determine that a vector has broadcastable dimensions using test values–as PyMC3 does–we unnecessarily introduce restrictions and potential inconsistencies down the line. One point of origin for such issues is &lt;strong&gt;shared variables&lt;/strong&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="optimizations-using-randomvariable" class="level1"&gt;
&lt;h1&gt;Optimizations Using &lt;code&gt;RandomVariable&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;With our new &lt;code&gt;RandomVariable&lt;/code&gt;, we can alter the replacement patterns used by &lt;code&gt;tt.gof.opt.PatternSub&lt;/code&gt; in &lt;sup id="24875a2c31fa7f94ce562adddedc0bf8"&gt;&lt;a href="#WillardSymbolicMathPyMC32018" title="@misc{WillardSymbolicMathPyMC32018, title = {Symbolic {{Math}} in {{PyMC3}}}, urldate = {2018-12-27}, url = {https://brandonwillard.github.io/symbolic-math-in-pymc3.html}, author = {Willard, Brandon T.}, month = dec, year = {2018}, file = {/home/bwillard/Zotero/storage/6VVT4UNF/symbolic-math-in-pymc3.html} }"&gt;WillardSymbolicMathPyMC32018&lt;/a&gt;&lt;/sup&gt; and implement a slightly better parameter lifting for affine transforms of scalar normal random variables.&lt;/p&gt;
&lt;div class="sourceCode" id="rv_optimizations"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="rv_optimizations-1" title="1"&gt;&lt;span class="co"&gt;# Create random variable constructors.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-2" title="2"&gt;NormalRV &lt;span class="op"&gt;=&lt;/span&gt; RandomVariable(&lt;span class="st"&gt;&amp;#39;normal&amp;#39;&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;, [&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;], &lt;span class="st"&gt;&amp;#39;normal&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-3" title="3"&gt;MvNormalRV &lt;span class="op"&gt;=&lt;/span&gt; RandomVariable(&lt;span class="st"&gt;&amp;#39;multivariate_normal&amp;#39;&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;, [&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;], &lt;span class="st"&gt;&amp;#39;multivariate_normal&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-5" title="5"&gt;&lt;span class="co"&gt;# We use the following to handle keyword arguments.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-6" title="6"&gt;construct_rv &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;lambda&lt;/span&gt; rng, size, mu, sd: NormalRV(mu, sd, size&lt;span class="op"&gt;=&lt;/span&gt;size, rng&lt;span class="op"&gt;=&lt;/span&gt;rng)&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-8" title="8"&gt;norm_lift_pats &lt;span class="op"&gt;=&lt;/span&gt; [&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-9" title="9"&gt;    &lt;span class="co"&gt;# Lift element-wise multiplication&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-10" title="10"&gt;    tt.gof.opt.PatternSub(&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-11" title="11"&gt;        (tt.mul,&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-12" title="12"&gt;         &lt;span class="st"&gt;&amp;#39;a_x&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-13" title="13"&gt;         (NormalRV, &lt;span class="st"&gt;&amp;#39;rs_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;size_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;mu_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;sd_x&amp;#39;&lt;/span&gt;)),&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-14" title="14"&gt;        (construct_rv,&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-15" title="15"&gt;         &lt;span class="st"&gt;&amp;#39;rs_x&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-16" title="16"&gt;         &lt;span class="co"&gt;# XXX: Is this really consistent?  How will it handle broadcasting?&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-17" title="17"&gt;         &lt;span class="st"&gt;&amp;#39;size_x&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-18" title="18"&gt;         (tt.mul, &lt;span class="st"&gt;&amp;#39;a_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;mu_x&amp;#39;&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-19" title="19"&gt;         (tt.mul, &lt;span class="st"&gt;&amp;#39;a_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;sd_x&amp;#39;&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-20" title="20"&gt;        )),&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-21" title="21"&gt;    &lt;span class="co"&gt;# Lift element-wise addition&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-22" title="22"&gt;    tt.gof.opt.PatternSub(&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-23" title="23"&gt;        (tt.add,&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-24" title="24"&gt;         (NormalRV, &lt;span class="st"&gt;&amp;#39;rs_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;size_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;mu_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;sd_x&amp;#39;&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-25" title="25"&gt;         &lt;span class="st"&gt;&amp;#39;b_x&amp;#39;&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-26" title="26"&gt;        (construct_rv,&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-27" title="27"&gt;         &lt;span class="st"&gt;&amp;#39;rs_x&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-28" title="28"&gt;         &lt;span class="co"&gt;# XXX: Is this really consistent?  How will it handle broadcasting?&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-29" title="29"&gt;         &lt;span class="st"&gt;&amp;#39;size_x&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-30" title="30"&gt;         (tt.add, &lt;span class="st"&gt;&amp;#39;mu_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;b_x&amp;#39;&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-31" title="31"&gt;         &lt;span class="st"&gt;&amp;#39;sd_x&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-32" title="32"&gt;        )),&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-33" title="33"&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-34" title="34"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-35" title="35"&gt;norm_lift_opts &lt;span class="op"&gt;=&lt;/span&gt; tt.gof.opt.EquilibriumOptimizer(&lt;/a&gt;
&lt;a class="sourceLine" id="rv_optimizations-36" title="36"&gt;    norm_lift_pats, max_use_ratio&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="example" data-markdown=""&gt;
&lt;div class="sourceCode" id="mat_mul_scaling_rv_exa"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-1" title="1"&gt;&lt;span class="im"&gt;from&lt;/span&gt; theano.gof &lt;span class="im"&gt;import&lt;/span&gt; FunctionGraph, Feature, NodeFinder&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-2" title="2"&gt;&lt;span class="im"&gt;from&lt;/span&gt; theano.gof.graph &lt;span class="im"&gt;import&lt;/span&gt; inputs &lt;span class="im"&gt;as&lt;/span&gt; tt_inputs, clone_get_equiv&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-4" title="4"&gt;mu_X &lt;span class="op"&gt;=&lt;/span&gt; tt.vector(&lt;span class="st"&gt;&amp;#39;mu_X&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-5" title="5"&gt;sd_X &lt;span class="op"&gt;=&lt;/span&gt; tt.vector(&lt;span class="st"&gt;&amp;#39;sd_X&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-6" title="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-7" title="7"&gt;mu_X.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([&lt;span class="dv"&gt;0&lt;/span&gt;], dtype&lt;span class="op"&gt;=&lt;/span&gt;tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-8" title="8"&gt;sd_X.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;], dtype&lt;span class="op"&gt;=&lt;/span&gt;tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-9" title="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-10" title="10"&gt;&lt;span class="co"&gt;# &lt;/span&gt;&lt;span class="al"&gt;TODO&lt;/span&gt;&lt;span class="co"&gt;: Defining the offset, `b_tt`, using `tt.vector` will err-out because of&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-11" title="11"&gt;&lt;span class="co"&gt;# non-matching dimensions and no default broadcasting.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-12" title="12"&gt;&lt;span class="co"&gt;# This is another good reason for broadcasting inputs in `make_node`.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-13" title="13"&gt;&lt;span class="co"&gt;# E.g.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-14" title="14"&gt;&lt;span class="co"&gt;# b_tt = tt.vector(&amp;#39;b&amp;#39;)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-15" title="15"&gt;&lt;span class="co"&gt;# b_tt.tag.test_value = np.array([1, 2], dtype=tt.config.floatX)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-16" title="16"&gt;&lt;span class="co"&gt;# or&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-17" title="17"&gt;&lt;span class="co"&gt;# b_tt.tag.test_value = np.array([1], dtype=tt.config.floatX)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-18" title="18"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-19" title="19"&gt;b_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.as_tensor_variable([&lt;span class="fl"&gt;5.&lt;/span&gt;], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-20" title="20"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-21" title="21"&gt;X_rv &lt;span class="op"&gt;=&lt;/span&gt; NormalRV(mu_X, sd_X, name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;~X_rv&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-22" title="22"&gt;Z_rv &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; X_rv &lt;span class="op"&gt;+&lt;/span&gt; b_tt&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-23" title="23"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-24" title="24"&gt;Z_graph &lt;span class="op"&gt;=&lt;/span&gt; FunctionGraph(tt_inputs([Z_rv]), [Z_rv])&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-25" title="25"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-26" title="26"&gt;Z_graph_opt &lt;span class="op"&gt;=&lt;/span&gt; Z_graph.clone()&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-27" title="27"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-28" title="28"&gt;_ &lt;span class="op"&gt;=&lt;/span&gt; norm_lift_opts.optimize(Z_graph_opt)&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-29" title="29"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-30" title="30"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;Before: &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(tt.pprint(Z_graph.outputs[&lt;span class="dv"&gt;0&lt;/span&gt;])))&lt;/a&gt;
&lt;a class="sourceLine" id="mat_mul_scaling_rv_exa-31" title="31"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;After: &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(tt.pprint(Z_graph_opt.outputs[&lt;span class="dv"&gt;0&lt;/span&gt;])))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="text"&gt;&lt;code&gt;Before: ((TensorConstant{5} * normal_rv(&amp;lt;RandomStateType&amp;gt;, TensorConstant{[]}, mu_X, sd_X)) + TensorConstant{(1,) of 5.0})
After: normal_rv(&amp;lt;RandomStateType&amp;gt;, TensorConstant{[]}, ((TensorConstant{5} * mu_X) + TensorConstant{(1,) of 5.0}), (TensorConstant{5} * sd_X))

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Now, what if we wanted to handle affine transformations of a multivariate normal random variable? Specifically, consider implementing the following:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{equation*}
  X \sim N\left(\mu, \Sigma \right), \quad
  A X \sim N\left(A \mu, A \Sigma A^\top \right)
 \;.
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;At first, the following substitution pattern might seem reasonable:&lt;/p&gt;
&lt;div class="sourceCode" id="cb21"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb21-1" title="1"&gt;&lt;span class="co"&gt;# Vector multiplication&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-2" title="2"&gt;tt.gof.opt.PatternSub(&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-3" title="3"&gt;    (tt.dot,&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-4" title="4"&gt;     &lt;span class="st"&gt;&amp;#39;A_x&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-5" title="5"&gt;     (MvNormalRV, &lt;span class="st"&gt;&amp;#39;rs_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;size_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;mu_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;cov_x&amp;#39;&lt;/span&gt;)),&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-6" title="6"&gt;    (construct_rv,&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-7" title="7"&gt;     MvNormalRV,&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-8" title="8"&gt;     &lt;span class="st"&gt;&amp;#39;rs_x&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-9" title="9"&gt;     &lt;span class="st"&gt;&amp;#39;size_x&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-10" title="10"&gt;     (tt.dot, &lt;span class="st"&gt;&amp;#39;A_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;mu_x&amp;#39;&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-11" title="11"&gt;     (tt.dot,&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-12" title="12"&gt;      (tt.dot, &lt;span class="st"&gt;&amp;#39;A_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;cov_x&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-13" title="13"&gt;      (tt.transpose, &lt;span class="st"&gt;&amp;#39;A_x&amp;#39;&lt;/span&gt;)),&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-14" title="14"&gt;    ))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unfortunately, the combination of size parameter and broadcasting complicates the scenario. Both parameters indirectly affect the distribution parameters, making the un-lifted dot-product consistent, but not necessarily the lifted products.&lt;/p&gt;
&lt;p&gt;The following example demonstrates the lifting issues brought on by broadcasting.&lt;/p&gt;
&lt;div class="example" data-markdown=""&gt;
&lt;p&gt;First, we create a simple multivariate normal.&lt;/p&gt;
&lt;div class="sourceCode" id="cb22"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb22-1" title="1"&gt;mu_X &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="dv"&gt;10&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-2" title="2"&gt;cov_X &lt;span class="op"&gt;=&lt;/span&gt; np.diag([&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="fl"&gt;1e-2&lt;/span&gt;])&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-3" title="3"&gt;size_X_rv &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-4" title="4"&gt;X_rv &lt;span class="op"&gt;=&lt;/span&gt; MvNormalRV(mu_X, cov_X, size&lt;span class="op"&gt;=&lt;/span&gt;size_X_rv)&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-6" title="6"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;X_rv sample:&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(X_rv.tag.test_value))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb23"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb23-1" title="1"&gt;X_rv sample:&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-2" title="2"&gt;[[[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;0.49226543&lt;/span&gt;  &lt;span class="fl"&gt;9.98771301&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-3" title="3"&gt;  [&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;0.22713441&lt;/span&gt; &lt;span class="fl"&gt;10.00124952&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-4" title="4"&gt;  [ &lt;span class="fl"&gt;1.21604812&lt;/span&gt; &lt;span class="fl"&gt;10.0386737&lt;/span&gt; ]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-6" title="6"&gt; [[ &lt;span class="fl"&gt;1.61758857&lt;/span&gt;  &lt;span class="fl"&gt;9.98456418&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-7" title="7"&gt;  [ &lt;span class="fl"&gt;1.26945358&lt;/span&gt;  &lt;span class="fl"&gt;9.9205853&lt;/span&gt; ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-8" title="8"&gt;  [ &lt;span class="fl"&gt;1.25295917&lt;/span&gt; &lt;span class="fl"&gt;10.09953858&lt;/span&gt;]]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-9" title="9"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next, we create a simple matrix operator to apply to the multivariate normal.&lt;/p&gt;
&lt;div class="sourceCode" id="cb24"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb24-1" title="1"&gt;A_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.as_tensor_variable([[&lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="dv"&gt;5&lt;/span&gt;, &lt;span class="dv"&gt;8&lt;/span&gt;], [&lt;span class="dv"&gt;3&lt;/span&gt;, &lt;span class="dv"&gt;4&lt;/span&gt;, &lt;span class="dv"&gt;9&lt;/span&gt;]])&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-2" title="2"&gt;&lt;span class="co"&gt;# or A_tt = tt.as_tensor_variable([[2, 5, 8]])&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-4" title="4"&gt;&lt;span class="co"&gt;# It&amp;#39;s really just `mu_X`...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-5" title="5"&gt;E_X_rv &lt;span class="op"&gt;=&lt;/span&gt; X_rv.owner.inputs[&lt;span class="dv"&gt;2&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-6" title="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-7" title="7"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;A * X_rv =&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(tt.dot(A_tt, X_rv).tag.test_value))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb25"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb25-1" title="1"&gt;A &lt;span class="op"&gt;*&lt;/span&gt; X_rv &lt;span class="op"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-2" title="2"&gt;[[[  &lt;span class="fl"&gt;7.60818207&lt;/span&gt; &lt;span class="fl"&gt;150.2910632&lt;/span&gt; ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-3" title="3"&gt;  [ &lt;span class="fl"&gt;19.60611837&lt;/span&gt; &lt;span class="fl"&gt;150.36836345&lt;/span&gt;]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-5" title="5"&gt; [[  &lt;span class="fl"&gt;8.55909917&lt;/span&gt; &lt;span class="fl"&gt;160.31620039&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-6" title="6"&gt;  [ &lt;span class="fl"&gt;21.20721252&lt;/span&gt; &lt;span class="fl"&gt;160.53188091&lt;/span&gt;]]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-7" title="7"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As we can see, the multivariate normal’s test/sampled value has the correct shape for our matrix operator.&lt;/p&gt;
&lt;div class="sourceCode" id="cb26"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb26-1" title="1"&gt;&lt;span class="im"&gt;import&lt;/span&gt; traceback&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-2" title="2"&gt;&lt;span class="cf"&gt;try&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-3" title="3"&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;A * E[X_rv] =&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(tt.dot(A_tt, E_X_rv).tag.test_value))&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-4" title="4"&gt;&lt;span class="cf"&gt;except&lt;/span&gt; &lt;span class="pp"&gt;ValueError&lt;/span&gt; &lt;span class="im"&gt;as&lt;/span&gt; e:&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-5" title="5"&gt;    &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;quot;&amp;quot;&lt;/span&gt;.join(traceback.format_exception_only(&lt;span class="bu"&gt;type&lt;/span&gt;(e), e)))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb27"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb27-1" title="1"&gt;&lt;span class="pp"&gt;ValueError&lt;/span&gt;: shapes (&lt;span class="dv"&gt;2&lt;/span&gt;,&lt;span class="dv"&gt;3&lt;/span&gt;) &lt;span class="kw"&gt;and&lt;/span&gt; (&lt;span class="dv"&gt;2&lt;/span&gt;,) &lt;span class="kw"&gt;not&lt;/span&gt; aligned: &lt;span class="dv"&gt;3&lt;/span&gt; (dim &lt;span class="dv"&gt;1&lt;/span&gt;) &lt;span class="op"&gt;!=&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt; (dim &lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb27-2" title="2"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, we see that the multivariate normal’s inputs (i.e. the &lt;code&gt;Op&lt;/code&gt; inputs)–specifically the mean parameter–do not directly reflect the support’s shape, as intuitively would suggest.&lt;/p&gt;
&lt;div class="sourceCode" id="cb28"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb28-1" title="1"&gt;size_tile &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;tuple&lt;/span&gt;(size_X_rv) &lt;span class="op"&gt;+&lt;/span&gt; (&lt;span class="dv"&gt;1&lt;/span&gt;,)&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-2" title="2"&gt;E_X_rv_ &lt;span class="op"&gt;=&lt;/span&gt; tt.tile(E_X_rv, size_tile, X_rv.ndim)&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb28-4" title="4"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;A * E[X_rv] =&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(tt.dot(A_tt, E_X_rv_).tag.test_value))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb29"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb29-1" title="1"&gt;A &lt;span class="op"&gt;*&lt;/span&gt; E[X_rv] &lt;span class="op"&gt;=&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-2" title="2"&gt;[[[  &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="dv"&gt;150&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-3" title="3"&gt;  [  &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="dv"&gt;150&lt;/span&gt;]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-5" title="5"&gt; [[  &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="dv"&gt;160&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-6" title="6"&gt;  [  &lt;span class="dv"&gt;0&lt;/span&gt; &lt;span class="dv"&gt;160&lt;/span&gt;]]]&lt;/a&gt;
&lt;a class="sourceLine" id="cb29-7" title="7"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can manually replicate the inputs so that they match the output shape, but a solution to the general problem requires a more organized response.&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="discussion" class="level1"&gt;
&lt;h1&gt;Discussion&lt;/h1&gt;
&lt;p&gt;In a follow-up, we’ll address a few loose ends, such as&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the inclusion of density functions and likelihoods,&lt;/li&gt;
&lt;li&gt;decompositions/reductions of overlapping multivariate types (e.g. transforms between tensors of univariate normals and equivalent multivariate normals),&lt;/li&gt;
&lt;li&gt;canonicalization of graphs containing &lt;code&gt;RandomVariable&lt;/code&gt; terms,&lt;/li&gt;
&lt;li&gt;and optimizations that specifically benefit MCMC schemes (e.g. automatic conversion to scale mixture decompositions that improve sampling/covariance structure).&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="bibliography" class="level1"&gt;
&lt;h1&gt;Bibliography&lt;/h1&gt;
&lt;p&gt;&lt;a id="WillardSymbolicMathPyMC32018"&gt;&lt;/a&gt;[WillardSymbolicMathPyMC32018] Willard, Symbolic Math in PyMC3, &lt;i&gt;&lt;/i&gt;, (2018). &lt;a href="https://brandonwillard.github.io/symbolic-math-in-pymc3.html"&gt;link&lt;/a&gt;. &lt;a href="#24875a2c31fa7f94ce562adddedc0bf8"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;script type="text/x-mathjax-config"&gt;
MathJax.Hub.Config({
  CommonHTML: { linebreaks: { automatic: true } },
  "HTML-CSS": { linebreaks: { automatic: true } },
  SVG: { linebreaks: { automatic: true } },
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</content><category term="pymc3"></category><category term="theano"></category><category term="statistics"></category><category term="symbolic computation"></category><category term="python"></category><category term="probability theory"></category></entry><entry><title>Readable Strings and Relational Programming in Hy</title><link href="https://brandonwillard.github.io/readable-strings-and-relational-programming-in-hy.html" rel="alternate"></link><published>2018-12-20T00:00:00-06:00</published><updated>2018-12-23T00:00:00-06:00</updated><author><name>Brandon T. Willard</name></author><id>tag:brandonwillard.github.io,2018-12-20:/readable-strings-and-relational-programming-in-hy.html</id><summary type="html"></summary><content type="html">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
  &lt;meta http-equiv="Content-Style-Type" content="text/css" /&gt;
  &lt;meta name="generator" content="pandoc" /&gt;
  &lt;meta name="author" content="Brandon T. Willard" /&gt;
  &lt;title&gt;Readable Strings and Relational Programming in Hy&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  &lt;/style&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--  --&gt;
&lt;!-- &lt;div id="header"&gt; --&gt;
&lt;!-- &lt;h1 class="title"&gt;Readable Strings and Relational Programming in Hy&lt;/h1&gt; --&gt;
&lt;!--  --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;h2 class="author"&gt;Brandon T. Willard&lt;/h2&gt; --&gt;
&lt;!--  --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;h3 class="date"&gt;2018–12–20&lt;/h3&gt; --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;/div&gt; --&gt;
&lt;!--  --&gt;
&lt;div class="abstract"&gt;
&lt;p&gt;Just some thoughts on a generalized &lt;code&gt;repr&lt;/code&gt; for Hy and some connections with relational programming.&lt;/p&gt;
&lt;/div&gt;
&lt;section id="introduction" class="level1"&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In the past few months, I’ve been working on &lt;a href="https://github.com/hylang/hy"&gt;Hy&lt;/a&gt; a lot. It’s been great for translating symbolic computation ideas originating in the Lisp community or simply performing the generic meta-programming inherent to the subject.&lt;/p&gt;
&lt;p&gt;One feature I’ve been missing the most is “readable” print-outs from the REPL. In this case, “readable” means “a string that can be &lt;code&gt;eval&lt;/code&gt;’ed to [re-]produce the object it’s meant to represent”. &lt;a href="https://docs.python.org/3/library/functions.html#repr"&gt;Python calls the function(s) that produce these strings “&lt;code&gt;repr&lt;/code&gt;”s&lt;/a&gt; and provides a generic &lt;code&gt;repr&lt;/code&gt; function–with limited Python “readability” guarantees–and a &lt;code&gt;__repr__&lt;/code&gt; property for object/class-level customization.&lt;/p&gt;
&lt;div class="example" data-markdown=""&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;test_obj &lt;span class="op"&gt;=&lt;/span&gt; {&lt;span class="st"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;: &lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="st"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;: [&lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;]}&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;span class="co"&gt;# Produce a readable string using `repr`&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;obj_repr_str &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;repr&lt;/span&gt;(test_obj)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(obj_repr_str)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" title="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" title="7"&gt;&lt;span class="co"&gt;# Re-create the object from its readable string form&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" title="8"&gt;obj_from_repr &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;eval&lt;/span&gt;(obj_repr_str)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" title="9"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(obj_from_repr)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" title="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" title="11"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(test_obj &lt;span class="op"&gt;==&lt;/span&gt; obj_from_repr)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;{&lt;span class="st"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;: &lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;: [&lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;]}&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;{&lt;span class="st"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;: &lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;: [&lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;]}&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;&lt;span class="va"&gt;True&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" title="4"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;There’s already a &lt;code&gt;hy.contrib.hy-repr&lt;/code&gt; module that gets most of the way there, but it doesn’t implement the Python standard library’s &lt;code&gt;reprlib.Repr&lt;/code&gt;. The class &lt;code&gt;reprlib.Repr&lt;/code&gt; implements limits for the display lengths of the strings it produces, and its source code provides a few standard library implementations of primitive object &lt;code&gt;repr&lt;/code&gt;s–which require only trivial changes to produce the desired Hy syntax.&lt;/p&gt;
&lt;p&gt;For these reasons–and an overall interest in using and translating more of the Python standard library to Hy–I decided to try a quick refactoring of &lt;code&gt;hy.contrib.hy-repr&lt;/code&gt; that implements &lt;code&gt;reprlib.Repr&lt;/code&gt;.&lt;/p&gt;
&lt;section id="the-problems" class="level2"&gt;
&lt;h2&gt;The Problem(s)&lt;/h2&gt;
&lt;p&gt;The translation of Hy AST to string form is fairly straight-forward. In most cases, one only needs to change the &lt;code&gt;repr&lt;/code&gt;s for Python primitives and basic function calls (e.g. from &lt;code&gt;func(1)&lt;/code&gt; to &lt;code&gt;(func 1)&lt;/code&gt;); however, changing just a couple lines in &lt;code&gt;repr&lt;/code&gt;/&lt;code&gt;__repr__&lt;/code&gt; functions for all the Python builtins is very annoying.&lt;/p&gt;
&lt;p&gt;Furthermore, what about those custom object &lt;code&gt;__repr__&lt;/code&gt; methods? While one might be able to manually patch most–if not all–of the (Python-implemented) standard library objects, there are far too many 3rd-party library &lt;code&gt;__repr__&lt;/code&gt;s with exactly the same trivial function-call form that can’t reasonably be patched.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="some-approaches" class="level2"&gt;
&lt;h2&gt;Some approaches&lt;/h2&gt;
&lt;p&gt;The first few things that come to mind when considering a more general approach to Python-to-Hy &lt;code&gt;__repr__&lt;/code&gt; translation involve some use of the existing &lt;code&gt;repr&lt;/code&gt; code. That might come in the form of string manipulation of &lt;code&gt;repr&lt;/code&gt; output, which &lt;code&gt;hy.contrib.hy-repr&lt;/code&gt; already does in some cases, or quite possibly some use of a &lt;code&gt;repr&lt;/code&gt; function’s source or code object.&lt;/p&gt;
&lt;p&gt;The latter seems like it has the potential to be more thorough and far-reaching, but also considerably more involved and computationally inefficient. Unfortunately, similar things can be said about the regex approach. Although it does seem a little easier to implement and–for limited cases–efficient enough for most purposes, it also comes across as much more brittle.&lt;/p&gt;
&lt;p&gt;Fortunately, the latter is unnecessary, because, when the existing &lt;code&gt;repr&lt;/code&gt; output is Python readable, it can be parsed by &lt;code&gt;ast.parse&lt;/code&gt;. The function &lt;code&gt;ast.parse&lt;/code&gt; effectively handles the regex work and yields the bulk of information needed for a Hy &lt;code&gt;repr&lt;/code&gt; string: the function name and its (positional and keyword) arguments.&lt;/p&gt;
&lt;div class="example" data-markdown=""&gt;
&lt;p&gt;Let’s say we implement our own object and &lt;code&gt;repr&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="hy"&gt;&lt;code&gt;(defclass TestClass [object]
  (defn --init-- [self arg1 arg2 &amp;amp;optional kwarg1 kwarg2]
    (setv self.arg1 arg1
          self.arg2 arg2
          self.kwarg1 kwarg1
          self.kwarg2 kwarg2))
  (defn --repr-- [self]
    (.format &amp;quot;TestClass({}, {}, kwarg1={}, kwarg2={})&amp;quot;
             #* (lfor a [self.arg1 self.arg2
                         self.kwarg1 self.kwarg2]
                      (repr a)))))

(setv test-obj (TestClass 1 {&amp;quot;a&amp;quot; 1 &amp;quot;b&amp;quot; 2} :kwarg1 1 :kwarg2 &amp;quot;ok&amp;quot;))
(print (repr test-obj))&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb4-1" title="1"&gt;TestClass(&lt;span class="dv"&gt;1&lt;/span&gt;, {&lt;span class="st"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;: &lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;: &lt;span class="dv"&gt;2&lt;/span&gt;}, kwarg1&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, kwarg2&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;ok&amp;#39;&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since the results are readable, we can do the following:&lt;/p&gt;
&lt;pre class="hy"&gt;&lt;code&gt;(import ast astor)
(setv repr-ast (ast.parse (repr test-obj) :mode &amp;quot;eval&amp;quot;))
(print (astor.dump repr-ast))&lt;/code&gt;&lt;/pre&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb6-1" title="1"&gt;Expression(&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" title="2"&gt;    body&lt;span class="op"&gt;=&lt;/span&gt;Call(func&lt;span class="op"&gt;=&lt;/span&gt;Name(&lt;span class="bu"&gt;id&lt;/span&gt;&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;TestClass&amp;#39;&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" title="3"&gt;              args&lt;span class="op"&gt;=&lt;/span&gt;[Num(n&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" title="4"&gt;                    Dict(keys&lt;span class="op"&gt;=&lt;/span&gt;[Str(s&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;), Str(s&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;)],&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" title="5"&gt;                         values&lt;span class="op"&gt;=&lt;/span&gt;[Num(n&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;), Num(n&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt;)])],&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" title="6"&gt;              keywords&lt;span class="op"&gt;=&lt;/span&gt;[keyword(arg&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;kwarg1&amp;#39;&lt;/span&gt;, value&lt;span class="op"&gt;=&lt;/span&gt;Num(n&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;)),&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" title="7"&gt;                        keyword(arg&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;kwarg2&amp;#39;&lt;/span&gt;, value&lt;span class="op"&gt;=&lt;/span&gt;Str(s&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;ok&amp;#39;&lt;/span&gt;))]))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="an-implemented-partial-solution" class="level1"&gt;
&lt;h1&gt;An Implemented Partial Solution&lt;/h1&gt;
&lt;p&gt;With existing &lt;code&gt;repr&lt;/code&gt; output converted to Python AST by Python itself (using &lt;code&gt;ast.parse&lt;/code&gt;), we can produce readable Hy strings from the resulting AST objects.&lt;/p&gt;
&lt;p&gt;In this scenario, we need only be concerned with the conversion of Python AST into readable Hy strings. This works like an inverse to the Hy compiler: in other words, a Hy decompiler. For &lt;code&gt;repr&lt;/code&gt; purposes, only function call statements and their arguments need to be decompiled. Unfortunately, function arguments can consist of arbitrary Python/Hy objects, and that’s how the decompilation responsibilities start to expand. If we limit our scope to a reasonable subset of Python builtins/primitives, the results can still be quite effective, and won’t require a complete decompiler.&lt;/p&gt;
&lt;p&gt;On the down-side, if a Hy &lt;code&gt;repr&lt;/code&gt; implementation overrides the built-in &lt;code&gt;repr&lt;/code&gt;, then arguments in existing &lt;code&gt;repr&lt;/code&gt;/&lt;code&gt;__repr__&lt;/code&gt;s might already be converted by the overridden &lt;code&gt;repr&lt;/code&gt;; however, the results from &lt;code&gt;ast.parse&lt;/code&gt; will undo/discard those results. Even so, custom class &lt;code&gt;__repr__&lt;/code&gt;s aren’t guaranteed to use the built-in &lt;code&gt;repr&lt;/code&gt; on their arguments, so attempts to salvage already-converted &lt;code&gt;repr&lt;/code&gt; output are undeniably fraught with complications.&lt;/p&gt;
&lt;div class="example" data-markdown=""&gt;
&lt;p&gt;Working from the &lt;code&gt;repr&lt;/code&gt;-produced AST above, I mocked-up a quick prototype for a generic Python-to-Hy conversion function.&lt;/p&gt;
&lt;pre class="hy"&gt;&lt;code&gt;(import ast)
(import builtins)

(import [hy.contrib.hy-repr [hy-repr :as -hy-repr]])

(defn ast-funcall-to-hy [ast-obj repr1
                         &amp;amp;optional [level 1]]
  &amp;quot;Turn Python `ast.Call` expressions into Hy `repr` strings.

XXX: Only a very minimal subset of Python-to-Hy AST is implemented.

This can be used to turn a \&amp;quot;readable\&amp;quot; `repr` result, via an actual \&amp;quot;read\&amp;quot; by
`ast.parse`, to Python AST then Hy AST.
&amp;quot;
  (assert (and (instance? ast.Expression ast-obj)
               (instance? ast.Call ast-obj.body)))
  (setv func-name (. ast-obj body func id))
  (setv eval-fn (fn [o]
                  (if (instance? ast.Name o)
                      o.id
                      (repr1 (ast.literal-eval o) (dec level)))))
  (setv func-args (lfor a (. ast-obj body args) (eval-fn a)))
  (setv func-kwargs (lfor k (. ast-obj body keywords)
                          (.format &amp;quot;:{} {}&amp;quot; k.arg (eval-fn k.value))))
  (.format &amp;quot;({})&amp;quot; (.join &amp;quot; &amp;quot; (+ [func-name] func-args func-kwargs))))


(setv test-ast (ast.parse &amp;quot;range(x, y, blah=1, bloh=\&amp;quot;ok\&amp;quot;)&amp;quot; :mode &amp;quot;eval&amp;quot;))
(print (ast-funcall-to-hy test-ast (fn [x &amp;amp;rest y] (-hy-repr x))))&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="hy"&gt;&lt;code&gt;(range x y :blah 1 :bloh &amp;quot;ok&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ast-funcall-to-hy&lt;/code&gt; is an extremely narrow decompiler that only handles readable function calls (represented by &lt;code&gt;ast.Call&lt;/code&gt; nodes), but, as part of a fallback sequence in a Hy &lt;code&gt;repr&lt;/code&gt; implementation, it’s still pretty useful.&lt;/p&gt;
&lt;p&gt;A function like &lt;code&gt;ast-funcall-to-hy&lt;/code&gt; can be used in &lt;code&gt;repr&lt;/code&gt; logic as follows:&lt;/p&gt;
&lt;pre class="hy"&gt;&lt;code&gt;(defn hy-repr [x &amp;amp;optional [level 1] [-repr (fn [x &amp;amp;rest y] (-hy-repr x))]]
  &amp;quot;Use `builtin.repr` results to generate readable Hy `repr` strings for cases
we haven&amp;#39;t covered explicitly.
&amp;quot;
  (try
    (setv s (builtins.repr x))
    (when (not (.startswith s &amp;quot;&amp;lt;&amp;quot;))
      (do
        (setv repr-ast (ast.parse s :mode &amp;quot;eval&amp;quot;))
        (setv s (ast-funcall-to-hy repr-ast -repr))))
    s
    (except [Exception]
      (.format &amp;quot;&amp;lt;{} instance at {}&amp;gt;&amp;quot; x.__class__.__name__ (id x)))))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, for the example class, &lt;code&gt;TestClass&lt;/code&gt;, we can demonstrate automatic conversion of its Python &lt;code&gt;__repr__&lt;/code&gt; implementation.&lt;/p&gt;
&lt;pre class="hy"&gt;&lt;code&gt;(setv test-ast (TestClass 1 {&amp;quot;a&amp;quot; 2 &amp;quot;b&amp;quot; 3} :kwarg1 1 :kwarg2 &amp;quot;ok&amp;quot;))
(print (.format &amp;quot;before: {}\nafter: {}&amp;quot;
                (repr test-ast)
                (hy-repr test-ast)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="text"&gt;&lt;code&gt;before: TestClass(1, {&amp;#39;a&amp;#39;: 2, &amp;#39;b&amp;#39;: 3}, kwarg1=1, kwarg2=&amp;#39;ok&amp;#39;)
after: (TestClass 1 {&amp;quot;a&amp;quot; 2  &amp;quot;b&amp;quot; 3} :kwarg1 1 :kwarg2 &amp;quot;ok&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="a-use-for-relational-programming" class="level1"&gt;
&lt;h1&gt;A use for relational programming&lt;/h1&gt;
&lt;p&gt;While considering all this, I kept thinking about how nice it would be to have a “bijective” compiler; in other words, the existing Hy compiler, which translates Hy-to-Python, &lt;strong&gt;and&lt;/strong&gt; a Python-to-Hy (de)compiler. With a Python-to-Hy AST compiler, we could more broadly convert Python AST output–like the kind in our example above–to a &lt;code&gt;repr&lt;/code&gt;/readable string in Hy.&lt;/p&gt;
&lt;p&gt;The idea isn’t too crazy, especially since one can easily work backward from a lot of the logic in the existing Hy compiler. There will be some edge cases that result in non-bijective translations (i.e. some round-trip Hy/Python translations might only be &lt;strong&gt;equal&lt;/strong&gt; and not exactly &lt;strong&gt;equivalent&lt;/strong&gt;), but this isn’t necessarily a blocking issue. Decisions regarding “canonical” or reduced forms of Hy/Python AST might be necessary, especially if the resulting AST is intended to be more human readable than not.&lt;/p&gt;
&lt;p&gt;Perhaps what’s more discouraging is the effort it would take to ensure that the compilation processes going both ways are–and stay–coherent during the course of development. For instance, when changes are made to the standard compilation process (i.e. Hy-to-Python), it’s likely that changes and tests would also be needed for the other direction.&lt;/p&gt;
&lt;p&gt;This is where a paradigm like relational programming is particularly appealing: it provides a language for defining–and means for computing–the maps&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{equation*}
  \text{Hy Syntax}
  \longleftrightarrow \text{Python AST}
  \longleftrightarrow \text{Python Syntax}
  \;
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;in a cohesive way.&lt;/p&gt;
&lt;p&gt;My relational programming DSL of choice, &lt;a href="http://minikanren.org"&gt;miniKanren&lt;/a&gt;, already has an implementation in Hy: &lt;a href="https://github.com/algernon/adderall"&gt;&lt;code&gt;loghyc&lt;/code&gt; (and to be formally known as &lt;code&gt;adderall&lt;/code&gt;)&lt;/a&gt;. We’ve been using it to perform static code analysis and refactoring in the project &lt;a href="https://github.com/hylang/hydiomatic"&gt;&lt;code&gt;hydiomatic&lt;/code&gt;&lt;/a&gt;, so there’s also a precedent for parsing Hy syntax in a relational context.&lt;/p&gt;
&lt;p&gt;The missing/next step would be to output Python AST (instead of more Hy forms, like &lt;code&gt;hydiomatic&lt;/code&gt; produces, for example).&lt;/p&gt;
&lt;p&gt;Perhaps, in a follow-up, I’ll illustrate how this can be done.&lt;/p&gt;
&lt;/section&gt;
&lt;script type="text/x-mathjax-config"&gt;
MathJax.Hub.Config({
  CommonHTML: { linebreaks: { automatic: true } },
  "HTML-CSS": { linebreaks: { automatic: true } },
  SVG: { linebreaks: { automatic: true } },
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</content><category term="hy"></category><category term="relational programming"></category><category term="python"></category></entry><entry><title>Data Science at Citybase</title><link href="https://brandonwillard.github.io/data-science-at-citybase.html" rel="alternate"></link><published>2018-12-18T00:00:00-06:00</published><updated>2018-12-23T00:00:00-06:00</updated><author><name>Brandon T. Willard</name></author><id>tag:brandonwillard.github.io,2018-12-18:/data-science-at-citybase.html</id><summary type="html"></summary><content type="html">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
  &lt;meta http-equiv="Content-Style-Type" content="text/css" /&gt;
  &lt;meta name="generator" content="pandoc" /&gt;
  &lt;meta name="author" content="Brandon T. Willard" /&gt;
  &lt;title&gt;Data Science at Citybase&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--  --&gt;
&lt;!-- &lt;div id="header"&gt; --&gt;
&lt;!-- &lt;h1 class="title"&gt;Data Science at Citybase&lt;/h1&gt; --&gt;
&lt;!--  --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;h2 class="author"&gt;Brandon T. Willard&lt;/h2&gt; --&gt;
&lt;!--  --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;h3 class="date"&gt;2018–12–18&lt;/h3&gt; --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;/div&gt; --&gt;
&lt;!--  --&gt;
&lt;p&gt;I recently wrote about data science at CityBase on the CityBase blog: &lt;sup id="c26e94c1b0b80ac3545371089d4f9936"&gt;&lt;a href="#WillardProgrammingIntelligentCity2018a"&gt;Programming an Intelligent City: The Role of Data Science&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;section id="bibliography" class="level1"&gt;
&lt;h1&gt;Bibliography&lt;/h1&gt;
&lt;p&gt;&lt;a id="WillardProgrammingIntelligentCity2018a"&gt;&lt;/a&gt;[WillardProgrammingIntelligentCity2018a] Willard, Programming an Intelligent City: The Role of Data Science, &lt;i&gt;CityBase&lt;/i&gt;, (2018). &lt;a href="https://thecitybase.com/programming-an-intelligent-city-the-role-of-data-science/"&gt;link&lt;/a&gt;. &lt;a href="#c26e94c1b0b80ac3545371089d4f9936"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;script type="text/x-mathjax-config"&gt;
MathJax.Hub.Config({
  CommonHTML: { linebreaks: { automatic: true } },
  "HTML-CSS": { linebreaks: { automatic: true } },
  SVG: { linebreaks: { automatic: true } },
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</content><category term="statistics"></category><category term="symbolic computation"></category><category term="citybase"></category></entry><entry><title>Symbolic Math in PyMC3</title><link href="https://brandonwillard.github.io/symbolic-math-in-pymc3.html" rel="alternate"></link><published>2018-12-18T00:00:00-06:00</published><updated>2018-12-26T00:00:00-06:00</updated><author><name>Brandon T. Willard</name></author><id>tag:brandonwillard.github.io,2018-12-18:/symbolic-math-in-pymc3.html</id><summary type="html"></summary><content type="html">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
  &lt;meta http-equiv="Content-Style-Type" content="text/css" /&gt;
  &lt;meta name="generator" content="pandoc" /&gt;
  &lt;meta name="author" content="Brandon T. Willard" /&gt;
  &lt;title&gt;Symbolic Math in PyMC3&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  &lt;/style&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--  --&gt;
&lt;!-- &lt;div id="header"&gt; --&gt;
&lt;!-- &lt;h1 class="title"&gt;Symbolic Math in PyMC3&lt;/h1&gt; --&gt;
&lt;!--  --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;h2 class="author"&gt;Brandon T. Willard&lt;/h2&gt; --&gt;
&lt;!--  --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;h3 class="date"&gt;2018–12–18&lt;/h3&gt; --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;/div&gt; --&gt;
&lt;!--  --&gt;
&lt;section id="introduction" class="level1"&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In &lt;sup id="4407b21e48ab9ff17c017e8d62684725"&gt;&lt;a href="#WillardRoleSymbolicComputation2017"&gt;A Role for Symbolic Computation in the General Estimation of Statistical Models&lt;/a&gt;&lt;/sup&gt;, I described how symbolic computation is used by bayesian modeling software like PyMC3 and some directions it could take. It closed with an example of automatic normal-normal convolution using PyMC3 objects and Theano’s optimization framework. This article elaborates on the foundations for symbolic mathematics in Theano and PyMC3; specifically, its current state, some challenges, and potential improvements.&lt;/p&gt;
&lt;p&gt;Let’s start by reconsidering the simple normal-normal convolution model. Mathematically, we can represent the model as follows:&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{equation}
  X \sim N(0, 1), \quad
  Y \sim N\left(1, \frac12\right), \quad
  Z = X + Y \sim N\left(1, \frac32\right)
  \label{eq:norm_conv_model}
\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Using PyMC3, the model for Equation &lt;span class="math inline"&gt;\(\eqref{eq:norm_conv_model}\)&lt;/span&gt; is constructed as follows:&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="im"&gt;import&lt;/span&gt; sys&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;span class="im"&gt;import&lt;/span&gt; os&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;&lt;span class="im"&gt;from&lt;/span&gt; pprint &lt;span class="im"&gt;import&lt;/span&gt; pprint&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" title="6"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" title="8"&gt;os.environ[&lt;span class="st"&gt;&amp;#39;MKL_THREADING_LAYER&amp;#39;&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;GNU&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" title="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" title="10"&gt;&lt;span class="im"&gt;import&lt;/span&gt; theano&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" title="11"&gt;&lt;span class="im"&gt;import&lt;/span&gt; theano.tensor &lt;span class="im"&gt;as&lt;/span&gt; tt&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" title="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" title="13"&gt;theano.config.mode &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;FAST_COMPILE&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" title="14"&gt;theano.config.exception_verbosity &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;high&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" title="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" title="16"&gt;&lt;span class="im"&gt;import&lt;/span&gt; pymc3 &lt;span class="im"&gt;as&lt;/span&gt; pm&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;mu_X &lt;span class="op"&gt;=&lt;/span&gt; tt.vector(&lt;span class="st"&gt;&amp;#39;mu_X&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;mu_X.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([&lt;span class="fl"&gt;0.&lt;/span&gt;], dtype&lt;span class="op"&gt;=&lt;/span&gt;tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;sd_X &lt;span class="op"&gt;=&lt;/span&gt; tt.vector(&lt;span class="st"&gt;&amp;#39;sd_X&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" title="4"&gt;sd_X.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([&lt;span class="fl"&gt;1.&lt;/span&gt;], dtype&lt;span class="op"&gt;=&lt;/span&gt;tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-6" title="6"&gt;mu_Y &lt;span class="op"&gt;=&lt;/span&gt; tt.vector(&lt;span class="st"&gt;&amp;#39;mu_Y&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-7" title="7"&gt;mu_Y.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([&lt;span class="fl"&gt;1.&lt;/span&gt;], dtype&lt;span class="op"&gt;=&lt;/span&gt;tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-8" title="8"&gt;sd_Y &lt;span class="op"&gt;=&lt;/span&gt; tt.vector(&lt;span class="st"&gt;&amp;#39;sd_Y&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-9" title="9"&gt;sd_Y.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([&lt;span class="fl"&gt;0.5&lt;/span&gt;], dtype&lt;span class="op"&gt;=&lt;/span&gt;tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-10" title="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-11" title="11"&gt;&lt;span class="cf"&gt;with&lt;/span&gt; pm.Model() &lt;span class="im"&gt;as&lt;/span&gt; conv_model:&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-12" title="12"&gt;    X_rv &lt;span class="op"&gt;=&lt;/span&gt; pm.Normal(&lt;span class="st"&gt;&amp;#39;X_rv&amp;#39;&lt;/span&gt;, mu_X, sd&lt;span class="op"&gt;=&lt;/span&gt;sd_X, shape&lt;span class="op"&gt;=&lt;/span&gt;(&lt;span class="dv"&gt;1&lt;/span&gt;,))&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-13" title="13"&gt;    Y_rv &lt;span class="op"&gt;=&lt;/span&gt; pm.Normal(&lt;span class="st"&gt;&amp;#39;Y_rv&amp;#39;&lt;/span&gt;, mu_Y, sd&lt;span class="op"&gt;=&lt;/span&gt;sd_Y, shape&lt;span class="op"&gt;=&lt;/span&gt;(&lt;span class="dv"&gt;1&lt;/span&gt;,))&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-14" title="14"&gt;    Z_rv &lt;span class="op"&gt;=&lt;/span&gt; X_rv &lt;span class="op"&gt;+&lt;/span&gt; Y_rv&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The Python objects representing terms in &lt;span class="math inline"&gt;\(\eqref{eq:norm_conv_model}\)&lt;/span&gt; are &lt;code&gt;X_rv&lt;/code&gt;, &lt;code&gt;Y_rv&lt;/code&gt;, and &lt;code&gt;Z_rv&lt;/code&gt; in &lt;a href="#pymc3_model"&gt;pymc3_model&lt;/a&gt;. Those terms together form a Theano graph for the entirety of &lt;span class="math inline"&gt;\(\eqref{eq:norm_conv_model}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Other aspects of the model are implicitly stored in the &lt;a href="https://docs.python.org/3.6/reference/compound_stmts.html#with"&gt;Python context object&lt;/a&gt; &lt;code&gt;conv_model&lt;/code&gt;. For example, the context object tracks the model’s log likelihood function when some variables are designated as “observed”–i.e. associated with sample data. In this example, we haven’t specified an observed variable, so the context object won’t be immediately useful.&lt;/p&gt;
&lt;div class="remark" data-markdown=""&gt;
&lt;p&gt;In what follows, we’ll briefly introduce the internal aspects of PyMC3 that are immediately relevant for the topics addressed here; otherwise, see &lt;a href="https://docs.pymc.io/developer_guide.html"&gt;the PyMC3 developer’s guide&lt;/a&gt; for an explanation of its design and internal workings.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The terms &lt;code&gt;X_rv&lt;/code&gt;, &lt;code&gt;Y_rv&lt;/code&gt; are derived from both a PyMC3 &lt;a href="https://github.com/pymc-devs/pymc3/blob/v3.3/pymc3/model.py#L151"&gt;&lt;code&gt;Factor&lt;/code&gt;&lt;/a&gt; class and the standard Theano &lt;code&gt;TensorVariable&lt;/code&gt;, as illustrated in the output of &lt;a href="#pymc3_mro"&gt;pymc3_mro&lt;/a&gt;. However, the convolution term &lt;code&gt;Z_rv&lt;/code&gt; is not a PyMC3 random variable; in other words, it does &lt;strong&gt;not&lt;/strong&gt; implement the PyMC3 &lt;code&gt;Factor&lt;/code&gt; class, but it &lt;strong&gt;is&lt;/strong&gt; a Theano &lt;code&gt;TensorVariable&lt;/code&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb3-1" title="1"&gt;pprint({&lt;span class="st"&gt;&amp;#39;Y_rv&amp;#39;&lt;/span&gt;: &lt;span class="bu"&gt;type&lt;/span&gt;(Y_rv).mro()})&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" title="2"&gt;pprint({&lt;span class="st"&gt;&amp;#39;Z_rv&amp;#39;&lt;/span&gt;: &lt;span class="bu"&gt;type&lt;/span&gt;(Z_rv).mro()})&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb4-1" title="1"&gt;{&lt;span class="st"&gt;&amp;#39;Y_rv&amp;#39;&lt;/span&gt;: [&lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;pymc3.model.FreeRV&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" title="2"&gt;          &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;pymc3.model.Factor&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" title="3"&gt;          &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;theano.tensor.var.TensorVariable&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" title="4"&gt;          &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;theano.tensor.var._tensor_py_operators&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" title="5"&gt;          &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;theano.gof.graph.Variable&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-6" title="6"&gt;          &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;theano.gof.graph.Node&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-7" title="7"&gt;          &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;theano.gof.utils.object2&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-8" title="8"&gt;          &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;object&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;]}&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-9" title="9"&gt;{&lt;span class="st"&gt;&amp;#39;Z_rv&amp;#39;&lt;/span&gt;: [&lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;theano.tensor.var.TensorVariable&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-10" title="10"&gt;          &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;theano.tensor.var._tensor_py_operators&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-11" title="11"&gt;          &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;theano.gof.graph.Variable&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-12" title="12"&gt;          &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;theano.gof.graph.Node&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-13" title="13"&gt;          &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;theano.gof.utils.object2&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-14" title="14"&gt;          &lt;span class="op"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;object&amp;#39;&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;]}&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-15" title="15"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While PyMC3 doesn’t &lt;strong&gt;need&lt;/strong&gt; to support convolution, so much within Bayesian statistics, MCMC, and probabilistic programming rely on it in some way. It’s an intrinsic part of the algebra(s) implied by the use of probability theory and essential to the implementation of more sophisticated models and sampler optimizations–in at least the same way as symbolic differentiation. Here, the question isn’t whether these algebraic properties are explicitly supported, but how easily they can be implemented when necessary.&lt;/p&gt;
&lt;p&gt;As it appears, all work related to probability theory or the algebra of random variables is performed implicitly within the context of Theano and mostly detached from the model-level meta information provided by the PyMC3 abstractions. This means that the linear/tensor algebra supported by Theano is the primary level of abstraction.&lt;/p&gt;
&lt;p&gt;More specifically, one purpose of the PyMC3 probability theory abstractions (e.g. random variable classes—&lt;code&gt;FreeRV&lt;/code&gt; and &lt;code&gt;ObservedRV&lt;/code&gt;, distributions and their likelihoods, etc.) is to associate a PyMC3 &lt;a href="https://github.com/pymc-devs/pymc3/blob/v3.3/pymc3/distributions/distribution.py#L18"&gt;&lt;code&gt;Distribution&lt;/code&gt;&lt;/a&gt; object with a Theano &lt;code&gt;TensorVariable&lt;/code&gt;. This connection is made through a &lt;code&gt;distribution&lt;/code&gt; attribute&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb5-1" title="1"&gt;pprint(Y_rv.distribution)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" title="2"&gt;pprint(X_rv.distribution)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb6-1" title="1"&gt;&lt;span class="op"&gt;&amp;lt;&lt;/span&gt;pymc3.distributions.continuous.Normal &lt;span class="bu"&gt;object&lt;/span&gt; at &lt;span class="bn"&gt;0x7f5d1796e908&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" title="2"&gt;&lt;span class="op"&gt;&amp;lt;&lt;/span&gt;pymc3.distributions.continuous.Normal &lt;span class="bu"&gt;object&lt;/span&gt; at &lt;span class="bn"&gt;0x7f5d17b10208&lt;/span&gt;&lt;span class="op"&gt;&amp;gt;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" title="3"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Distribution&lt;/code&gt; objects loosely represents a measure, holding distribution parameters (e.g. mean and standard deviation &lt;code&gt;mu_X&lt;/code&gt;, &lt;code&gt;sd_X&lt;/code&gt;) and constructing the appropriate conditional log likelihoods–from which the model’s total log likelihood is later derived. The distribution parameters and log-likelihoods are Theano &lt;code&gt;TensorVariable&lt;/code&gt;s–including other PyMC3-derived &lt;code&gt;TensorVariable&lt;/code&gt;s corresponding to (the output of) random variables.&lt;/p&gt;
&lt;p&gt;Again, since objects derived via algebraic manipulation of random variables are not themselves random variables within the framework of PyMC3, objects like &lt;code&gt;Z_rv&lt;/code&gt; do not have a &lt;code&gt;Distribution&lt;/code&gt; attribute. The mechanics described here provide a means for supporting terms like &lt;code&gt;Z_rv&lt;/code&gt; with the appropriate “derived” distribution.&lt;/p&gt;
&lt;p&gt;To start, we’ll have to dive deeper into the graph aspects of Theano.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="random-variables-in-graphs" class="level1"&gt;
&lt;h1&gt;Random Variables in Graphs&lt;/h1&gt;
&lt;p&gt;The Theano graph representing &lt;span class="math inline"&gt;\(\eqref{eq:norm_conv_model}\)&lt;/span&gt; consists of linear/tensor algebra operations–under the interface of &lt;code&gt;theano.gof.op.Op&lt;/code&gt;–on &lt;code&gt;TensorVariable&lt;/code&gt;s. For our example in &lt;a href="#pymc3_model"&gt;pymc3_model&lt;/a&gt;, a textual representation is given in &lt;a href="#Z_rv_debugprint"&gt;Z_rv_debugprint&lt;/a&gt; and a graphical form in &lt;a href="#fig:norm_sum_graph"&gt;fig:norm_sum_graph&lt;/a&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb7-1" title="1"&gt;tt.printing.debugprint(Z_rv)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="text"&gt;&lt;code&gt;Elemwise{add,no_inplace} [id A] &amp;#39;&amp;#39;
 |X_rv [id B]
 |Y_rv [id C]

&lt;/code&gt;&lt;/pre&gt;
&lt;figure id="fig:norm_sum_graph"&gt;
&lt;img src="https://brandonwillard.github.io/figures/Z_rv.png" alt="Graph of Z_rv for the PyMC3 model in 2. " /&gt;
&lt;figcaption&gt;
Graph of &lt;code&gt;Z_rv&lt;/code&gt; for the PyMC3 model in &lt;a href="#org7c56540"&gt;2&lt;/a&gt;.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;At present, PyMC3 (version &lt;code&gt;print(pm.__version__)&lt;/code&gt; 3.3) does not make very consistent use of Theano’s graph objects. For instance, notice how the dependent parameters &lt;code&gt;mu_X&lt;/code&gt; and &lt;code&gt;sd_X&lt;/code&gt; are not present in the model’s graph (e.g. &lt;a href="#fig:norm_sum_graph"&gt;fig:norm_sum_graph&lt;/a&gt;). We know that &lt;code&gt;X_rv&lt;/code&gt; and &lt;code&gt;Y_rv&lt;/code&gt; are PyMC3 random variables, but what we see in the graph is only their representations as sampled scalar/vector/matrix/tensor values. In other words, where &lt;span class="math inline"&gt;\(X\)&lt;/span&gt;, &lt;span class="math inline"&gt;\(Y\)&lt;/span&gt; symbolize random variables and &lt;span class="math inline"&gt;\(x \sim X\)&lt;/span&gt;, &lt;span class="math inline"&gt;\(y \sim Y\)&lt;/span&gt; their samples, we have a graph expressing only &lt;span class="math inline"&gt;\(z = x + y\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;What we need for higher-level work is a graph of &lt;span class="math inline"&gt;\(Z = X + Y\)&lt;/span&gt; that includes every term involved. This is true for graphs representing a model’s measure/log-likelihood &lt;strong&gt;and&lt;/strong&gt; its sampled values. The former is essentially covered by the log-likelihood graphs we can already produce using the PyMC3 model objects. It’s the latter that we’ll establish here, since it sets the stage for applications of numerous techniques in statistics and probability theory.&lt;/p&gt;
&lt;p&gt;One way to produce graphs that represent the full probabilistic model is to formalize the notion of random variables using the Theano API. Basically, if we want to include the relationships between distribution parameters and sampled variables, &lt;strong&gt;we need an &lt;code&gt;Op&lt;/code&gt; that represents random variables and/or the act of sampling&lt;/strong&gt;. &lt;code&gt;theano.tensor.raw_random.RandomFunction&lt;/code&gt; does exactly this; although it represents the concept of a sampling action and not exactly a random measure.&lt;/p&gt;
&lt;p&gt;Nonetheless, using &lt;code&gt;RandomFunction&lt;/code&gt;, we can replace nodes corresponding to PyMC3 random variables with newly constructed &lt;code&gt;Op&lt;/code&gt; nodes.&lt;/p&gt;
&lt;div class="example" data-markdown=""&gt;
&lt;p&gt;We can produce the types of graphs described above through conversion of existing PyMC3 models.&lt;/p&gt;
&lt;p&gt;In order to perform any manipulations on our model’s graph, we need to create a Theano &lt;code&gt;theano.gof.FunctionGraph&lt;/code&gt; object. We create a utility function in &lt;a href="#model_graph_fn"&gt;model_graph_fn&lt;/a&gt; that constructs a &lt;code&gt;FunctionGraph&lt;/code&gt; from a PyMC3 model.&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb9-1" title="1"&gt;&lt;span class="im"&gt;from&lt;/span&gt; theano.gof &lt;span class="im"&gt;import&lt;/span&gt; FunctionGraph, Feature, NodeFinder&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" title="2"&gt;&lt;span class="im"&gt;from&lt;/span&gt; theano.gof.graph &lt;span class="im"&gt;import&lt;/span&gt; inputs &lt;span class="im"&gt;as&lt;/span&gt; tt_inputs, clone_get_equiv&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" title="4"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; model_graph(pymc_model, derived_vars&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" title="6"&gt;    model &lt;span class="op"&gt;=&lt;/span&gt; pm.modelcontext(pymc_model)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" title="8"&gt;    &lt;span class="cf"&gt;if&lt;/span&gt; derived_vars &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-9" title="9"&gt;        model_outs &lt;span class="op"&gt;=&lt;/span&gt; derived_vars&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-10" title="10"&gt;    &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-11" title="11"&gt;        model_outs &lt;span class="op"&gt;=&lt;/span&gt; [o.logpt &lt;span class="cf"&gt;for&lt;/span&gt; o &lt;span class="kw"&gt;in&lt;/span&gt; model.observed_RVs]&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-12" title="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-13" title="13"&gt;    model_inputs &lt;span class="op"&gt;=&lt;/span&gt; [inp &lt;span class="cf"&gt;for&lt;/span&gt; inp &lt;span class="kw"&gt;in&lt;/span&gt; tt_inputs(model_outs)]&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-14" title="14"&gt;    &lt;span class="co"&gt;# if not isinstance(inp, theano.gof.graph.Constant)]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-15" title="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-16" title="16"&gt;    model_memo &lt;span class="op"&gt;=&lt;/span&gt; clone_get_equiv(model_inputs, model_outs,&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-17" title="17"&gt;                                 copy_orphans&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-18" title="18"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-19" title="19"&gt;    fg_features &lt;span class="op"&gt;=&lt;/span&gt; [&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-20" title="20"&gt;        NodeFinder(),&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-21" title="21"&gt;    ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-22" title="22"&gt;    model_fg &lt;span class="op"&gt;=&lt;/span&gt; FunctionGraph([model_memo[i] &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; model_inputs],&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-23" title="23"&gt;                             [model_memo[i] &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; model_outs],&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-24" title="24"&gt;                             clone&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;, features&lt;span class="op"&gt;=&lt;/span&gt;fg_features)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-25" title="25"&gt;    model_fg.memo &lt;span class="op"&gt;=&lt;/span&gt; model_memo&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-26" title="26"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-27" title="27"&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; model_fg&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When cloning the graph with &lt;code&gt;theano.gof.graph.clone_get_equiv&lt;/code&gt; in &lt;code&gt;model_graph&lt;/code&gt;, we lose the &lt;code&gt;FreeRV.distribution&lt;/code&gt; attribute–among others. Since those attributes hold all the information required to construct our &lt;code&gt;RandomFunction&lt;/code&gt; &lt;code&gt;Op&lt;/code&gt;s, we’ll need to find a way to preserve it.&lt;/p&gt;
&lt;p&gt;This can be accomplished by overriding the default Theano &lt;code&gt;clone&lt;/code&gt; function inherited by the PyMC3 random variable classes.&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb10-1" title="1"&gt;&lt;span class="im"&gt;import&lt;/span&gt; types&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" title="2"&gt;&lt;span class="im"&gt;from&lt;/span&gt; copy &lt;span class="im"&gt;import&lt;/span&gt; copy&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" title="4"&gt;pymc_rv_types &lt;span class="op"&gt;=&lt;/span&gt; (pm.model.FreeRV, pm.model.ObservedRV, pm.model.TransformedRV)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" title="6"&gt;pymc_rv_attrs &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="st"&gt;&amp;#39;dshape&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;dsize&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;distribution&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;logp_elemwiset&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" title="7"&gt;                 &lt;span class="st"&gt;&amp;#39;logp_sum_unscaledt&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;logp_nojac_unscaledt&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;total_size&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" title="8"&gt;                 &lt;span class="st"&gt;&amp;#39;scaling&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;missing_values&amp;#39;&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" title="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" title="10"&gt;&lt;span class="cf"&gt;for&lt;/span&gt; rv_type &lt;span class="kw"&gt;in&lt;/span&gt; pymc_rv_types:&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-11" title="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-12" title="12"&gt;    &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="bu"&gt;hasattr&lt;/span&gt;(rv_type, &lt;span class="st"&gt;&amp;#39;__clone&amp;#39;&lt;/span&gt;):&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-13" title="13"&gt;        rv_type.__clone &lt;span class="op"&gt;=&lt;/span&gt; rv_type.clone&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-14" title="14"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-15" title="15"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; pymc_rv_clone(&lt;span class="va"&gt;self&lt;/span&gt;):&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-16" title="16"&gt;        cp &lt;span class="op"&gt;=&lt;/span&gt; rv_type.__clone(&lt;span class="va"&gt;self&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-17" title="17"&gt;        &lt;span class="cf"&gt;for&lt;/span&gt; attr &lt;span class="kw"&gt;in&lt;/span&gt; pymc_rv_attrs:&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-18" title="18"&gt;            &lt;span class="bu"&gt;setattr&lt;/span&gt;(cp, attr, copy(&lt;span class="bu"&gt;getattr&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;, attr, &lt;span class="va"&gt;None&lt;/span&gt;)))&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-19" title="19"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-20" title="20"&gt;        &lt;span class="co"&gt;# Allow a cloned rv to inherit the context&amp;#39;s model?&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-21" title="21"&gt;        &lt;span class="co"&gt;# try:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-22" title="22"&gt;        &lt;span class="co"&gt;#     cp.model = pm.Model.get_context()&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-23" title="23"&gt;        &lt;span class="co"&gt;# except TypeError:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-24" title="24"&gt;        &lt;span class="co"&gt;#     pass&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-25" title="25"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-26" title="26"&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="bu"&gt;getattr&lt;/span&gt;(cp, &lt;span class="st"&gt;&amp;#39;model&amp;#39;&lt;/span&gt;, &lt;span class="va"&gt;None&lt;/span&gt;) &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-27" title="27"&gt;            cp.model &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;getattr&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;model&amp;#39;&lt;/span&gt;, &lt;span class="va"&gt;None&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-28" title="28"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-29" title="29"&gt;        &lt;span class="cf"&gt;return&lt;/span&gt; cp&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-30" title="30"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-31" title="31"&gt;    rv_type.clone &lt;span class="op"&gt;=&lt;/span&gt; pymc_rv_clone&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, we can produce a proper &lt;code&gt;FunctionGraph&lt;/code&gt; from our PyMC3 model.&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb11-1" title="1"&gt;Z_fgraph_tt &lt;span class="op"&gt;=&lt;/span&gt; model_graph(conv_model, derived_vars&lt;span class="op"&gt;=&lt;/span&gt;[Z_rv])&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With a &lt;code&gt;FunctionGraph&lt;/code&gt; at our disposal, we can use the graph manipulation tools provided by Theano to replace the PyMC3 &lt;code&gt;TensorVariable&lt;/code&gt;s used to represent random variables with corresponding Theano &lt;code&gt;RandomFunction&lt;/code&gt;s that represent the &lt;strong&gt;act of sampling&lt;/strong&gt; to produce said random variables.&lt;/p&gt;
&lt;p&gt;We can use a simple mapping between Pymc3 random variable nodes and &lt;code&gt;RandomFunction&lt;/code&gt; to specify the desired replacements. Fortunately, this isn’t too difficult, since &lt;code&gt;RandomFunction&lt;/code&gt; already supports numerous Numpy-provided random distributions–covering much of the same ground as the PyMC3 distributions. Otherwise, the rest of the work involves mapping distribution parameters.&lt;/p&gt;
&lt;p&gt;Also, &lt;code&gt;RandomFunction&lt;/code&gt; requires a &lt;code&gt;RandomStream&lt;/code&gt;, which it uses to track the sampler state. For our purely symbolic purposes, the stream object is not immediately useful, but it does–in the end–provide a sample-able graph as a nice side-effect. We demonstrate the PyMC3 random variable-to-&lt;code&gt;RandomFunction&lt;/code&gt; translation in &lt;a href="#random_op_mapping"&gt;random_op_mapping&lt;/a&gt; using only a single mapping.&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb12-1" title="1"&gt;&lt;span class="im"&gt;from&lt;/span&gt; theano.tensor.raw_random &lt;span class="im"&gt;import&lt;/span&gt; RandomFunction&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" title="3"&gt;pymc_theano_rv_equivs &lt;span class="op"&gt;=&lt;/span&gt; {&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" title="4"&gt;    pm.Normal:&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" title="5"&gt;    &lt;span class="kw"&gt;lambda&lt;/span&gt; dist, rand_state:&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-6" title="6"&gt;    tt.raw_random.normal(rand_state, dist.shape.tolist(), dist.mu, dist.sd),&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-7" title="7"&gt;}&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb13-1" title="1"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; create_theano_rvs(fgraph, clone&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;, rand_state&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" title="2"&gt;    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot;Replace PyMC3 random variables with `RandomFunction` Ops.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" title="4"&gt;&lt;span class="co"&gt;    &lt;/span&gt;&lt;span class="al"&gt;TODO&lt;/span&gt;&lt;span class="co"&gt;: Could use a Theano graph `Feature` to trace--or even&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" title="5"&gt;&lt;span class="co"&gt;    replace--random variables.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" title="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" title="7"&gt;&lt;span class="co"&gt;    Parameters&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-8" title="8"&gt;&lt;span class="co"&gt;    ----------&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-9" title="9"&gt;&lt;span class="co"&gt;    fgraph : FunctionGraph&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-10" title="10"&gt;&lt;span class="co"&gt;    A graph containing PyMC3 random variables.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-11" title="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-12" title="12"&gt;&lt;span class="co"&gt;    clone: bool, optional&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-13" title="13"&gt;&lt;span class="co"&gt;    Clone the original graph.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-14" title="14"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-15" title="15"&gt;&lt;span class="co"&gt;    rand_state : RandomStateType, optional&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-16" title="16"&gt;&lt;span class="co"&gt;    The Theano random state.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-17" title="17"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-18" title="18"&gt;&lt;span class="co"&gt;    Returns&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-19" title="19"&gt;&lt;span class="co"&gt;    -------&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-20" title="20"&gt;&lt;span class="co"&gt;    out : A cloned graph with random variables replaced and a `memo` attribute.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-21" title="21"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-22" title="22"&gt;&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-23" title="23"&gt;    &lt;span class="cf"&gt;if&lt;/span&gt; clone:&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-24" title="24"&gt;        fgraph_, fgraph_memo_ &lt;span class="op"&gt;=&lt;/span&gt; fgraph.clone_get_equiv(attach_feature&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-25" title="25"&gt;        fgraph_.memo &lt;span class="op"&gt;=&lt;/span&gt; fgraph_memo_&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-26" title="26"&gt;    &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-27" title="27"&gt;        fgraph_ &lt;span class="op"&gt;=&lt;/span&gt; fgraph&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-28" title="28"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-29" title="29"&gt;    &lt;span class="cf"&gt;if&lt;/span&gt; rand_state &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-30" title="30"&gt;        rand_state &lt;span class="op"&gt;=&lt;/span&gt; theano.shared(np.random.RandomState())&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-31" title="31"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-32" title="32"&gt;    fgraph_replacements &lt;span class="op"&gt;=&lt;/span&gt; {}&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-33" title="33"&gt;    fgraph_new_inputs &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;set&lt;/span&gt;()&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-34" title="34"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-35" title="35"&gt;    &lt;span class="cf"&gt;for&lt;/span&gt; old_rv_i, old_rv &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(fgraph_.inputs):&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-36" title="36"&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="bu"&gt;isinstance&lt;/span&gt;(old_rv, pymc_rv_types):&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-37" title="37"&gt;            dist &lt;span class="op"&gt;=&lt;/span&gt; old_rv.distribution&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-38" title="38"&gt;            theano_rv_op &lt;span class="op"&gt;=&lt;/span&gt; pymc_theano_rv_equivs.get(&lt;span class="bu"&gt;type&lt;/span&gt;(dist), &lt;span class="va"&gt;None&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-39" title="39"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-40" title="40"&gt;            &lt;span class="cf"&gt;if&lt;/span&gt; theano_rv_op &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-41" title="41"&gt;                rng_tt, new_rv &lt;span class="op"&gt;=&lt;/span&gt; theano_rv_op(dist, rand_state)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-42" title="42"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-43" title="43"&gt;                &lt;span class="co"&gt;# Keep track of our replacements&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-44" title="44"&gt;                fgraph_replacements[old_rv] &lt;span class="op"&gt;=&lt;/span&gt; new_rv&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-45" title="45"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-46" title="46"&gt;                new_rv.name &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;~&lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(old_rv.name)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-47" title="47"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-48" title="48"&gt;                new_rv_inputs &lt;span class="op"&gt;=&lt;/span&gt; [i &lt;span class="cf"&gt;for&lt;/span&gt; i &lt;span class="kw"&gt;in&lt;/span&gt; tt_inputs([new_rv])]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-49" title="49"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-50" title="50"&gt;                fgraph_new_inputs.update(new_rv_inputs)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-51" title="51"&gt;            &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-52" title="52"&gt;                &lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt; could not be mapped to a random function&amp;#39;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(old_rv))&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-53" title="53"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-54" title="54"&gt;    fgraph_new_inputs_memo &lt;span class="op"&gt;=&lt;/span&gt; theano.gof.graph.clone_get_equiv(&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-55" title="55"&gt;        fgraph_new_inputs, &lt;span class="bu"&gt;list&lt;/span&gt;(fgraph_replacements.values()),&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-56" title="56"&gt;        copy_orphans&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-57" title="57"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-58" title="58"&gt;    &lt;span class="co"&gt;# Update our maps and new inputs to use the cloned objects&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-59" title="59"&gt;    fgraph_replacements &lt;span class="op"&gt;=&lt;/span&gt; {old_rv: fgraph_new_inputs_memo.pop(new_rv)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-60" title="60"&gt;                           &lt;span class="cf"&gt;for&lt;/span&gt; old_rv, new_rv &lt;span class="kw"&gt;in&lt;/span&gt; fgraph_replacements.items()}&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-61" title="61"&gt;    fgraph_new_inputs &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;set&lt;/span&gt;(&lt;span class="bu"&gt;map&lt;/span&gt;(fgraph_new_inputs_memo.pop, fgraph_new_inputs))&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-62" title="62"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-63" title="63"&gt;    &lt;span class="co"&gt;# What remains in `fgraph_new_inputs_memo` are the nodes between our desired&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-64" title="64"&gt;    &lt;span class="co"&gt;# inputs (i.e. the random variables&amp;#39; distribution parameters) and the old inputs&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-65" title="65"&gt;    &lt;span class="co"&gt;# (i.e. Theano `Variable`s corresponding to a sample of said random variables).&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-66" title="66"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-67" title="67"&gt;    _ &lt;span class="op"&gt;=&lt;/span&gt; [fgraph_.add_input(new_in) &lt;span class="cf"&gt;for&lt;/span&gt; new_in &lt;span class="kw"&gt;in&lt;/span&gt; fgraph_new_inputs&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-68" title="68"&gt;         &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="bu"&gt;isinstance&lt;/span&gt;(new_in, theano.gof.graph.Constant)]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-69" title="69"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-70" title="70"&gt;    &lt;span class="co"&gt;# _ = [fgraph_.add_input(new_in) for new_in in fgraph_new_inputs_memo.values()]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-71" title="71"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-72" title="72"&gt;    fgraph_.replace_all(fgraph_replacements.items())&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-73" title="73"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-74" title="74"&gt;    &lt;span class="co"&gt;# The replace method apparently doesn&amp;#39;t remove the old inputs...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-75" title="75"&gt;    _ &lt;span class="op"&gt;=&lt;/span&gt; [fgraph_.inputs.remove(old_rv) &lt;span class="cf"&gt;for&lt;/span&gt; old_rv &lt;span class="kw"&gt;in&lt;/span&gt; fgraph_replacements.keys()]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-76" title="76"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-77" title="77"&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; fgraph_&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb14-1" title="1"&gt;Z_fgraph_rv_tt &lt;span class="op"&gt;=&lt;/span&gt; create_theano_rvs(Z_fgraph_tt)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" title="3"&gt;tt.printing.debugprint(Z_fgraph_rv_tt)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="text"&gt;&lt;code&gt;Elemwise{add,no_inplace} [id A] &amp;#39;&amp;#39;   10
 |RandomFunction{normal}.1 [id B] &amp;#39;~X_rv&amp;#39;   9
 | |&amp;lt;RandomStateType&amp;gt; [id C]
 | |Elemwise{Cast{int64}} [id D] &amp;#39;&amp;#39;   8
 | | |MakeVector{dtype=&amp;#39;int8&amp;#39;} [id E] &amp;#39;&amp;#39;   7
 | |   |TensorConstant{1} [id F]
 | |mu_X [id G]
 | |Elemwise{mul,no_inplace} [id H] &amp;#39;&amp;#39;   6
 |   |InplaceDimShuffle{x} [id I] &amp;#39;&amp;#39;   5
 |   | |TensorConstant{1.0} [id J]
 |   |sd_X [id K]
 |RandomFunction{normal}.1 [id L] &amp;#39;~Y_rv&amp;#39;   4
   |&amp;lt;RandomStateType&amp;gt; [id C]
   |Elemwise{Cast{int64}} [id M] &amp;#39;&amp;#39;   3
   | |MakeVector{dtype=&amp;#39;int8&amp;#39;} [id N] &amp;#39;&amp;#39;   2
   |   |TensorConstant{1} [id F]
   |mu_Y [id O]
   |Elemwise{mul,no_inplace} [id P] &amp;#39;&amp;#39;   1
     |InplaceDimShuffle{x} [id Q] &amp;#39;&amp;#39;   0
     | |TensorConstant{1.0} [id J]
     |sd_Y [id R]

&lt;/code&gt;&lt;/pre&gt;
&lt;figure id="fig:random_op_mapping_exa_graph"&gt;
&lt;img src="https://brandonwillard.github.io/figures/Z_fgraph_rv_tt.png" alt="Graph of Z = X + Y using an Op to represent sampling/a random variable. " /&gt;
&lt;figcaption&gt;
Graph of &lt;span class="math inline"&gt;\(Z = X + Y\)&lt;/span&gt; using an &lt;code&gt;Op&lt;/code&gt; to represent sampling/a random variable.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Illustrations of the transformed graphs given in &lt;a href="#random_op_mapping_exa"&gt;random_op_mapping_exa&lt;/a&gt; and &lt;a href="#fig:random_op_mapping_exa_graph"&gt;fig:random_op_mapping_exa_graph&lt;/a&gt; show the full extent of our simple example model and provide a context in which to perform higher-level manipulations.&lt;/p&gt;
&lt;p&gt;With a graph representing the relevant terms and relationships, we can implement the convolution simplification/transformation/optimization. For instance, as shown in &lt;a href="#rv_find_nodes"&gt;rv_find_nodes&lt;/a&gt;, we can now easily query random function/variable nodes in a graph.&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb16-1" title="1"&gt;&lt;span class="co"&gt;# Using a `FunctionGraph` &amp;quot;feature&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" title="2"&gt;Z_fgraph_rv_tt.attach_feature(NodeFinder())&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-4" title="4"&gt;&lt;span class="co"&gt;# The fixed `TensorType` is unnecessarily restrictive.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-5" title="5"&gt;rf_normal_type &lt;span class="op"&gt;=&lt;/span&gt; RandomFunction(&lt;span class="st"&gt;&amp;#39;normal&amp;#39;&lt;/span&gt;, tt.TensorType(&lt;span class="st"&gt;&amp;#39;float64&amp;#39;&lt;/span&gt;, (&lt;span class="va"&gt;True&lt;/span&gt;,)))&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-6" title="6"&gt;rf_nodes &lt;span class="op"&gt;=&lt;/span&gt; Z_fgraph_rv_tt.get_nodes(rf_normal_type)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-8" title="8"&gt;&lt;span class="co"&gt;#&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-9" title="9"&gt;&lt;span class="co"&gt;# or, more generally,...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-10" title="10"&gt;&lt;span class="co"&gt;#&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-11" title="11"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; get_random_nodes(fgraph):&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-12" title="12"&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;list&lt;/span&gt;(&lt;span class="bu"&gt;filter&lt;/span&gt;(&lt;span class="kw"&gt;lambda&lt;/span&gt; x: &lt;span class="bu"&gt;isinstance&lt;/span&gt;(x.op, RandomFunction), fgraph.apply_nodes))&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-13" title="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-14" title="14"&gt;rf_nodes &lt;span class="op"&gt;=&lt;/span&gt; get_random_nodes(Z_fgraph_rv_tt)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-15" title="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-16" title="16"&gt;tt.printing.debugprint(rf_nodes)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="text"&gt;&lt;code&gt;RandomFunction{normal}.0 [id A] &amp;#39;&amp;#39;
 |&amp;lt;RandomStateType&amp;gt; [id B]
 |Elemwise{Cast{int64}} [id C] &amp;#39;&amp;#39;
 | |MakeVector{dtype=&amp;#39;int8&amp;#39;} [id D] &amp;#39;&amp;#39;
 |   |TensorConstant{1} [id E]
 |mu_X [id F]
 |Elemwise{mul,no_inplace} [id G] &amp;#39;&amp;#39;
   |InplaceDimShuffle{x} [id H] &amp;#39;&amp;#39;
   | |TensorConstant{1.0} [id I]
   |sd_X [id J]
RandomFunction{normal}.1 [id A] &amp;#39;~X_rv&amp;#39;
RandomFunction{normal}.0 [id K] &amp;#39;&amp;#39;
 |&amp;lt;RandomStateType&amp;gt; [id B]
 |Elemwise{Cast{int64}} [id L] &amp;#39;&amp;#39;
 | |MakeVector{dtype=&amp;#39;int8&amp;#39;} [id M] &amp;#39;&amp;#39;
 |   |TensorConstant{1} [id E]
 |mu_Y [id N]
 |Elemwise{mul,no_inplace} [id O] &amp;#39;&amp;#39;
   |InplaceDimShuffle{x} [id P] &amp;#39;&amp;#39;
   | |TensorConstant{1.0} [id I]
   |sd_Y [id Q]
RandomFunction{normal}.1 [id K] &amp;#39;~Y_rv&amp;#39;

&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;section id="performing-high-level-simplifications" class="level1"&gt;
&lt;h1&gt;Performing High-level Simplifications&lt;/h1&gt;
&lt;p&gt;To apply optimizations like our simple convolution, we need to first identify the appropriate circumstances for its application. This means finding all sub-graphs for which we are able to replace existing nodes with a convolution node.&lt;/p&gt;
&lt;p&gt;Theano provides some &lt;a href="https://en.wikipedia.org/wiki/Unification_(computer_science)"&gt;unification&lt;/a&gt; tools that facilitate the search component. We’ll use those to implement an extremely restrictive form of our convolution.&lt;/p&gt;
&lt;div class="example" data-markdown=""&gt;
&lt;p&gt;In &lt;a href="#normal_conv_pattern"&gt;normal_conv_pattern&lt;/a&gt;, we create patterns for our expressions of interest that are unified against the elements in our graph and reified with a replacement expression. The patterns are expressed as tuples in a LISP-like fashion, e.g. &lt;code&gt;(add, 1, 2)&lt;/code&gt; corresponding to an unevaluated &lt;code&gt;add(1, 2)&lt;/code&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb18-1" title="1"&gt;&lt;span class="im"&gt;from&lt;/span&gt; operator &lt;span class="im"&gt;import&lt;/span&gt; attrgetter, itemgetter&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-4" title="4"&gt;&lt;span class="co"&gt;# &lt;/span&gt;&lt;span class="al"&gt;FIXME&lt;/span&gt;&lt;span class="co"&gt;: This fixed `TensorType` specification is restrictive.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-5" title="5"&gt;NormalRV &lt;span class="op"&gt;=&lt;/span&gt; RandomFunction(&lt;span class="st"&gt;&amp;#39;normal&amp;#39;&lt;/span&gt;, tt.TensorType(&lt;span class="st"&gt;&amp;#39;float64&amp;#39;&lt;/span&gt;, (&lt;span class="va"&gt;True&lt;/span&gt;,)))&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-6" title="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-7" title="7"&gt;norm_conv_pat_tt &lt;span class="op"&gt;=&lt;/span&gt; [&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-8" title="8"&gt;    tt.gof.opt.PatternSub(&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-9" title="9"&gt;        &lt;span class="co"&gt;# Search expression pattern&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-10" title="10"&gt;      (tt.add,&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-11" title="11"&gt;       (NormalRV, &lt;span class="st"&gt;&amp;#39;rs_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;shp_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;mu_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;sd_x&amp;#39;&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-12" title="12"&gt;       (NormalRV, &lt;span class="st"&gt;&amp;#39;rs_y&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;shp_y&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;mu_y&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;sd_y&amp;#39;&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-13" title="13"&gt;      ),&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-14" title="14"&gt;        &lt;span class="co"&gt;# Replacement expression&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-15" title="15"&gt;      (itemgetter(&lt;span class="dv"&gt;1&lt;/span&gt;), &lt;span class="co"&gt;#&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-16" title="16"&gt;       (NormalRV,&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-17" title="17"&gt;        &lt;span class="st"&gt;&amp;#39;rs_x&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-18" title="18"&gt;        &lt;span class="st"&gt;&amp;#39;shp_x&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-19" title="19"&gt;        (tt.add, &lt;span class="st"&gt;&amp;#39;mu_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;mu_y&amp;#39;&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-20" title="20"&gt;        (tt.sqrt, (tt.add, (tt.square, &lt;span class="st"&gt;&amp;#39;sd_x&amp;#39;&lt;/span&gt;), (tt.square, &lt;span class="st"&gt;&amp;#39;sd_y&amp;#39;&lt;/span&gt;))),&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-21" title="21"&gt;       )),&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-22" title="22"&gt;    ),&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-23" title="23"&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;itemgetter(1)&lt;/code&gt; applied to the replacement result is necessary because the &lt;code&gt;Op&lt;/code&gt; &lt;code&gt;RandomFunction&lt;/code&gt; returns two outputs and the second is the &lt;code&gt;TensorVariable&lt;/code&gt; corresponding to a sample from that random variable.&lt;/p&gt;
&lt;p&gt;We also need to specify exactly how the pattern matching and replacement are to be performed for the entire graph. Do we match a single sum of normal distributions or all of them? What happens when a replacement creates yet another sum of normals that can be reduced?&lt;/p&gt;
&lt;p&gt;In this case, we choose to apply the operation until it reaches a fixed point, i.e. until it produces no changes in the graph.&lt;/p&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb19-1" title="1"&gt;norm_conv_opt_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.gof.opt.EquilibriumOptimizer(norm_conv_pat_tt,&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-2" title="2"&gt;                                                   max_use_ratio&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, we manually perform our Theano optimization.&lt;/p&gt;
&lt;div class="sourceCode" id="cb20"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb20-1" title="1"&gt;_ &lt;span class="op"&gt;=&lt;/span&gt; norm_conv_opt_tt.optimize(Z_fgraph_rv_tt)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The optimization was applied within our graph, as evidenced by the single new &lt;code&gt;RandomFunction&lt;/code&gt; node.&lt;/p&gt;
&lt;div class="sourceCode" id="cb21"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb21-1" title="1"&gt;tt.printing.debugprint(Z_fgraph_rv_tt)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="text"&gt;&lt;code&gt;RandomFunction{normal}.1 [id A] &amp;#39;&amp;#39;   11
 |&amp;lt;RandomStateType&amp;gt; [id B]
 |Elemwise{Cast{int64}} [id C] &amp;#39;&amp;#39;   10
 | |MakeVector{dtype=&amp;#39;int8&amp;#39;} [id D] &amp;#39;&amp;#39;   9
 |   |TensorConstant{1} [id E]
 |Elemwise{add,no_inplace} [id F] &amp;#39;&amp;#39;   8
 | |mu_X [id G]
 | |mu_Y [id H]
 |Elemwise{sqrt,no_inplace} [id I] &amp;#39;&amp;#39;   7
   |Elemwise{add,no_inplace} [id J] &amp;#39;&amp;#39;   6
     |Elemwise{sqr,no_inplace} [id K] &amp;#39;&amp;#39;   5
     | |Elemwise{mul,no_inplace} [id L] &amp;#39;&amp;#39;   4
     |   |InplaceDimShuffle{x} [id M] &amp;#39;&amp;#39;   3
     |   | |TensorConstant{1.0} [id N]
     |   |sd_X [id O]
     |Elemwise{sqr,no_inplace} [id P] &amp;#39;&amp;#39;   2
       |Elemwise{mul,no_inplace} [id Q] &amp;#39;&amp;#39;   1
         |InplaceDimShuffle{x} [id R] &amp;#39;&amp;#39;   0
         | |TensorConstant{1.0} [id N]
         |sd_Y [id S]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Likewise, the resulting distribution terms in the optimized graph reflect the normal-normal random variable sum. Figure &lt;a href="#fig:norm_sum_merge_graph"&gt;fig:norm_sum_merge_graph&lt;/a&gt; shows the graph under our optimization.&lt;/p&gt;
&lt;div class="sourceCode" id="cb23"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb23-1" title="1"&gt;conv_rv_tt &lt;span class="op"&gt;=&lt;/span&gt; Z_fgraph_rv_tt.outputs[&lt;span class="dv"&gt;0&lt;/span&gt;].owner&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-3" title="3"&gt;new_mu, new_sd &lt;span class="op"&gt;=&lt;/span&gt; conv_rv_tt.inputs[&lt;span class="dv"&gt;2&lt;/span&gt;:&lt;span class="dv"&gt;4&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-5" title="5"&gt;&lt;span class="co"&gt;# Test values of the original means/new moments&amp;#39; inputs&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-6" title="6"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;, &amp;#39;&lt;/span&gt;.join([&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt; = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(tt.pprint(o), o.tag.test_value)&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-7" title="7"&gt;                 &lt;span class="cf"&gt;for&lt;/span&gt; o &lt;span class="kw"&gt;in&lt;/span&gt; new_mu.owner.inputs]))&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-8" title="8"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(tt.pprint(new_mu))&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-9" title="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-10" title="10"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;, &amp;#39;&lt;/span&gt;.join([&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt; = &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(tt.pprint(o), o.tag.test_value)&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-11" title="11"&gt;                 &lt;span class="cf"&gt;for&lt;/span&gt; o &lt;span class="kw"&gt;in&lt;/span&gt; new_sd.owner.inputs]))&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-12" title="12"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(tt.pprint(new_sd))&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-13" title="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-14" title="14"&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st"&gt;&amp;#39;mean: &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="ch"&gt;\n&lt;/span&gt;&lt;span class="st"&gt;std. dev.: &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-15" title="15"&gt;    new_mu.tag.test_value,&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-16" title="16"&gt;    new_sd.tag.test_value))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre class="text"&gt;&lt;code&gt;mu_X = [0.], mu_Y = [1.]
(mu_X + mu_Y)
(sqr((TensorConstant{1.0} * sd_X)) + sqr((TensorConstant{1.0} * sd_Y))) = [1.25]
sqrt((sqr((TensorConstant{1.0} * sd_X)) + sqr((TensorConstant{1.0} * sd_Y))))
mean: [1.]
std. dev.: [1.11803399]

&lt;/code&gt;&lt;/pre&gt;
&lt;figure id="fig:norm_sum_merge_graph"&gt;
&lt;img src="https://brandonwillard.github.io/figures/Z_fgraph_opt_tt.png" alt="Graph of merged normal variables. " /&gt;
&lt;figcaption&gt;
Graph of merged normal variables.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/section&gt;
&lt;section id="generalizing-operations" class="level1"&gt;
&lt;h1&gt;Generalizing Operations&lt;/h1&gt;
&lt;p&gt;Our example above was admittedly too simple; for instance, what about scale and location transformed variables? Most models/graphs will consist of more elaborate manipulations of random variables, so it’s necessary that we account for as many basic manipulations, as well.&lt;/p&gt;
&lt;p&gt;We start by adding an optimization that lifts scale parameters into the arguments/parameters of a random variable. In other words,&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{gather*}
  X \sim N(\mu, \sigma^2) \\
  Z = a X \sim N\left(a \mu, (a \sigma)^2\right)
  \;.
\end{gather*}\]&lt;/span&gt;&lt;/p&gt;
&lt;div class="sourceCode" id="cb25"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb25-1" title="1"&gt;norm_conv_pat_tt &lt;span class="op"&gt;+=&lt;/span&gt; [&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-2" title="2"&gt;    tt.gof.opt.PatternSub(&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-3" title="3"&gt;        &lt;span class="co"&gt;# Search expression pattern&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-4" title="4"&gt;        (tt.mul,&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-5" title="5"&gt;         &lt;span class="st"&gt;&amp;#39;a_x&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-6" title="6"&gt;         (NormalRV, &lt;span class="st"&gt;&amp;#39;rs_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;shp_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;mu_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;sd_x&amp;#39;&lt;/span&gt;)),&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-7" title="7"&gt;        &lt;span class="co"&gt;# Replacement expression&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-8" title="8"&gt;        (itemgetter(&lt;span class="dv"&gt;1&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-9" title="9"&gt;         (NormalRV,&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-10" title="10"&gt;          &lt;span class="co"&gt;# RNG&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-11" title="11"&gt;                &lt;span class="st"&gt;&amp;#39;rs_x&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-12" title="12"&gt;          &lt;span class="co"&gt;# Convolution shape&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-13" title="13"&gt;                &lt;span class="st"&gt;&amp;#39;shp_x&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-14" title="14"&gt;          &lt;span class="co"&gt;# Convolution mean&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-15" title="15"&gt;                (tt.mul, &lt;span class="st"&gt;&amp;#39;a_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;mu_x&amp;#39;&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-16" title="16"&gt;          &lt;span class="co"&gt;# Convolution std. dev.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-17" title="17"&gt;                (tt.mul, &lt;span class="st"&gt;&amp;#39;a_x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;sd_x&amp;#39;&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-18" title="18"&gt;         )),&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-19" title="19"&gt;    )&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-20" title="20"&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-21" title="21"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-22" title="22"&gt;norm_conv_opt_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.gof.opt.EquilibriumOptimizer(&lt;/a&gt;
&lt;a class="sourceLine" id="cb25-23" title="23"&gt;    norm_conv_pat_tt, max_use_ratio&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The additional optimization is demonstrated in &lt;a href="#mat_mul_scaling_exa"&gt;mat_mul_scaling_exa&lt;/a&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb26"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb26-1" title="1"&gt;mu_X &lt;span class="op"&gt;=&lt;/span&gt; tt.vector(&lt;span class="st"&gt;&amp;#39;mu_X&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-2" title="2"&gt;mu_X.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([&lt;span class="fl"&gt;0.&lt;/span&gt;], dtype&lt;span class="op"&gt;=&lt;/span&gt;tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-3" title="3"&gt;sd_X &lt;span class="op"&gt;=&lt;/span&gt; tt.vector(&lt;span class="st"&gt;&amp;#39;sd_X&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-4" title="4"&gt;sd_X.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([&lt;span class="fl"&gt;1.&lt;/span&gt;], dtype&lt;span class="op"&gt;=&lt;/span&gt;tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-6" title="6"&gt;&lt;span class="cf"&gt;with&lt;/span&gt; pm.Model() &lt;span class="im"&gt;as&lt;/span&gt; conv_scale_model:&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-7" title="7"&gt;    X_rv &lt;span class="op"&gt;=&lt;/span&gt; pm.Normal(&lt;span class="st"&gt;&amp;#39;X_rv&amp;#39;&lt;/span&gt;, mu_X, sd&lt;span class="op"&gt;=&lt;/span&gt;sd_X, shape&lt;span class="op"&gt;=&lt;/span&gt;(&lt;span class="dv"&gt;1&lt;/span&gt;,))&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-8" title="8"&gt;    Z_rv &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; X_rv&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-9" title="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-10" title="10"&gt;Z_mul_tt &lt;span class="op"&gt;=&lt;/span&gt; model_graph(conv_scale_model, derived_vars&lt;span class="op"&gt;=&lt;/span&gt;[Z_rv])&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-11" title="11"&gt;Z_mul_rv &lt;span class="op"&gt;=&lt;/span&gt; create_theano_rvs(Z_mul_tt)&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-12" title="12"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-13" title="13"&gt;Z_mul_rv_merged &lt;span class="op"&gt;=&lt;/span&gt; Z_mul_rv.clone()&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-14" title="14"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb26-15" title="15"&gt;_ &lt;span class="op"&gt;=&lt;/span&gt; norm_conv_opt_tt.optimize(Z_mul_rv_merged)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="#fig:scaled_random_sum_before"&gt;fig:scaled_random_sum_before&lt;/a&gt; and &lt;a href="#fig:scaled_random_sum_after"&gt;fig:scaled_random_sum_after&lt;/a&gt; demonstrate the a scaled normal random variable before and after the optimization, respectively.&lt;/p&gt;
&lt;figure id="fig:scaled_random_sum_before"&gt;
&lt;img src="https://brandonwillard.github.io/figures/Z_mul_rv.png" alt="Graph of a single term scaled in a normal-normal convolution. " /&gt;
&lt;figcaption&gt;
Graph of a single term scaled in a normal-normal convolution.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure id="fig:scaled_random_sum_after"&gt;
&lt;img src="https://brandonwillard.github.io/figures/Z_mul_rv_merged.png" alt="Graph of a single term scaled in a normal-normal convolution after the convolution optimization. " /&gt;
&lt;figcaption&gt;
Graph of a single term scaled in a normal-normal convolution after the convolution optimization.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/section&gt;
&lt;section id="challenges" class="level1"&gt;
&lt;h1&gt;Challenges&lt;/h1&gt;
&lt;p&gt;If we change the dimensions of our example above, the pattern employed by our scaling optimization will not match. To fix this, we can generalize the form of our &lt;code&gt;RandomFunction&lt;/code&gt; operator so that it includes more cases of broadcastable dimensions–instead of only &lt;code&gt;(True, )&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;We could also extend the reach of our &lt;code&gt;PatternSub&lt;/code&gt;s; however, this direction introduces more complexity into the process of writing optimizations and provides no foreseeable benefit elsewhere.&lt;/p&gt;
&lt;p&gt;More generally, one of the major challenges in this kind of work is due to the design of &lt;code&gt;RandomFunction&lt;/code&gt;; its type is dependent on a &lt;code&gt;TensorType&lt;/code&gt; parameter that requires an array of “broadcast” dimensions.&lt;/p&gt;
&lt;p&gt;This situation arises–in part–from PyMC3, Theano, and NumPy’s use of a “size” parameter in combination with random variable dimensions inferred from distribution parameters. A few outstanding &lt;a href="https://github.com/pymc-devs/pymc3/pull/1125"&gt;PyMC3 issues seem to revolve&lt;/a&gt; around the interactions between these elements.&lt;/p&gt;
&lt;p&gt;The size parameter is like a sample size, but with all the samples considered together as a single tensor (e.g. each sample of a multivariate normal random variable, say, acting as a column in a matrix). The size parameter is independent of a random variable’s parameters’ sizes (e.g. dimensions of a mean and covariance), but, together, the size and distribution parameters effectively compose the size/dimension of a random variable’s support (e.g. the matrix in the above example is the resulting random variable).&lt;/p&gt;
&lt;p&gt;Needless to say, PyMC3 and Theano’s terms–and their relation to mathematical notions–are a bit confusing, and likely driven more by software design choices than the mathematical frameworks in use. However, those design choices significantly affect our ability to manipulate graphs and express common mathematical notions. For instance, these terms and design choices put greater demand on the graph manipulation steps, due to the ambiguous dimensions of the elements involved.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="next-steps" class="level1"&gt;
&lt;h1&gt;Next Steps&lt;/h1&gt;
&lt;p&gt;In a follow-up, I’ll introduce a new &lt;code&gt;Op&lt;/code&gt; that overcomes some of the dimensionality issues and allows for much easier graph manipulation. It replaces &lt;code&gt;RandomFunction&lt;/code&gt; with a single &lt;code&gt;Op&lt;/code&gt; for each distribution type and [re]moves the type specifier from the definition of the &lt;code&gt;Op&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Essentially, the &lt;code&gt;TensorType&lt;/code&gt; argument to the &lt;code&gt;RandomFunction&lt;/code&gt; constructor is moved into &lt;code&gt;RandomFunction&lt;/code&gt;’s &lt;code&gt;make_node&lt;/code&gt; method and, thus, generated/inferred from the symbolic inputs.&lt;/p&gt;
&lt;p&gt;To be clear, we’re talking about two distinct aspects of &lt;code&gt;RandomFunction&lt;/code&gt;: one is the &lt;code&gt;NormalRV = RandomFunction('normal', TensorType('float64', bcast))&lt;/code&gt; step, in which we &lt;strong&gt;create the &lt;code&gt;Op&lt;/code&gt;&lt;/strong&gt; corresponding to a specific type of normal random variable, and the other in which we &lt;strong&gt;use the &lt;code&gt;Op&lt;/code&gt;&lt;/strong&gt; (e.g. &lt;code&gt;NormalRV(rng, 1, 2)&lt;/code&gt;)–to, say, produce a tensor variable corresponding to an instance of said random variable.&lt;/p&gt;
&lt;p&gt;This distinction is important for pattern matching because &lt;code&gt;NormalRV&lt;/code&gt;, as defined above, isn’t very general and mostly due to the &lt;code&gt;TensorType('float64', bcast))&lt;/code&gt; covering only some Theano tensor types (i.e. those that match the fixed broadcast dimensions specified by &lt;code&gt;bcast&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;As stated previously, there have been real difficulties with the handling of shape and type information in PyMC3 (see &lt;a href="https://github.com/pymc-devs/pymc3/pull/1125"&gt;PyMC3 PR 1125&lt;/a&gt;). These problems are related to the same concerns involving &lt;code&gt;TensorType&lt;/code&gt;s. In refactoring the type information requirement for &lt;code&gt;RandomFunction&lt;/code&gt;, we’ll end up addressing those PyMC3 issues as well.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="bibliography" class="level1"&gt;
&lt;h1&gt;Bibliography&lt;/h1&gt;
&lt;p&gt;&lt;a id="WillardRoleSymbolicComputation2017"&gt;&lt;/a&gt;[WillardRoleSymbolicComputation2017] Willard, A Role for Symbolic Computation in the General Estimation of Statistical Models, &lt;i&gt;Brandon T. Willard&lt;/i&gt;, (2017). &lt;a href="https://brandonwillard.github.io/a-role-for-symbolic-computation-in-the-general-estimation-of-statistical-models.html"&gt;link&lt;/a&gt;. &lt;a href="#4407b21e48ab9ff17c017e8d62684725"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;script type="text/x-mathjax-config"&gt;
MathJax.Hub.Config({
  CommonHTML: { linebreaks: { automatic: true } },
  "HTML-CSS": { linebreaks: { automatic: true } },
  SVG: { linebreaks: { automatic: true } },
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</content><category term="pymc3"></category><category term="theano"></category><category term="statistics"></category><category term="symbolic computation"></category><category term="python"></category><category term="probability theory"></category></entry><entry><title>More Proximal Estimation</title><link href="https://brandonwillard.github.io/more-proximal-estimation.html" rel="alternate"></link><published>2017-03-06T00:00:00-06:00</published><updated>2017-03-06T00:00:00-06:00</updated><author><name>Brandon T. Willard</name></author><id>tag:brandonwillard.github.io,2017-03-06:/more-proximal-estimation.html</id><summary type="html"></summary><content type="html">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
  &lt;meta http-equiv="Content-Style-Type" content="text/css" /&gt;
  &lt;meta name="generator" content="pandoc" /&gt;
  &lt;meta name="author" content="Brandon T. Willard" /&gt;
  &lt;title&gt;More Proximal Estimation&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  &lt;/style&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--  --&gt;
&lt;!-- &lt;div id="header"&gt; --&gt;
&lt;!-- &lt;h1 class="title"&gt;More Proximal Estimation&lt;/h1&gt; --&gt;
&lt;!--  --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;h2 class="author"&gt;Brandon T. Willard&lt;/h2&gt; --&gt;
&lt;!--  --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;h3 class="date"&gt;2017–03–06&lt;/h3&gt; --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;/div&gt; --&gt;
&lt;!--  --&gt;
&lt;section id="introduction" class="level1"&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The focal point of this short exposition will be an elaboration of the basic &lt;span class="math inline"&gt;\(\ell_1\)&lt;/span&gt; penalization problem discussed in &lt;span class="citation" data-cites="willard_role_2017"&gt;Willard (2017)&lt;/span&gt;, &lt;span class="math display"&gt;\[\begin{equation}
\operatorname*{argmin}_{\beta} \left\{
  \frac{1}{2} \|y - X \beta\|^2_2
    + \lambda \|\beta\|_1
  \right\}
  \;.
  \label{eq:lasso}
\end{equation}\]&lt;/span&gt; We continue our discussion on topics concerning automation and symbolic computation in Theano &lt;span class="citation" data-cites="bergstra_theano_2010"&gt;(Bergstra et al. 2010)&lt;/span&gt;, as well as the mathematical methodology we believe is suitable for such implementations. Again, our framing of the problem is in terms of “proximal methods” &lt;span class="citation" data-cites="parikh_proximal_2014 combettes_proximal_2011"&gt;(Parikh and Boyd 2014; Combettes and Pesquet 2011)&lt;/span&gt;. Along the way we propose one simple means of placing the well-known technique of coordinate descent within the scope of proximal methods via a general property of proximal operators. These efforts are a continued outgrowth of our work in &lt;span class="citation" data-cites="polson_proximal_2015"&gt;Polson, Scott, and Willard (2015)&lt;/span&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="proximal-and-computational-components" class="level1"&gt;
&lt;h1&gt;Proximal and Computational Components&lt;/h1&gt;
&lt;p&gt;First, we [re]-introduce the workhorse of proximal methods: the &lt;em&gt;proximal operator&lt;/em&gt;.&lt;/p&gt;
&lt;div class="definition" data-markdown="" data-title-name="[Proximal Operator]"&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{equation*}
\operatorname*{prox}_{\phi}(x) =
    \operatorname*{argmin}_{z} \left\{
    \frac{1}{2} \left(z - x\right)^2 + \phi(z)
    \right\}
    \;.
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Inspired by Equation &lt;span class="math inline"&gt;\(\eqref{eq:lasso}\)&lt;/span&gt;, we produce a toy dataset as follows:&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="im"&gt;from&lt;/span&gt; theano &lt;span class="im"&gt;import&lt;/span&gt; shared &lt;span class="im"&gt;as&lt;/span&gt; tt_shared&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;M &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;50&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;M_nonzero &lt;span class="op"&gt;=&lt;/span&gt; M &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="op"&gt;//&lt;/span&gt; &lt;span class="dv"&gt;10&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" title="6"&gt;beta_true &lt;span class="op"&gt;=&lt;/span&gt; np.zeros(M)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" title="7"&gt;beta_true[:M_nonzero] &lt;span class="op"&gt;=&lt;/span&gt; np.exp(&lt;span class="op"&gt;-&lt;/span&gt;np.arange(M_nonzero)) &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" title="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" title="9"&gt;N &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;int&lt;/span&gt;(np.alen(beta_true) &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="fl"&gt;0.4&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" title="10"&gt;X &lt;span class="op"&gt;=&lt;/span&gt; np.random.randn(N, M)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" title="11"&gt;mu_true &lt;span class="op"&gt;=&lt;/span&gt; X.dot(beta_true)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" title="12"&gt;y &lt;span class="op"&gt;=&lt;/span&gt; mu_true &lt;span class="op"&gt;+&lt;/span&gt; sc.stats.norm.rvs(np.zeros(N), scale&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" title="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" title="14"&gt;X_tt &lt;span class="op"&gt;=&lt;/span&gt; tt_shared(X, name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;X&amp;#39;&lt;/span&gt;, borrow&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" title="15"&gt;y_tt &lt;span class="op"&gt;=&lt;/span&gt; tt_shared(y, name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, borrow&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" title="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-17" title="17"&gt;&lt;span class="co"&gt;# Estimation starting parameters...&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-18" title="18"&gt;beta_0 &lt;span class="op"&gt;=&lt;/span&gt; np.zeros(X.shape[&lt;span class="dv"&gt;1&lt;/span&gt;]).astype(&lt;span class="st"&gt;&amp;#39;float64&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-19" title="19"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-20" title="20"&gt;&lt;span class="co"&gt;# Gradient [starting] step size&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-21" title="21"&gt;alpha_0 &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1.&lt;/span&gt; &lt;span class="op"&gt;/&lt;/span&gt; np.linalg.norm(X, &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;span class="op"&gt;**&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-22" title="22"&gt;&lt;span class="co"&gt;# np.linalg.matrix_rank(X)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-23" title="23"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-24" title="24"&gt;&lt;span class="co"&gt;# Regularization value heuristic&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-25" title="25"&gt;&lt;span class="co"&gt;# beta_ols = np.linalg.lstsq(X, y)[0]&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-26" title="26"&gt;&lt;span class="co"&gt;# lambda_max = 0.1 * np.linalg.norm(beta_ols, np.inf)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-27" title="27"&gt;lambda_max &lt;span class="op"&gt;=&lt;/span&gt; np.linalg.norm(X.T.dot(y), np.inf)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As in &lt;span class="citation" data-cites="willard_role_2017"&gt;Willard (2017)&lt;/span&gt;, we can start with a model defined within a system like PyMC3 &lt;span class="citation" data-cites="salvatier_probabilistic_2016"&gt;(Salvatier, Wiecki, and Fonnesbeck 2016)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="cf"&gt;with&lt;/span&gt; pm.Model() &lt;span class="im"&gt;as&lt;/span&gt; lasso_model:&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;    beta_rv &lt;span class="op"&gt;=&lt;/span&gt; pm.Laplace(&lt;span class="st"&gt;&amp;#39;beta&amp;#39;&lt;/span&gt;, mu&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;, b&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-3" title="3"&gt;                         shape&lt;span class="op"&gt;=&lt;/span&gt;X.shape[&lt;span class="dv"&gt;1&lt;/span&gt;])&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-4" title="4"&gt;    y_rv &lt;span class="op"&gt;=&lt;/span&gt; pm.Normal(&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, mu&lt;span class="op"&gt;=&lt;/span&gt;X_tt.dot(beta_rv), sd&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-5" title="5"&gt;                     shape&lt;span class="op"&gt;=&lt;/span&gt;y.shape[&lt;span class="dv"&gt;0&lt;/span&gt;], observed&lt;span class="op"&gt;=&lt;/span&gt;y_tt)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this setting one might then arrive at the necessary steps toward estimation automatically (i.e. identify the underlying &lt;span class="math inline"&gt;\(\ell_1\)&lt;/span&gt; estimation problem). We discuss this more in &lt;span class="citation" data-cites="willard_role_2017"&gt;Willard (2017)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;For simplicity, we’ll just assume that all components of the estimation problem are know–i.e. loss and penalty functions. The proximal operator that arises in this standard example is the &lt;em&gt;soft thresholding&lt;/em&gt; operator. In Theano, it can be implemented with the following:&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb3-1" title="1"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; tt_soft_threshold(beta_, lambda_):&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" title="2"&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; tt.sgn(beta_) &lt;span class="op"&gt;*&lt;/span&gt; tt.maximum(tt.abs_(beta_) &lt;span class="op"&gt;-&lt;/span&gt; lambda_, &lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="remark" data-markdown="" data-title-name=""&gt;
&lt;p&gt;This operator can take other forms, and the one used here is likely not the best. The &lt;code&gt;maximum&lt;/code&gt; can be replaced by other conditional-like statements–such as &lt;span class="math display"&gt;\[\begin{equation*}
\operatorname{S}(z, \lambda) =
    \begin{cases}
     {\mathop{\mathrm{sgn}}}(\beta) (\beta - \lambda) &amp;amp; \beta &amp;gt; \lambda
     \\
     0 &amp;amp; \text{otherwise}
    \end{cases}
    \;.
\end{equation*}\]&lt;/span&gt; If we were to–say–multiply the output of this operator with another, more difficult to compute result, then we might also wish to extend this multiplication into the definition of the operator and avoid its computation in the &lt;span class="math inline"&gt;\(\beta \leq \lambda\)&lt;/span&gt; case.&lt;/p&gt;
&lt;p&gt;Barring any reuses of this quantity, or a need to preserve undefined results produced by an expensive product with zero, we would ideally like a “compiler” to make such an optimization itself. It isn’t clear how a standard compiler–or interpreter/hybrid–could safely make this optimization, whereas it does seem more reasonable as a symbolic/Theano optimization.&lt;/p&gt;
&lt;p&gt;Optimizations like this are–I think–a necessary step to enable expressive, generalized methods, truly rapid prototyping at the math level.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Now, assuming that we’ve obtained the relevant loss and penalty functions–for example, in PyMC3–then we can proceed to setting up the exact context of our proximal problem.&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb4-1" title="1"&gt;&lt;span class="im"&gt;from&lt;/span&gt; theano &lt;span class="im"&gt;import&lt;/span&gt; clone &lt;span class="im"&gt;as&lt;/span&gt; tt_clone&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" title="3"&gt;&lt;span class="co"&gt;# Clone the negative log-likelihood of our observation model.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" title="4"&gt;nlogl_rv &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="op"&gt;-&lt;/span&gt;lasso_model.observed_RVs[&lt;span class="dv"&gt;0&lt;/span&gt;].logpt&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-5" title="5"&gt;nlogl &lt;span class="op"&gt;=&lt;/span&gt; tt_clone(nlogl_rv)&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-6" title="6"&gt;nlogl.name &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;-logl&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-7" title="7"&gt;beta_tt &lt;span class="op"&gt;=&lt;/span&gt; tt_inputs([nlogl])[&lt;span class="dv"&gt;4&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/section&gt;
&lt;section id="proximal-gradient" class="level1"&gt;
&lt;h1&gt;Proximal Gradient&lt;/h1&gt;
&lt;p&gt;In what follows it will be convenient to generalize a bit and work in terms of arbitrary loss and penalty functions &lt;span class="math inline"&gt;\(l\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(\phi\)&lt;/span&gt;, respectively, which in our case corresponds to &lt;span class="math display"&gt;\[\begin{equation*}
\begin{gathered}
  l(\beta) = \frac12 \|y - X \beta\|^2_2, \quad
  \text{and}\;
  \phi(\beta) = \|\beta\|_1
  \;.\end{gathered}
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The proximal gradient &lt;span class="citation" data-cites="combettes_proximal_2011"&gt;(Combettes and Pesquet 2011)&lt;/span&gt; algorithm is a staple of the proximal framework that provides solutions to problems of the form &lt;span class="math display"&gt;\[\begin{equation*}
\operatorname*{argmin}_\beta \left\{
    l(\beta) + \lambda \phi(\beta)
  \right\}
  \;,
\end{equation*}\]&lt;/span&gt; when both &lt;span class="math inline"&gt;\(l\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(\phi\)&lt;/span&gt; are lower semi-continuous convex functions, and &lt;span class="math inline"&gt;\(l\)&lt;/span&gt; is differentiable with Lipschitz gradient.&lt;/p&gt;
&lt;p&gt;The solution is given as the following fixed-point: &lt;span class="math display"&gt;\[\begin{equation}
\beta = \operatorname*{prox}_{\alpha \lambda \phi}(\beta - \alpha \nabla l(\beta))
  \;.
  \label{eq:forward-backward}
\end{equation}\]&lt;/span&gt; The constant step size &lt;span class="math inline"&gt;\(\alpha\)&lt;/span&gt; is related to the Lipschitz constant of &lt;span class="math inline"&gt;\(\nabla l\)&lt;/span&gt;, but can also be a sequence obeying certain constraints. Since our &lt;span class="math inline"&gt;\(l\)&lt;/span&gt; under consideration is &lt;span class="math inline"&gt;\(\ell_2\)&lt;/span&gt;, we have the incredibly standard &lt;span class="math inline"&gt;\(\nabla l(\beta) = X^\top (X \beta - y)\)&lt;/span&gt;.&lt;/p&gt;
&lt;section id="implementation" class="level2"&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;As in &lt;span class="citation" data-cites="willard_role_2017"&gt;Willard (2017)&lt;/span&gt;, we provide an implementation of a proximal gradient step.&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb5-1" title="1"&gt;&lt;span class="im"&gt;from&lt;/span&gt; theano &lt;span class="im"&gt;import&lt;/span&gt; function &lt;span class="im"&gt;as&lt;/span&gt; tt_function&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" title="2"&gt;&lt;span class="im"&gt;from&lt;/span&gt; theano.&lt;span class="bu"&gt;compile&lt;/span&gt;.nanguardmode &lt;span class="im"&gt;import&lt;/span&gt; NanGuardMode&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" title="4"&gt;tt_func_mode &lt;span class="op"&gt;=&lt;/span&gt; NanGuardMode(nan_is_error&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" title="5"&gt;                            inf_is_error&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" title="6"&gt;                            big_is_error&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-8" title="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-9" title="9"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; prox_gradient_step(loss, beta_tt, prox_func,&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-10" title="10"&gt;                       alpha_tt&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;, lambda_tt&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-11" title="11"&gt;                       return_loss_grad&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;False&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-12" title="12"&gt;                       tt_func_kwargs&lt;span class="op"&gt;=&lt;/span&gt;{&lt;span class="st"&gt;&amp;#39;mode&amp;#39;&lt;/span&gt;: tt_func_mode}&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-13" title="13"&gt;                       ):&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-14" title="14"&gt;    &lt;span class="co"&gt;r&amp;quot;&amp;quot;&amp;quot; Creates a function that produces a proximal gradient step.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-15" title="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-16" title="16"&gt;&lt;span class="co"&gt;    Arguments&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-17" title="17"&gt;&lt;span class="co"&gt;    =========&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-18" title="18"&gt;&lt;span class="co"&gt;    loss: TensorVariable&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-19" title="19"&gt;&lt;span class="co"&gt;        Continuously differentiable &amp;quot;loss&amp;quot; function in the objective&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-20" title="20"&gt;&lt;span class="co"&gt;        function.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-21" title="21"&gt;&lt;span class="co"&gt;    beta_tt: TensorVariable&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-22" title="22"&gt;&lt;span class="co"&gt;        Variable argument of the loss function.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-23" title="23"&gt;&lt;span class="co"&gt;    prox_fn: function&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-24" title="24"&gt;&lt;span class="co"&gt;        Function that computes the proximal operator for the &amp;quot;penalty&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-25" title="25"&gt;&lt;span class="co"&gt;        function.  Must take two parameters: the first a&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-26" title="26"&gt;&lt;span class="co"&gt;TensorVariable&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-27" title="27"&gt;&lt;span class="co"&gt;        of the gradient step, the second a float or Scalar value.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-28" title="28"&gt;&lt;span class="co"&gt;    alpha_tt: float, Scalar (optional)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-29" title="29"&gt;&lt;span class="co"&gt;        Gradient step size.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-30" title="30"&gt;&lt;span class="co"&gt;    lambda_tt: float, Scalar (optional)&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-31" title="31"&gt;&lt;span class="co"&gt;        Additional scalar value passed to `prox_fn`.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-32" title="32"&gt;&lt;span class="co"&gt;        &lt;/span&gt;&lt;span class="al"&gt;TODO&lt;/span&gt;&lt;span class="co"&gt;: Not sure if this should be here; is redundant.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-33" title="33"&gt;&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-34" title="34"&gt;    loss_grad &lt;span class="op"&gt;=&lt;/span&gt; tt.grad(loss, wrt&lt;span class="op"&gt;=&lt;/span&gt;beta_tt)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-35" title="35"&gt;    loss_grad.name &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;loss_grad&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-36" title="36"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-37" title="37"&gt;    &lt;span class="cf"&gt;if&lt;/span&gt; alpha_tt &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-38" title="38"&gt;        alpha_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.scalar(name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;alpha&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-39" title="39"&gt;        alpha_tt.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-40" title="40"&gt;    &lt;span class="cf"&gt;if&lt;/span&gt; lambda_tt &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-41" title="41"&gt;        lambda_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.scalar(name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;lambda&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-42" title="42"&gt;        lambda_tt.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-43" title="43"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-44" title="44"&gt;    beta_grad_step &lt;span class="op"&gt;=&lt;/span&gt; beta_tt &lt;span class="op"&gt;-&lt;/span&gt; alpha_tt &lt;span class="op"&gt;*&lt;/span&gt; loss_grad&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-45" title="45"&gt;    beta_grad_step.name &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;beta_grad_step&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-46" title="46"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-47" title="47"&gt;    prox_grad_step &lt;span class="op"&gt;=&lt;/span&gt; prox_func(beta_grad_step, lambda_tt &lt;span class="op"&gt;*&lt;/span&gt; alpha_tt)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-48" title="48"&gt;    prox_grad_step.name &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;prox_grad_step&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-49" title="49"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-50" title="50"&gt;    inputs &lt;span class="op"&gt;=&lt;/span&gt; []&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-51" title="51"&gt;    updates &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-52" title="52"&gt;    &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="bu"&gt;isinstance&lt;/span&gt;(beta_tt, tt.sharedvar.SharedVariable):&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-53" title="53"&gt;        updates &lt;span class="op"&gt;=&lt;/span&gt; [(beta_tt, prox_grad_step)]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-54" title="54"&gt;    &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-55" title="55"&gt;        inputs &lt;span class="op"&gt;+=&lt;/span&gt; [beta_tt]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-56" title="56"&gt;    &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="bu"&gt;isinstance&lt;/span&gt;(alpha_tt, tt.sharedvar.SharedVariable):&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-57" title="57"&gt;        inputs &lt;span class="op"&gt;+=&lt;/span&gt; [alpha_tt]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-58" title="58"&gt;    &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="kw"&gt;not&lt;/span&gt; &lt;span class="bu"&gt;isinstance&lt;/span&gt;(lambda_tt, tt.sharedvar.SharedVariable):&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-59" title="59"&gt;        inputs &lt;span class="op"&gt;+=&lt;/span&gt; [lambda_tt]&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-60" title="60"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-61" title="61"&gt;    prox_grad_step_fn &lt;span class="op"&gt;=&lt;/span&gt; tt_function(inputs,&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-62" title="62"&gt;                                    prox_grad_step,&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-63" title="63"&gt;                                    updates&lt;span class="op"&gt;=&lt;/span&gt;updates,&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-64" title="64"&gt;                                    &lt;span class="op"&gt;**&lt;/span&gt;tt_func_kwargs)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-65" title="65"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-66" title="66"&gt;    res &lt;span class="op"&gt;=&lt;/span&gt; (prox_grad_step_fn,)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-67" title="67"&gt;    &lt;span class="cf"&gt;if&lt;/span&gt; return_loss_grad:&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-68" title="68"&gt;        res &lt;span class="op"&gt;+=&lt;/span&gt; (loss_grad,)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-69" title="69"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-70" title="70"&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; res&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/section&gt;
&lt;section id="step-sizes" class="level2"&gt;
&lt;h2&gt;Step Sizes&lt;/h2&gt;
&lt;p&gt;A critical aspect of the proximal gradient approach–and most optimization–involves the use of appropriate step sizes, &lt;span class="math inline"&gt;\(\alpha\)&lt;/span&gt;. They needn’t always be fixed values, and, because of this, we can search for a suitable value during estimation. Furthermore, in some cases, step sizes can be sequences amenable to acceleration techniques &lt;span class="citation" data-cites="beck_fast_2014"&gt;(Beck and Teboulle 2014)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;These values have obvious connections to the performance of an optimization method–beyond basic guarantees of convergence, so the power of any implementation will depend on how much support it has for various types of step size sequences.&lt;/p&gt;
&lt;p&gt;Often acceptable ranges of step size values are derived from Lipschitz and related properties of the functions involved–and/or their gradients. Similar considerations underlie the classical line-search methods in optimization, and give meaning to what some call “tuning parameters”. These connections between function-analytic properties and “tuning parameters” themselves highlight the need for more mathematical coverage within implementations–by which we imply their place in a fully computational, symbolic setting.&lt;/p&gt;
&lt;p&gt;In this spirit, one particularly relevant direction of work can be found in Theano’s experimental matrix “Hints”. The ideas behind &lt;code&gt;theano.sandbox.linalg.ops.{psd, spectral_radius_bound}&lt;/code&gt; examples of the machinery needed to automatically determine applicable and efficient &lt;span class="math inline"&gt;\(\alpha\)&lt;/span&gt; constants and sequences.&lt;/p&gt;
&lt;p&gt;In our example, we use the standard backtracking line-search.&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb6-1" title="1"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; backtracking_search(beta_, alpha_,&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" title="2"&gt;                        prox_fn, loss_fn, loss_grad_fn,&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-3" title="3"&gt;                        lambda_&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, bt_rate&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;0.5&lt;/span&gt;, obj_tol&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1e-5&lt;/span&gt;):&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-4" title="4"&gt;    &lt;span class="co"&gt;# alpha_start = alpha_&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-5" title="5"&gt;    z &lt;span class="op"&gt;=&lt;/span&gt; beta_&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-6" title="6"&gt;    beta_start_ &lt;span class="op"&gt;=&lt;/span&gt; beta_&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-7" title="7"&gt;    loss_start_ &lt;span class="op"&gt;=&lt;/span&gt; loss_fn(beta_)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-8" title="8"&gt;    loss_grad_start_ &lt;span class="op"&gt;=&lt;/span&gt; loss_grad_fn(beta_)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-9" title="9"&gt;    &lt;span class="cf"&gt;while&lt;/span&gt; &lt;span class="va"&gt;True&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-10" title="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-11" title="11"&gt;        beta_ &lt;span class="op"&gt;=&lt;/span&gt; beta_start_ &lt;span class="op"&gt;-&lt;/span&gt; alpha_ &lt;span class="op"&gt;*&lt;/span&gt; loss_grad_start_&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-12" title="12"&gt;        z &lt;span class="op"&gt;=&lt;/span&gt; prox_fn(beta_, alpha_ &lt;span class="op"&gt;*&lt;/span&gt; lambda_)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-13" title="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-14" title="14"&gt;        loss_z &lt;span class="op"&gt;=&lt;/span&gt; loss_fn(z)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-15" title="15"&gt;        step_diff &lt;span class="op"&gt;=&lt;/span&gt; z &lt;span class="op"&gt;-&lt;/span&gt; beta_start_&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-16" title="16"&gt;        loss_diff &lt;span class="op"&gt;=&lt;/span&gt; loss_z &lt;span class="op"&gt;-&lt;/span&gt; loss_start_&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-17" title="17"&gt;        line_diff &lt;span class="op"&gt;=&lt;/span&gt; alpha_ &lt;span class="op"&gt;*&lt;/span&gt; (loss_diff &lt;span class="op"&gt;-&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-18" title="18"&gt;loss_grad_start_.T.dot(step_diff))&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-19" title="19"&gt;        line_diff &lt;span class="op"&gt;-=&lt;/span&gt; step_diff.T.dot(step_diff) &lt;span class="op"&gt;/&lt;/span&gt; &lt;span class="fl"&gt;2.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-20" title="20"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-21" title="21"&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; line_diff &lt;span class="op"&gt;&amp;lt;=&lt;/span&gt; obj_tol:&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-22" title="22"&gt;            &lt;span class="cf"&gt;return&lt;/span&gt; z, alpha_, loss_z&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-23" title="23"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-24" title="24"&gt;        alpha_ &lt;span class="op"&gt;*=&lt;/span&gt; bt_rate&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-25" title="25"&gt;        &lt;span class="cf"&gt;assert&lt;/span&gt; alpha_ &lt;span class="op"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;invalid step size: &lt;/span&gt;&lt;span class="sc"&gt;{}&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;&lt;/span&gt;.&lt;span class="bu"&gt;format&lt;/span&gt;(alpha_)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="remark" data-markdown="" data-title-name=""&gt;
&lt;p&gt;Routines like this that make use of the gradient and other quantities might also be good candidates for execution in Theano, if only because of the graph optimizations that are able to remedy obviously redundant computations.&lt;/p&gt;
&lt;p&gt;In this vein, we could consider performing the line-search, and/or the entire optimization loop, within a Theano &lt;code&gt;scan&lt;/code&gt; operation. We could also create &lt;code&gt;Op&lt;/code&gt;s that represents gradient and line-search step. These might make graph construction much simpler, and be more suited for the current optimization framework.&lt;/p&gt;
&lt;p&gt;Although &lt;code&gt;scan&lt;/code&gt; and tighter Theano integration may not on average produce better results than our current use of its compiled functions, we still wish to emphasize the possibilities.&lt;/p&gt;
&lt;p&gt;Likewise, an &lt;code&gt;Op&lt;/code&gt; for the proximal operator might also be necessary for solving proximal operators automatically in closed-form (when possible) within a graph. This is based on the standard use of lookup tables combined with sets of algebraic relationships and identities used in symbolic algebra libraries for automatic differentiation and integration. The same can be done to extend the coverage of known closed-form solutions to proximal operators in an automated setting.&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="examples" class="level1"&gt;
&lt;h1&gt;Examples&lt;/h1&gt;
&lt;p&gt;First, we need to set up the basic functions, which–in this case–are constructed from the Theano graphs.&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb7-1" title="1"&gt;lambda_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.scalar(&lt;span class="st"&gt;&amp;#39;lambda&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" title="2"&gt;lambda_tt.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" title="4"&gt;prox_fn &lt;span class="op"&gt;=&lt;/span&gt; tt_function([beta_tt, lambda_tt],&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" title="5"&gt;                      tt_soft_threshold(beta_tt, lambda_tt))&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-6" title="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-7" title="7"&gt;prox_grad_step_fn, loss_grad &lt;span class="op"&gt;=&lt;/span&gt; prox_gradient_step(&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-8" title="8"&gt;    nlogl, beta_tt, tt_soft_threshold,&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-9" title="9"&gt;    return_loss_grad&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-10" title="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-11" title="11"&gt;loss_fn &lt;span class="op"&gt;=&lt;/span&gt; tt_function([beta_tt], nlogl)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-12" title="12"&gt;loss_grad_fn &lt;span class="op"&gt;=&lt;/span&gt; tt_function([beta_tt], loss_grad)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-13" title="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-14" title="14"&gt;cols_fns &lt;span class="op"&gt;=&lt;/span&gt; [&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-15" title="15"&gt;    (&lt;span class="kw"&gt;lambda&lt;/span&gt; i, b: i, &lt;span class="vs"&gt;r&amp;#39;$i$&amp;#39;&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-16" title="16"&gt;    (&lt;span class="kw"&gt;lambda&lt;/span&gt; i, b: np.asscalar(loss_fn(b)),&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-17" title="17"&gt;        &lt;span class="vs"&gt;r&amp;#39;$l(\beta^{(i)})$&amp;#39;&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-18" title="18"&gt;    (&lt;span class="kw"&gt;lambda&lt;/span&gt; i, b: np.linalg.norm(b &lt;span class="op"&gt;-&lt;/span&gt; beta_true, &lt;span class="dv"&gt;2&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-19" title="19"&gt;        &lt;span class="vs"&gt;r&amp;#39;$\|\beta^{(i)} - \beta^*\|^2_2$&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-20" title="20"&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For a baseline comparison–and sanity check–we’ll use the &lt;code&gt;cvxpy&lt;/code&gt; library &lt;span class="citation" data-cites="diamond_cvxpy:_2016"&gt;(Diamond and Boyd 2016)&lt;/span&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb8-1" title="1"&gt;&lt;span class="im"&gt;import&lt;/span&gt; cvxpy &lt;span class="im"&gt;as&lt;/span&gt; cvx&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-3" title="3"&gt;beta_var_cvx &lt;span class="op"&gt;=&lt;/span&gt; cvx.Variable(M, name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;beta&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-4" title="4"&gt;lambda_cvx &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1e-2&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; lambda_max &lt;span class="op"&gt;*&lt;/span&gt; N&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-6" title="6"&gt;cvx_obj &lt;span class="op"&gt;=&lt;/span&gt; cvx.Minimize(&lt;span class="fl"&gt;0.5&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; cvx.sum_squares(y &lt;span class="op"&gt;-&lt;/span&gt; X &lt;span class="op"&gt;*&lt;/span&gt; beta_var_cvx)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-7" title="7"&gt;                       &lt;span class="op"&gt;+&lt;/span&gt; lambda_cvx &lt;span class="op"&gt;*&lt;/span&gt; cvx.norm(beta_var_cvx, &lt;span class="dv"&gt;1&lt;/span&gt;) )&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-8" title="8"&gt;cvx_prob &lt;span class="op"&gt;=&lt;/span&gt; cvx.Problem(cvx_obj)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-9" title="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-10" title="10"&gt;_ &lt;span class="op"&gt;=&lt;/span&gt; cvx_prob.solve(solver&lt;span class="op"&gt;=&lt;/span&gt;cvx.CVXOPT, verbose&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-11" title="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-12" title="12"&gt;beta_cvx &lt;span class="op"&gt;=&lt;/span&gt; np.asarray(beta_var_cvx.value).squeeze()&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-13" title="13"&gt;loss_cvx &lt;span class="op"&gt;=&lt;/span&gt; loss_fn(beta_cvx)&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-14" title="14"&gt;beta_cvx_err &lt;span class="op"&gt;=&lt;/span&gt; np.linalg.norm(beta_cvx &lt;span class="op"&gt;-&lt;/span&gt; beta_true, &lt;span class="dv"&gt;2&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We now have the necessary pieces to perform an example estimation. We’ll start with an exceedingly large step size and let backtracking line-search find a good value.&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb9-1" title="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; ProxGradient(&lt;span class="bu"&gt;object&lt;/span&gt;):&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" title="3"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; &lt;span class="fu"&gt;__init__&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;, y, X, beta_0,&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" title="4"&gt;                 prox_fn_, loss_fn_, loss_grad_fn_,&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" title="5"&gt;                 alpha_0):&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" title="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" title="7"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.y &lt;span class="op"&gt;=&lt;/span&gt; y&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-8" title="8"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.X &lt;span class="op"&gt;=&lt;/span&gt; X&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-9" title="9"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.alpha_val &lt;span class="op"&gt;=&lt;/span&gt; alpha_0&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-10" title="10"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.beta_0 &lt;span class="op"&gt;=&lt;/span&gt; beta_0&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-11" title="11"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.N, &lt;span class="va"&gt;self&lt;/span&gt;.M &lt;span class="op"&gt;=&lt;/span&gt; X.shape&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-12" title="12"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.prox_fn_ &lt;span class="op"&gt;=&lt;/span&gt; prox_fn_&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-13" title="13"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.loss_fn_ &lt;span class="op"&gt;=&lt;/span&gt; loss_fn_&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-14" title="14"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.loss_grad_fn_ &lt;span class="op"&gt;=&lt;/span&gt; loss_grad_fn_&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-15" title="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-16" title="16"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; step(&lt;span class="va"&gt;self&lt;/span&gt;, beta):&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-17" title="17"&gt;        beta_val &lt;span class="op"&gt;=&lt;/span&gt; np.copy(beta)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-18" title="18"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-19" title="19"&gt;        beta_val, &lt;span class="va"&gt;self&lt;/span&gt;.alpha_val, _ &lt;span class="op"&gt;=&lt;/span&gt; backtracking_search(&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-20" title="20"&gt;            beta_val, &lt;span class="va"&gt;self&lt;/span&gt;.alpha_val,&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-21" title="21"&gt;            &lt;span class="va"&gt;self&lt;/span&gt;.prox_fn_, &lt;span class="va"&gt;self&lt;/span&gt;.loss_fn_, &lt;span class="va"&gt;self&lt;/span&gt;.loss_grad_fn_)&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-22" title="22"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-23" title="23"&gt;        &lt;span class="cf"&gt;return&lt;/span&gt; beta_val&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb10-1" title="1"&gt;beta_0 &lt;span class="op"&gt;=&lt;/span&gt; np.zeros(M).astype(&lt;span class="st"&gt;&amp;#39;float64&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" title="2"&gt;lambda_val &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1e-2&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; lambda_max&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" title="3"&gt;pg_step &lt;span class="op"&gt;=&lt;/span&gt; ProxGradient(y, X, beta_0,&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" title="4"&gt;                       &lt;span class="kw"&gt;lambda&lt;/span&gt; x, a: prox_fn(x, N &lt;span class="op"&gt;*&lt;/span&gt; lambda_val &lt;span class="op"&gt;*&lt;/span&gt; a),&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" title="5"&gt;                       loss_fn, loss_grad_fn, &lt;span class="dv"&gt;10&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" title="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" title="7"&gt;pg_cols_fns &lt;span class="op"&gt;=&lt;/span&gt; cols_fns &lt;span class="op"&gt;+&lt;/span&gt; [(&lt;span class="kw"&gt;lambda&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt;args, &lt;span class="op"&gt;**&lt;/span&gt;kwargs: pg_step.alpha_val,&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" title="8"&gt;&lt;span class="vs"&gt;r&amp;#39;$\alpha$&amp;#39;&lt;/span&gt;)]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" title="9"&gt;pg_est_data, _ &lt;span class="op"&gt;=&lt;/span&gt; iterative_run(pg_step, loss_fn, pg_cols_fns)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" title="10"&gt;pg_ls_data &lt;span class="op"&gt;=&lt;/span&gt; pd.DataFrame(pg_est_data)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-11" title="11"&gt;&lt;span class="co"&gt;# pg_ls_data = pg_ls_data.append(pg_est_data, ignore_index=True)&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span id="fig:pg_ls_plot"&gt;&lt;span id="fig:pg_ls_plot_span" style="display:none;visibility:hidden"&gt;&lt;span class="math display"&gt;\[\begin{equation}\tag{1}\label{fig:pg_ls_plot}\end{equation}\]&lt;/span&gt;&lt;/span&gt;&lt;img src="https://brandonwillard.github.io/figures/more_proximal_estimation_pg_ls_plot_1.png" title="fig:" alt="Minimization by proximal gradient with backtracking line-search." /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Figure &lt;span class="math inline"&gt;\(\ref{fig:pg_ls_plot}\)&lt;/span&gt; shows a couple convergence measures for proximal gradient steps alongside the step size changes due to backtracking line-search. Regarding the latter, in our example a sufficient step size is found within the first few iterations, so the overall result isn’t too interesting. Fortunately, this sort of behaviour isn’t uncommon, which makes line-search quite effective in practice.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="coordinate-wise-estimation" class="level1"&gt;
&lt;h1&gt;Coordinate-wise Estimation&lt;/h1&gt;
&lt;p&gt;Given that our loss is a composition of &lt;span class="math inline"&gt;\(\ell_2\)&lt;/span&gt; and a linear operator of finite dimension (i.e. &lt;span class="math inline"&gt;\(X\)&lt;/span&gt;), we can conveniently exploit conditional separability and obtain simple estimation steps in each coordinate. This is, effectively, what characterizes coordinate–or cyclic–descent. Since it is a common technique in the estimation of &lt;span class="math inline"&gt;\(\ell_1\)&lt;/span&gt; models &lt;span class="citation" data-cites="friedman_pathwise_2007 mazumder_regularization_2009 scikit-learn_sklearn.linear_model.elasticnet_2017"&gt;(Friedman et al. 2007; Mazumder, Hastie, and Tibshirani 2009; scikit-learn 2017)&lt;/span&gt;, it’s worthwhile to consider how it can viewed in terms of proximal operators.&lt;/p&gt;
&lt;p&gt;From a statistical perspective, the basics of coordinate-wise methods begin with the “partial residuals”, &lt;span class="math inline"&gt;\(r_{-m} \in {{\mathbb{R}}}^{N}\)&lt;/span&gt; discussed in &lt;span class="citation" data-cites="friedman_pathwise_2007"&gt;Friedman et al. (2007)&lt;/span&gt;, and implicitly defined by &lt;span class="math display"&gt;\[\begin{equation}
\begin{aligned}
    \beta^*
    &amp;amp;= \operatorname*{argmin}_{\beta} \left\{
      \frac12
      \|
    y - X(\beta - e_m \beta_m)
        - X e_m \cdot \beta_{m}\|^2_2
      + \lambda \left|\beta_m\right|
      + \lambda \sum_{m^\prime \neq m} \left|\beta_{m^\prime}\right|
      \right\}
    \\
    &amp;amp;= \operatorname*{argmin}_{\beta} \left\{
      \frac12
      \|r_{-m} - X e_m \cdot \beta_{m}\|^2_2
      + \lambda \left|\beta_m\right|
      + \dots
    \right\}
  \;.
  \end{aligned}
  \label{eq:partial_resid}
\end{equation}\]&lt;/span&gt; The last expression hints at the most basic idea behind the coordinate-wise approach: conditional minimization in each &lt;span class="math inline"&gt;\(m\)&lt;/span&gt;. Its exact solution in each coordinate is given by the aforementioned soft thresholding function, which–as we’ve already stated–is a proximal operator. In symbols, &lt;span class="math inline"&gt;\(\operatorname*{prox}_{\lambda \left|\cdot\right|}(x) = \operatorname{S}_\lambda(x)\)&lt;/span&gt;, where the latter is the soft thresholding operator.&lt;/p&gt;
&lt;p&gt;Now, if we wanted to relate Equation &lt;span class="math inline"&gt;\(\eqref{eq:partial_resid}\)&lt;/span&gt; a proximal method via the statement of a proximal gradient fixed-point solution–i.e. Equation &lt;span class="math inline"&gt;\(\eqref{eq:forward-backward}\)&lt;/span&gt;–we might use the following property of proximal operators:&lt;/p&gt;
&lt;div id="lem:prox_ortho_basis" class="lemma" data-markdown="" data-title-name=""&gt;
&lt;p&gt;&lt;span id="lem:prox_ortho_basis_span" style="display:none;visibility:hidden"&gt;&lt;span class="math display"&gt;\[\begin{equation}\tag{1}\label{lem:prox_ortho_basis}\end{equation}\]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{equation*}
\operatorname*{prox}_{\lambda \phi \circ e^\top_m}(z) =
    \sum^M_m \operatorname*{prox}_{\lambda \phi}\left(e^\top_m z\right) e_m
    \;.
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;div class="proof" data-markdown="" data-title-name=""&gt;
&lt;p&gt;See &lt;span class="citation" data-cites="chaux_variational_2007"&gt;Chaux et al. (2007)&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The next result yields our desired connection.&lt;/p&gt;
&lt;div id="eq:prox_grad_descent" class="proposition" data-markdown="" data-title-name=""&gt;
&lt;p&gt;&lt;span id="eq:prox_grad_descent_span" style="display:none;visibility:hidden"&gt;&lt;span class="math display"&gt;\[\begin{equation}\tag{1}\label{eq:prox_grad_descent}\end{equation}\]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;For &lt;span class="math inline"&gt;\(X\)&lt;/span&gt; such that &lt;span class="math inline"&gt;\({{\bf 1}}^\top X e_m = 0\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(e^\top_m X^\top X e_m = 1\)&lt;/span&gt;, &lt;span class="math inline"&gt;\(m \in \{1, \dots, M\}\)&lt;/span&gt;, the coordinate-wise step of the Lasso in &lt;span class="citation" data-cites="friedman_pathwise_2007"&gt;Friedman et al. (2007 Equation (9))&lt;/span&gt;, &lt;span class="math display"&gt;\[\begin{equation*}
\beta_m = \operatorname{S}_{\lambda}\left[
      \sum_{n}^N X_{n,m} \left(
      y_n - \sum^M_{m^\prime \neq m} X_{n,m^\prime} \beta_{m^\prime}
      \right)
    \right]
    \;,
\end{equation*}\]&lt;/span&gt; has a proximal gradient fixed-point solution under a Euclidean basis decomposition with the form &lt;span class="math display"&gt;\[\begin{equation*}
\beta =
    \sum^M_m \operatorname*{prox}_{\alpha \lambda \phi}\left[
      e^\top_m \left(\beta - \alpha \nabla l(\beta)\right)
    \right] e_m
    \;.
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;div class="proof" data-markdown="" data-title-name=""&gt;
&lt;p&gt;We start with an expansion of the terms in &lt;span class="math inline"&gt;\(\operatorname*{prox}_{\lambda \phi} \equiv \operatorname{S}_\lambda\)&lt;/span&gt;. After simplifying the notation with &lt;span class="math display"&gt;\[\begin{equation*}
\begin{gathered}
    \sum^N_{n} X_{n,m} z_n = e^\top_m X^\top z, \quad \text{and} \quad
    \sum^M_{m^\prime \neq m} X_{n,m^\prime} \beta_{m^\prime} =
    X \left(\beta - \beta_m e_m \right)
    \;,
  \end{gathered}
\end{equation*}\]&lt;/span&gt; the expanded argument of &lt;span class="math inline"&gt;\(\operatorname{S}\)&lt;/span&gt; reduces to &lt;span class="math display"&gt;\[\begin{equation*}
\begin{aligned}
      e^\top_m X^\top \left(y - X\left( \beta - e_m \beta_m\right)\right)
      &amp;amp;= e^\top_m X^\top X e_m \beta_m + e^\top_m X^\top \left(y - X \beta\right)
      \\
      &amp;amp;= \beta_m + e^\top_m X^\top \left(y - X \beta\right)
      \\
      &amp;amp;= e^\top_m \left(\beta + X^\top \left(y - X \beta\right)\right)
    \end{aligned}
\end{equation*}\]&lt;/span&gt; where the last step follows from &lt;span class="math inline"&gt;\(X\)&lt;/span&gt; standardization. This establishes the relationship with Equation &lt;span class="math inline"&gt;\(\eqref{eq:forward-backward}\)&lt;/span&gt; only component-wise. Using Lemma &lt;span class="math inline"&gt;\(\eqref{lem:prox_ortho_basis}\)&lt;/span&gt; together with &lt;span class="math inline"&gt;\(z = \beta - \alpha \nabla  l(\beta)\)&lt;/span&gt; yields the proximal gradient fixed-point statement, i.e. &lt;span class="math display"&gt;\[\begin{equation*}
\begin{aligned}
      \beta
      &amp;amp;=
      \sum^M_m \operatorname*{prox}_{\alpha \lambda \phi}\left[
    e^\top_m \left(\beta - \alpha \nabla l(\beta)\right)
      \right] e_m
      \\
      &amp;amp;=
      \sum^M_m \operatorname*{prox}_{\alpha \lambda \phi}\left(
      \beta_m + \alpha e_m^\top X^\top \left(y - X \beta \right)
      \right) e_m
      \;.
    \end{aligned}
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="rem:bases" class="remark" data-markdown="" data-title-name=""&gt;
&lt;p&gt;&lt;span id="rem:bases_span" style="display:none;visibility:hidden"&gt;&lt;span class="math display"&gt;\[\begin{equation}\tag{3}\label{rem:bases}\end{equation}\]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The property in Lemma &lt;span class="math inline"&gt;\(\eqref{lem:prox_ortho_basis}\)&lt;/span&gt; can used with other orthonormal bases–providing yet another connection between proximal methods and established dimensionality reduction and sparse estimation techniques &lt;span class="citation" data-cites="chaux_variational_2007"&gt;(Chaux et al. 2007)&lt;/span&gt;. Also, this property provides a neat way to think about &lt;span class="math inline"&gt;\(X\)&lt;/span&gt;-based orthogonalizations in estimations for regression and grouped-penalization problems.&lt;/p&gt;
&lt;/div&gt;
&lt;section id="implementation-1" class="level2"&gt;
&lt;h2&gt;Implementation&lt;/h2&gt;
&lt;p&gt;The following performs a standard form of coordinate descent:&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb11-1" title="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; CoordDescent(&lt;span class="bu"&gt;object&lt;/span&gt;):&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-3" title="3"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; &lt;span class="fu"&gt;__init__&lt;/span&gt;(&lt;span class="va"&gt;self&lt;/span&gt;, y, X, beta_0, prox_fn_, col_seq&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;):&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-5" title="5"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.y &lt;span class="op"&gt;=&lt;/span&gt; y&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-6" title="6"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.X &lt;span class="op"&gt;=&lt;/span&gt; X&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-7" title="7"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.beta_0 &lt;span class="op"&gt;=&lt;/span&gt; beta_0&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-8" title="8"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.N, &lt;span class="va"&gt;self&lt;/span&gt;.M &lt;span class="op"&gt;=&lt;/span&gt; X.shape&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-9" title="9"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.Xb &lt;span class="op"&gt;=&lt;/span&gt; np.dot(&lt;span class="va"&gt;self&lt;/span&gt;.X, &lt;span class="va"&gt;self&lt;/span&gt;.beta_0)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-10" title="10"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.prox_fn_ &lt;span class="op"&gt;=&lt;/span&gt; prox_fn_&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-11" title="11"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-12" title="12"&gt;        &lt;span class="co"&gt;# (Inverse) 2-norm of each column/feature, i.e.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-13" title="13"&gt;        &lt;span class="co"&gt;#   np.reciprocal(np.diag(np.dot(X.T, X)))&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-14" title="14"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.alpha_vals &lt;span class="op"&gt;=&lt;/span&gt; np.reciprocal((&lt;span class="va"&gt;self&lt;/span&gt;.X&lt;span class="op"&gt;**&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt;).&lt;span class="bu"&gt;sum&lt;/span&gt;(axis&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-15" title="15"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-16" title="16"&gt;        &lt;span class="cf"&gt;if&lt;/span&gt; col_seq &lt;span class="kw"&gt;is&lt;/span&gt; &lt;span class="va"&gt;None&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-17" title="17"&gt;            &lt;span class="va"&gt;self&lt;/span&gt;.col_seq &lt;span class="op"&gt;=&lt;/span&gt; np.arange(&lt;span class="va"&gt;self&lt;/span&gt;.M)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-18" title="18"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-19" title="19"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; reset(&lt;span class="va"&gt;self&lt;/span&gt;):&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-20" title="20"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.Xb &lt;span class="op"&gt;=&lt;/span&gt; np.dot(&lt;span class="va"&gt;self&lt;/span&gt;.X, &lt;span class="va"&gt;self&lt;/span&gt;.beta_0)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-21" title="21"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-22" title="22"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; step(&lt;span class="va"&gt;self&lt;/span&gt;, beta):&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-23" title="23"&gt;        beta_val &lt;span class="op"&gt;=&lt;/span&gt; np.copy(beta)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-24" title="24"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-25" title="25"&gt;        &lt;span class="cf"&gt;for&lt;/span&gt; j &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.col_seq:&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-26" title="26"&gt;            X_j &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.X[:, j]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-27" title="27"&gt;            alpha_val &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.alpha_vals[j]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-28" title="28"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-29" title="29"&gt;            &lt;span class="co"&gt;# A little cheaper to just subtract the column&amp;#39;s&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-30" title="30"&gt;contribution...&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-31" title="31"&gt;            &lt;span class="va"&gt;self&lt;/span&gt;.Xb &lt;span class="op"&gt;-=&lt;/span&gt; X_j &lt;span class="op"&gt;*&lt;/span&gt; beta_val[j]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-32" title="32"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-33" title="33"&gt;            Xt_r &lt;span class="op"&gt;=&lt;/span&gt; np.dot(X_j.T, &lt;span class="va"&gt;self&lt;/span&gt;.y &lt;span class="op"&gt;-&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.Xb) &lt;span class="op"&gt;*&lt;/span&gt; alpha_val&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-34" title="34"&gt;            beta_val[j] &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="va"&gt;self&lt;/span&gt;.prox_fn_(np.atleast_1d(Xt_r),&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-35" title="35"&gt;alpha_val)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-36" title="36"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-37" title="37"&gt;            &lt;span class="co"&gt;# ...and add the updated column back.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-38" title="38"&gt;            &lt;span class="va"&gt;self&lt;/span&gt;.Xb &lt;span class="op"&gt;+=&lt;/span&gt; X_j &lt;span class="op"&gt;*&lt;/span&gt; beta_val[j]&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-39" title="39"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-40" title="40"&gt;        &lt;span class="va"&gt;self&lt;/span&gt;.beta_last &lt;span class="op"&gt;=&lt;/span&gt; beta_val&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-41" title="41"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-42" title="42"&gt;        &lt;span class="cf"&gt;return&lt;/span&gt; beta_val&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Our example randomizes the order of coordinates to loosely demonstrate the range of efficiency possible in coordinate descent.&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb12-1" title="1"&gt;beta_0 &lt;span class="op"&gt;=&lt;/span&gt; np.zeros(M).astype(&lt;span class="st"&gt;&amp;#39;float64&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" title="2"&gt;lambda_val &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="fl"&gt;1e-2&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt; lambda_max&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" title="3"&gt;cd_step &lt;span class="op"&gt;=&lt;/span&gt; CoordDescent(y, X, beta_0,&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" title="4"&gt;                       &lt;span class="kw"&gt;lambda&lt;/span&gt; x, a: prox_fn(x, N &lt;span class="op"&gt;*&lt;/span&gt; lambda_val &lt;span class="op"&gt;*&lt;/span&gt; a))&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-6" title="6"&gt;cd_cols_fns &lt;span class="op"&gt;=&lt;/span&gt; cols_fns &lt;span class="op"&gt;+&lt;/span&gt; [(&lt;span class="kw"&gt;lambda&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt;args, &lt;span class="op"&gt;**&lt;/span&gt;kwargs: j, &lt;span class="st"&gt;&amp;quot;replication&amp;quot;&lt;/span&gt;)]&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-8" title="8"&gt;pg_coord_data &lt;span class="op"&gt;=&lt;/span&gt; pd.DataFrame()&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-9" title="9"&gt;&lt;span class="cf"&gt;for&lt;/span&gt; j &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;range&lt;/span&gt;(&lt;span class="dv"&gt;15&lt;/span&gt;):&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-10" title="10"&gt;    est_data, _ &lt;span class="op"&gt;=&lt;/span&gt; iterative_run(cd_step, loss_fn, cd_cols_fns)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-11" title="11"&gt;    pg_coord_data &lt;span class="op"&gt;=&lt;/span&gt; pg_coord_data.append(est_data,&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-12" title="12"&gt;                                         ignore_index&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-13" title="13"&gt;    &lt;span class="co"&gt;# Reset internal state of our step method, since we&amp;#39;re&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-14" title="14"&gt;    &lt;span class="co"&gt;# running multiple replications.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-15" title="15"&gt;    cd_step.reset()&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-16" title="16"&gt;    np.random.shuffle(cd_step.col_seq)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span id="fig:pg_coord_plot"&gt;&lt;span id="fig:pg_coord_plot_span" style="display:none;visibility:hidden"&gt;&lt;span class="math display"&gt;\[\begin{equation}\tag{2}\label{fig:pg_coord_plot}\end{equation}\]&lt;/span&gt;&lt;/span&gt;&lt;img src="https://brandonwillard.github.io/figures/more_proximal_estimation_pg_coord_plot_1.png" title="fig:" alt="Minimization by coordinate descent." /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Figure &lt;span class="math inline"&gt;\(\ref{fig:pg_coord_plot}\)&lt;/span&gt; shows convergence measures for each randomized coordinate order. The [average] difference in the number of iterations required for coordinate descent and proximal gradient is fairly noticeable. Nonetheless, both reach effectively the same limits.&lt;/p&gt;
&lt;div class="remark" data-markdown="" data-title-name=""&gt;
&lt;p&gt;Similar ideas behind batched vs. non-batched steps and block sampling–found within the Gibbs sampling literature &lt;span class="citation" data-cites="roberts_updating_1997"&gt;(Roberts and Sahu 1997)&lt;/span&gt;–could explain the variation due to coordinate order and the relative efficiency of coordinate descent. There are also connections with our comments in Remark &lt;span class="math inline"&gt;\(\ref{rem:bases}\)&lt;/span&gt; and, to some extent, stochastic gradient descent (SGD) &lt;span class="citation" data-cites="bertsekas_incremental_2010"&gt;(Bertsekas 2010)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;In a woefully lacking over-generalization, let’s say that it comes down to the [spectral] properties of the composite operator(s) &lt;span class="math inline"&gt;\(l \circ X\)&lt;/span&gt; and/or &lt;span class="math inline"&gt;\(\nabla l \circ X\)&lt;/span&gt;. These determine the bounds of efficiency for steps in certain directions and how blocking or partitioning the dimensions of &lt;span class="math inline"&gt;\(\beta\)&lt;/span&gt; nears or distances from those bounds.&lt;/p&gt;
&lt;/div&gt;
&lt;section id="regularization-paths" class="level3"&gt;
&lt;h3&gt;Regularization Paths&lt;/h3&gt;
&lt;p&gt;Also, due to the relatively fast convergence of coordinate descent, the method is a little more suitable for the computation of regularization paths– i.e. varying &lt;span class="math inline"&gt;\(\lambda\)&lt;/span&gt; between iterations. There is much more to this topic, but for simplicity let’s just note that each &lt;span class="math inline"&gt;\(\lambda\)&lt;/span&gt; step has a “warm-start” from the previous descent iteration–which helps–and that we’re otherwise fine with the solution provided by this approach.&lt;/p&gt;
&lt;p&gt;Next, we make a small extension to demonstrate the computation of regularization paths–using &lt;code&gt;lasso_path&lt;/code&gt; for comparison.&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb13-1" title="1"&gt;&lt;span class="im"&gt;from&lt;/span&gt; sklearn.linear_model &lt;span class="im"&gt;import&lt;/span&gt; lasso_path, enet_path&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" title="3"&gt;beta_0 &lt;span class="op"&gt;=&lt;/span&gt; np.zeros(M).astype(&lt;span class="st"&gt;&amp;#39;float64&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" title="5"&gt;lambda_path, beta_path, _ &lt;span class="op"&gt;=&lt;/span&gt; lasso_path(X, y)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" title="6"&gt;path_len &lt;span class="op"&gt;=&lt;/span&gt; np.alen(lambda_path)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-8" title="8"&gt;beta_last &lt;span class="op"&gt;=&lt;/span&gt; beta_0&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-9" title="9"&gt;pg_path_data &lt;span class="op"&gt;=&lt;/span&gt; pd.DataFrame()&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-10" title="10"&gt;&lt;span class="cf"&gt;for&lt;/span&gt; i, lambda_ &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(lambda_path):&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-11" title="11"&gt;    cd_path_step &lt;span class="op"&gt;=&lt;/span&gt; CoordDescent(y, X, beta_last,&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-12" title="12"&gt;                        &lt;span class="kw"&gt;lambda&lt;/span&gt; x, a: prox_fn(x, N &lt;span class="op"&gt;*&lt;/span&gt; lambda_ &lt;span class="op"&gt;*&lt;/span&gt; a))&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-13" title="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-14" title="14"&gt;    cd_cols_fns &lt;span class="op"&gt;=&lt;/span&gt; cols_fns[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; [&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-15" title="15"&gt;        (&lt;span class="kw"&gt;lambda&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt;args, &lt;span class="op"&gt;**&lt;/span&gt;kwargs: lambda_, &lt;span class="vs"&gt;r&amp;#39;$\lambda$&amp;#39;&lt;/span&gt;)]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-16" title="16"&gt;    est_data, beta_last &lt;span class="op"&gt;=&lt;/span&gt; iterative_run(cd_path_step, loss_fn,&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-17" title="17"&gt;                                        cd_cols_fns,&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-18" title="18"&gt;                                        stop_tol&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="fl"&gt;1e-4&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-19" title="19"&gt;                                        stop_loss&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-20" title="20"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-21" title="21"&gt;    pg_path_data &lt;span class="op"&gt;=&lt;/span&gt; pg_path_data.append(est_data.iloc[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, :],&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-22" title="22"&gt;                                       ignore_index&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb14-1" title="1"&gt;cd_cols_fns &lt;span class="op"&gt;=&lt;/span&gt; cols_fns[&lt;span class="dv"&gt;1&lt;/span&gt;:] &lt;span class="op"&gt;+&lt;/span&gt; [&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" title="2"&gt;    (&lt;span class="kw"&gt;lambda&lt;/span&gt; &lt;span class="op"&gt;*&lt;/span&gt;args, &lt;span class="op"&gt;**&lt;/span&gt;kwargs: lambda_path[args[&lt;span class="dv"&gt;0&lt;/span&gt;]], &lt;span class="vs"&gt;r&amp;#39;$\lambda$&amp;#39;&lt;/span&gt;)]&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" title="4"&gt;iter_values &lt;span class="op"&gt;=&lt;/span&gt; []&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-5" title="5"&gt;&lt;span class="cf"&gt;for&lt;/span&gt; i, beta_ &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(beta_path.T):&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-6" title="6"&gt;    iter_values.append([col_fn(i, beta_)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-7" title="7"&gt;                        &lt;span class="cf"&gt;for&lt;/span&gt; col_fn, _ &lt;span class="kw"&gt;in&lt;/span&gt; cd_cols_fns])&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-8" title="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-9" title="9"&gt;sklearn_path_data &lt;span class="op"&gt;=&lt;/span&gt; pd.DataFrame(iter_values,&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-10" title="10"&gt;                                 columns&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="bu"&gt;zip&lt;/span&gt;(&lt;span class="op"&gt;*&lt;/span&gt;cd_cols_fns)[&lt;span class="dv"&gt;1&lt;/span&gt;])&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-11" title="11"&gt;sklearn_path_data &lt;span class="op"&gt;=&lt;/span&gt; sklearn_path_data.assign(&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-12" title="12"&gt;    replication&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;None&lt;/span&gt;, &lt;span class="bu"&gt;type&lt;/span&gt;&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;sklearn&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-13" title="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-14" title="14"&gt;pg_path_data &lt;span class="op"&gt;=&lt;/span&gt; pg_path_data.assign(&lt;span class="bu"&gt;type&lt;/span&gt;&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;pg&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-15" title="15"&gt;pg_path_data &lt;span class="op"&gt;=&lt;/span&gt; pg_path_data.append(sklearn_path_data,&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-16" title="16"&gt;                                   ignore_index&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span id="fig:pg_path_plot"&gt;&lt;span id="fig:pg_path_plot_span" style="display:none;visibility:hidden"&gt;&lt;span class="math display"&gt;\[\begin{equation}\tag{3}\label{fig:pg_path_plot}\end{equation}\]&lt;/span&gt;&lt;/span&gt;&lt;img src="https://brandonwillard.github.io/figures/more_proximal_estimation_pg_path_plot_1.png" title="fig:" alt="Regularization paths via coordinate descent." /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="discussion" class="level1"&gt;
&lt;h1&gt;Discussion&lt;/h1&gt;
&lt;p&gt;Among the changes discussed earlier regarding Theano &lt;code&gt;Op&lt;/code&gt;s for the proximal objects used here, we would also like to motivate much larger changes to the applied mathematician/statistician’s standard tools by demonstrating the relevance of less common–yet increasingly useful–abstractions. For instance, the proximal methods are neatly framed within operator theory and set-valued analysis, where concepts like the resolvent, sub-differential/gradient and others are common. Abstractions like these provide a compact means of extending familiar ideas into new contexts–such as non-differentiable functions.&lt;/p&gt;
&lt;p&gt;Unfortunately, numerical libraries do not provide much in the way of utilizing these abstractions. Most are strictly founded in the representation of point-valued mappings, which can require significant work-arounds to handle even the most basic non-differentiable functions (e.g. the absolute value within our example problem). Our use of the proximal framework is, in part, motivated by its near seamless use &lt;em&gt;and&lt;/em&gt; simultaneous bypassing of set-valued maps–in implementation, at least.&lt;/p&gt;
&lt;p&gt;There is no fundamental restriction blocking support for set-valued maps, however–aside from the necessary labor and community interest. Even minimal support could provide a context that makes frameworks like ours merely minor abstractions. A similar idea can be found in the symbolic calculation of limits via filters &lt;span class="citation" data-cites="beeson_meaning_2005"&gt;(Beeson and Wiedijk 2005)&lt;/span&gt;. Perhaps we can liken these changes to the modern evolution of linear algebra libraries to tensor libraries.&lt;/p&gt;
&lt;p&gt;We would also like to stress that the value provided by the symbolic tools discussed here (Theano, really) are not &lt;em&gt;just&lt;/em&gt; in their ability to act as compilers at a “math level”, but more for their ability to concretely encode mathematical characterizations of optimization problems and methods. Work in this direction is not new by any means; however, the combination of open-source tools and industry interest in algorithms that fall under the broad class of proximal methods (e.g. gradient descent, ADMM, EM, etc.) provides a more immediate reason to pursue these abstractions in code and automate their use.&lt;/p&gt;
&lt;p&gt;Regarding the proximal methods, we can consider Theano optimizations that make direct use of the orthonormal basis property in Lemma &lt;span class="math inline"&gt;\(\eqref{lem:prox_ortho_basis}\)&lt;/span&gt;, or the Moreau-Fenchel theorem, and automate consideration for various estimation methods via splitting (e.g. ADMM, Douglas-Rachford, etc.)–perhaps by making decisions based on inferred or specified tensor, function, and operator properties. In future installments we’ll delve into the details of these ideas.&lt;/p&gt;
&lt;p&gt;&lt;span class="citation" data-cites="wytock_new_2016"&gt;(Wytock et al. 2016)&lt;/span&gt; also discuss similar ideas in an optimization setting, such as the use of symbolic graphs and a close coupling with useful mathematical abstractions–including proximal operators. Additionally, there are many other good examples &lt;span class="citation" data-cites="diamond_cvxpy:_2016"&gt;(Diamond and Boyd 2016)&lt;/span&gt; of constructive mathematical abstractions applied in code.&lt;/p&gt;
&lt;p&gt;In most cases, libraries providing optimization tools and supporting model estimation do not attempt to root their implementations within an independently developed symbolic framework and then realize their relevant methodologies in that context. Too often the mathematical abstractions–or the resulting methods alone–are directly implemented at the highest levels of abstraction possible. This is what we see as the result of popular libraries like &lt;code&gt;scikit-learn&lt;/code&gt; and the body of &lt;code&gt;R&lt;/code&gt; packages. One can also find the same efforts for proximal methods themselves–e.g. in &lt;span class="citation" data-cites="svaiter_pyprox_2017"&gt;(svaiter 2017)&lt;/span&gt;, where individual functions for ADMM, forward-backward/proximal gradient and Douglas-Rachford are the end result. This is the most common approach and it makes sense in terms of simplicity, but offers very little of the extensibility, generalization, or efficiencies provided by shared efforts across related projects and fields.&lt;/p&gt;
&lt;p&gt;In the context of Theano, implementations immediately benefit from its code conversion, parallelization and relevant improvements to its basic graph optimizations. The latter covers both low-level computational efficiency–such as relevant application of BLAS functions–and high-level tensor algebra simplifications.&lt;/p&gt;
&lt;p&gt;In a development community that builds on these tools, related efficiency and performance gains can occur much more often, without necessarily sacrificing the specificity inherent to certain areas of application. For example, we can safely use the Rao-Blackwell theorem as the basis of a graph optimization in PyMC3, so it could be included among that project’s default offerings; however, it would be far too cumbersome to use productively in a less specific context.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="bibliography" class="level1 unnumbered"&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;div id="refs" class="references"&gt;
&lt;div id="ref-beck_fast_2014"&gt;
&lt;p&gt;Beck, Amir, and Marc Teboulle. 2014. “A Fast Dual Proximal Gradient Algorithm for Convex Minimization and Applications.” &lt;em&gt;Operations Research Letters&lt;/em&gt; 42 (1): 1–6. &lt;a href="http://www.sciencedirect.com/science/article/pii/S0167637713001454"&gt;http://www.sciencedirect.com/science/article/pii/S0167637713001454&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-beeson_meaning_2005"&gt;
&lt;p&gt;Beeson, Michael, and Freek Wiedijk. 2005. “The Meaning of Infinity in Calculus and Computer Algebra Systems.” &lt;em&gt;Journal of Symbolic Computation&lt;/em&gt;, Automated reasoning and computer algebra systems (ar-ca)AR-ca, 39 (5): 523–38. &lt;a href="https://www.sciencedirect.com/science/article/pii/S074771710500026X"&gt;https://www.sciencedirect.com/science/article/pii/S074771710500026X&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-bergstra_theano_2010"&gt;
&lt;p&gt;Bergstra, James, Olivier Breuleux, Frédéric Bastien, Pascal Lamblin, Razvan Pascanu, Guillaume Desjardins, Joseph Turian, David Warde-Farley, and Yoshua Bengio. 2010. “Theano: A CPU and GPU Math Expression Compiler.” In &lt;em&gt;Proceedings of the Python for Scientific Computing Conference (SciPy)&lt;/em&gt;. Austin, TX.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-bertsekas_incremental_2010"&gt;
&lt;p&gt;Bertsekas, Dimitri P. 2010. “Incremental Gradient, Subgradient, and Proximal Methods for Convex Optimization: A Survey.” &lt;a href="http://web.mit.edu/dimitrib/www/Incremental_Survey_LIDS.pdf"&gt;http://web.mit.edu/dimitrib/www/Incremental_Survey_LIDS.pdf&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-chaux_variational_2007"&gt;
&lt;p&gt;Chaux, Caroline, Patrick L Combettes, Jean-Christophe Pesquet, and Valérie R Wajs. 2007. “A Variational Formulation for Frame-Based Inverse Problems.” &lt;em&gt;Inverse Problems&lt;/em&gt; 23 (4): 1495.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-combettes_proximal_2011"&gt;
&lt;p&gt;Combettes, Patrick L, and Jean-Christophe Pesquet. 2011. “Proximal Splitting Methods in Signal Processing.” &lt;em&gt;Fixed-Point Algorithms for Inverse Problems in Science and Engineering&lt;/em&gt;, 185–212.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-diamond_cvxpy:_2016"&gt;
&lt;p&gt;Diamond, Steven, and Stephen Boyd. 2016. “CVXPY: A Python-Embedded Modeling Language for Convex Optimization.” &lt;em&gt;Journal of Machine Learning Research&lt;/em&gt; 17 (83): 1–5.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-friedman_pathwise_2007"&gt;
&lt;p&gt;Friedman, Jerome, Trevor Hastie, Holger Höfling, Robert Tibshirani, and others. 2007. “Pathwise Coordinate Optimization.” &lt;em&gt;The Annals of Applied Statistics&lt;/em&gt; 1 (2): 302–32. &lt;a href="http://projecteuclid.org/euclid.aoas/1196438020"&gt;http://projecteuclid.org/euclid.aoas/1196438020&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-mazumder_regularization_2009"&gt;
&lt;p&gt;Mazumder, Rahul, Trevor Hastie, and Rob Tibshirani. 2009. “Regularization Methods for Learning Incomplete Matrices.” &lt;em&gt;arXiv Preprint arXiv:0906.2034&lt;/em&gt;. &lt;a href="https://arxiv.org/abs/0906.2034"&gt;https://arxiv.org/abs/0906.2034&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-parikh_proximal_2014"&gt;
&lt;p&gt;Parikh, Neal, and Stephen Boyd. 2014. “Proximal Algorithms.” &lt;em&gt;Foundations and Trends in Optimization&lt;/em&gt; 1 (3): 123–231. &lt;a href="https://doi.org/10.1561/2400000003"&gt;https://doi.org/10.1561/2400000003&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-polson_proximal_2015"&gt;
&lt;p&gt;Polson, Nicholas G., James G. Scott, and Brandon T. Willard. 2015. “Proximal Algorithms in Statistics and Machine Learning.” &lt;em&gt;Statistical Science&lt;/em&gt; 30 (4): 559–81. &lt;a href="http://projecteuclid.org/euclid.ss/1449670858"&gt;http://projecteuclid.org/euclid.ss/1449670858&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-roberts_updating_1997"&gt;
&lt;p&gt;Roberts, Gareth O., and Sujit K. Sahu. 1997. “Updating Schemes, Correlation Structure, Blocking and Parameterization for the Gibbs Sampler.” &lt;em&gt;Journal of the Royal Statistical Society: Series B (Statistical Methodology)&lt;/em&gt; 59 (2): 291–317. &lt;a href="http://onlinelibrary.wiley.com/doi/10.1111/1467-9868.00070/abstract"&gt;http://onlinelibrary.wiley.com/doi/10.1111/1467-9868.00070/abstract&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-salvatier_probabilistic_2016"&gt;
&lt;p&gt;Salvatier, John, Thomas V. Wiecki, and Christopher Fonnesbeck. 2016. “Probabilistic Programming in Python Using PyMC3.” &lt;em&gt;PeerJ Computer Science&lt;/em&gt; 2 (April): e55. &lt;a href="https://peerj.com/articles/cs-55"&gt;https://peerj.com/articles/cs-55&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-scikit-learn_sklearn.linear_model.elasticnet_2017"&gt;
&lt;p&gt;scikit-learn. 2017. “Sklearn.Linear_model.ElasticNet Scikit-Learn 0.19.Dev0 Documentation.” &lt;a href="http://scikit-learn.org/dev/modules/generated/sklearn.linear_model.ElasticNet.html\#sklearn-linear-model-elasticnet"&gt;http://scikit-learn.org/dev/modules/generated/sklearn.linear_model.ElasticNet.html\#sklearn-linear-model-elasticnet&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-svaiter_pyprox_2017"&gt;
&lt;p&gt;svaiter. 2017. “Pyprox.” &lt;a href="https://github.com/svaiter/pyprox"&gt;https://github.com/svaiter/pyprox&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-willard_role_2017"&gt;
&lt;p&gt;Willard, Brandon T. 2017. “A Role for Symbolic Computation in the General Estimation of Statistical Models.” &lt;a href="https://brandonwillard.github.io/a-role-for-symbolic-computation-in-the-general-estimation-of-statistical-models.html"&gt;https://brandonwillard.github.io/a-role-for-symbolic-computation-in-the-general-estimation-of-statistical-models.html&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-wytock_new_2016"&gt;
&lt;p&gt;Wytock, Matt, Steven Diamond, Felix Heide, and Stephen Boyd. 2016. “A New Architecture for Optimization Modeling Frameworks.” &lt;em&gt;arXiv Preprint arXiv:1609.03488&lt;/em&gt;. &lt;a href="https://arxiv.org/abs/1609.03488"&gt;https://arxiv.org/abs/1609.03488&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;script type="text/x-mathjax-config"&gt;
MathJax.Hub.Config({
  CommonHTML: { linebreaks: { automatic: true } },
  "HTML-CSS": { linebreaks: { automatic: true } },
  SVG: { linebreaks: { automatic: true } },
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry><entry><title>A Role for Symbolic Computation in the General Estimation of Statistical Models</title><link href="https://brandonwillard.github.io/a-role-for-symbolic-computation-in-the-general-estimation-of-statistical-models.html" rel="alternate"></link><published>2017-01-18T00:00:00-06:00</published><updated>2017-01-18T00:00:00-06:00</updated><author><name>Brandon T. Willard</name></author><id>tag:brandonwillard.github.io,2017-01-18:/a-role-for-symbolic-computation-in-the-general-estimation-of-statistical-models.html</id><summary type="html"></summary><content type="html">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
  &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
  &lt;meta http-equiv="Content-Style-Type" content="text/css" /&gt;
  &lt;meta name="generator" content="pandoc" /&gt;
  &lt;meta name="author" content="Brandon T. Willard" /&gt;
  &lt;title&gt;A Role for Symbolic Computation in the General Estimation of Statistical Models&lt;/title&gt;
  &lt;style type="text/css"&gt;code{white-space: pre;}&lt;/style&gt;
  &lt;style type="text/css"&gt;
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  &lt;/style&gt;
  &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!--  --&gt;
&lt;!-- &lt;div id="header"&gt; --&gt;
&lt;!-- &lt;h1 class="title"&gt;A Role for Symbolic Computation in the General Estimation of Statistical Models&lt;/h1&gt; --&gt;
&lt;!--  --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;h2 class="author"&gt;Brandon T. Willard&lt;/h2&gt; --&gt;
&lt;!--  --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;h3 class="date"&gt;2017–01–18&lt;/h3&gt; --&gt;
&lt;!--  --&gt;
&lt;!-- &lt;/div&gt; --&gt;
&lt;!--  --&gt;
&lt;section id="introduction" class="level1"&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In this document we describe how symbolic computation can be used to provide generalizable statistical estimation through a combination of existing open source frameworks. Specifically, we will show how symbolic tools can be used to address the estimation of non-smooth functions that appear in models with parameter regularization, shrinkage and sparsity. We employ a mathematical framework that makes extensive use of &lt;em&gt;proximal operators&lt;/em&gt; &lt;span class="citation" data-cites="parikh_proximal_2014 combettes_proximal_2011"&gt;(Parikh and Boyd 2014; Combettes and Pesquet 2011)&lt;/span&gt; and their properties for maximum a posteriori (MAP) estimation: i.e. the &lt;em&gt;proximal framework&lt;/em&gt;. This framework produces what we’ll call &lt;em&gt;proximal methods&lt;/em&gt; and their implementations as &lt;em&gt;proximal algorithms&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In &lt;span class="citation" data-cites="polson_proximal_2015"&gt;Polson, Scott, and Willard (2015)&lt;/span&gt; we outlined a set of seemingly disparate optimization techniques within the fields of statistics, computer vision, and machine learning (e.g. gradient descent, ADMM, EM, Douglas-Rachford) that are unified by their various applications of proximal methods. These methods–and the concepts behind them–have found much success in recent times and admit quite a few interesting paths for research. In other words, there are many reasons to alone discuss the implementation of proximal methods.&lt;/p&gt;
&lt;p&gt;Proximal operators also enjoy a breadth of closed-form solutions and useful properties that are amenable to symbolic computation. In more than a few cases, the work required to produce a proximal algorithm overlaps with well-established features of computer algebra systems and symbolic mathematics, such as symbolic differentiation and algebraic equation solving.&lt;/p&gt;
&lt;p&gt;Symbolic integration provides an excellent example of how proximal operators could be implemented in a symbolic system. In these systems, mappings between functions (as canonicalized graphs) and their generalized hypergeometric equivalents are used to exploit the latter’s relevant convolution identities. In the same vein, it is possible to use tables of closed-form proximal operators and their properties to produce a wide array of estimation algorithms for many non-smooth functions. We outline how this might be done in the following sections.&lt;/p&gt;
&lt;p&gt;Otherwise, the ideas discussed here are part of a never-ending attempt to answer a question that arises naturally in both mathematics and programming–at all levels: &lt;em&gt;How does one provide a means of generating robust solutions to as many problems as possible?&lt;/em&gt; Instead of the common efforts to independently implement each model, method and/or combination of the two–followed by their placement in an API or library of functions–implementations can be encoded in and organized by the very mathematics from which they were derived. This close coupling between mathematical principles and their implementations might be the only reasonable way to remove barriers between theory, research and practice.&lt;/p&gt;
&lt;section id="a-context" class="level2"&gt;
&lt;h2&gt;A Context&lt;/h2&gt;
&lt;p&gt;Much recent work in statistical modeling and estimation has had the goal of producing sparse results and/or efficient, near automatic model selection. This objective is shared with other related practices–such as Deep Learning and Compressed Sensing. In the former case, we can point to Dropout &lt;span class="citation" data-cites="srivastava_dropout_2014"&gt;(Srivastava et al. 2014)&lt;/span&gt; and–in the latter–&lt;span class="math inline"&gt;\(\ell_p\)&lt;/span&gt; regularization &lt;span class="citation" data-cites="donoho_compressed_2006"&gt;(Donoho 2006)&lt;/span&gt; as basic examples.&lt;/p&gt;
&lt;p&gt;Here we’ll simply assume that a practitioner intends to produce sparse estimates using the well-known LASSO–or &lt;span class="math inline"&gt;\(\ell_1\)&lt;/span&gt; penalty.&lt;/p&gt;
&lt;p&gt;In PyMC3 &lt;span class="citation" data-cites="salvatier_probabilistic_2016"&gt;(Salvatier, Wiecki, and Fonnesbeck 2016)&lt;/span&gt;, the Bayes version of LASSO &lt;span class="citation" data-cites="park_bayesian_2008"&gt;(Park and Casella 2008)&lt;/span&gt; is easily specified.&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb1-1" title="1"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-2" title="2"&gt;&lt;span class="im"&gt;import&lt;/span&gt; scipy &lt;span class="im"&gt;as&lt;/span&gt; sc&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-4" title="4"&gt;&lt;span class="im"&gt;import&lt;/span&gt; pymc3 &lt;span class="im"&gt;as&lt;/span&gt; pm&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-5" title="5"&gt;&lt;span class="im"&gt;import&lt;/span&gt; theano&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-6" title="6"&gt;&lt;span class="im"&gt;import&lt;/span&gt; theano.tensor &lt;span class="im"&gt;as&lt;/span&gt; tt&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-7" title="7"&gt;&lt;span class="im"&gt;from&lt;/span&gt; theano &lt;span class="im"&gt;import&lt;/span&gt; shared &lt;span class="im"&gt;as&lt;/span&gt; tt_shared&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-8" title="8"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-9" title="9"&gt;theano.config.mode &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;#39;FAST_COMPILE&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-10" title="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-11" title="11"&gt;mu_true &lt;span class="op"&gt;=&lt;/span&gt; np.zeros(&lt;span class="dv"&gt;100&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-12" title="12"&gt;mu_true[:&lt;span class="dv"&gt;20&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; np.exp(&lt;span class="op"&gt;-&lt;/span&gt;np.arange(&lt;span class="dv"&gt;20&lt;/span&gt;)) &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="dv"&gt;100&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-13" title="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-14" title="14"&gt;X &lt;span class="op"&gt;=&lt;/span&gt; np.random.randn(&lt;span class="bu"&gt;int&lt;/span&gt;(np.alen(mu_true) &lt;span class="op"&gt;*&lt;/span&gt; &lt;span class="fl"&gt;0.7&lt;/span&gt;), np.alen(mu_true))&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-15" title="15"&gt;y &lt;span class="op"&gt;=&lt;/span&gt; sc.stats.norm.rvs(loc&lt;span class="op"&gt;=&lt;/span&gt;X.dot(mu_true), scale&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-16" title="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-17" title="17"&gt;X_tt &lt;span class="op"&gt;=&lt;/span&gt; tt_shared(X, name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;X&amp;#39;&lt;/span&gt;, borrow&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-18" title="18"&gt;y_tt &lt;span class="op"&gt;=&lt;/span&gt; tt_shared(y, name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, borrow&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="va"&gt;True&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-19" title="19"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-20" title="20"&gt;&lt;span class="cf"&gt;with&lt;/span&gt; pm.Model() &lt;span class="im"&gt;as&lt;/span&gt; lasso_model:&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-21" title="21"&gt;    &lt;span class="co"&gt;# Would be nice if we could pass the symbolic y_tt.shape, so&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-22" title="22"&gt;    &lt;span class="co"&gt;# that our model would automatically conform to changes in&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-23" title="23"&gt;    &lt;span class="co"&gt;# the shared variables X_tt.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-24" title="24"&gt;    &lt;span class="co"&gt;# See https://github.com/pymc-devs/pymc3/pull/1125&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-25" title="25"&gt;    beta_rv &lt;span class="op"&gt;=&lt;/span&gt; pm.Laplace(&lt;span class="st"&gt;&amp;#39;beta&amp;#39;&lt;/span&gt;, mu&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;0&lt;/span&gt;, b&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;, shape&lt;span class="op"&gt;=&lt;/span&gt;X.shape[&lt;span class="dv"&gt;1&lt;/span&gt;])&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-26" title="26"&gt;    y_rv &lt;span class="op"&gt;=&lt;/span&gt; pm.Normal(&lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, mu&lt;span class="op"&gt;=&lt;/span&gt;X_tt.dot(beta_rv), sd&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb1-27" title="27"&gt;                     shape&lt;span class="op"&gt;=&lt;/span&gt;y.shape[&lt;span class="dv"&gt;0&lt;/span&gt;], observed&lt;span class="op"&gt;=&lt;/span&gt;y_tt)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Again, the negative total log likelihood in our example has a non-smooth &lt;span class="math inline"&gt;\(\ell_1\)&lt;/span&gt; term. Keeping this in mind, let’s say we wanted to produce a MAP estimate using PyMC3. A function is already provided for this task: &lt;code&gt;find_MAP&lt;/code&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb2-1" title="1"&gt;&lt;span class="cf"&gt;with&lt;/span&gt; lasso_model:&lt;/a&gt;
&lt;a class="sourceLine" id="cb2-2" title="2"&gt;    params_0 &lt;span class="op"&gt;=&lt;/span&gt; pm.find_MAP(&lt;span class="bu"&gt;vars&lt;/span&gt;&lt;span class="op"&gt;=&lt;/span&gt;[beta_rv])&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In our run of the above, an exception was thrown due to &lt;code&gt;nan&lt;/code&gt; values within the gradient evaluation. We can inspect the gradient at &lt;span class="math inline"&gt;\(\beta = 0, 1\)&lt;/span&gt; and reproduce the result.&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb3-1" title="1"&gt;start &lt;span class="op"&gt;=&lt;/span&gt; pm.Point({&lt;span class="st"&gt;&amp;#39;beta&amp;#39;&lt;/span&gt;: np.zeros(X.shape[&lt;span class="dv"&gt;1&lt;/span&gt;])}, model&lt;span class="op"&gt;=&lt;/span&gt;lasso_model)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-2" title="2"&gt;bij &lt;span class="op"&gt;=&lt;/span&gt; pm.DictToArrayBijection(pm.ArrayOrdering(lasso_model.&lt;span class="bu"&gt;vars&lt;/span&gt;),&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-3" title="3"&gt;start)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-4" title="4"&gt;logp &lt;span class="op"&gt;=&lt;/span&gt; bij.mapf(lasso_model.fastlogp)&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-5" title="5"&gt;dlogp &lt;span class="op"&gt;=&lt;/span&gt; bij.mapf(lasso_model.fastdlogp(lasso_model.&lt;span class="bu"&gt;vars&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-6" title="6"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-7" title="7"&gt;&lt;span class="co"&gt;# Could also inspect the log likelihood of the prior:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-8" title="8"&gt;&lt;span class="co"&gt;# beta_rv.dlogp().f(np.zeros_like(start[&amp;#39;beta&amp;#39;]))&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-9" title="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-10" title="10"&gt;grad_at_0 &lt;span class="op"&gt;=&lt;/span&gt; dlogp(np.zeros_like(start[&lt;span class="st"&gt;&amp;#39;beta&amp;#39;&lt;/span&gt;]))&lt;/a&gt;
&lt;a class="sourceLine" id="cb3-11" title="11"&gt;grad_at_1 &lt;span class="op"&gt;=&lt;/span&gt; dlogp(np.ones_like(start[&lt;span class="st"&gt;&amp;#39;beta&amp;#39;&lt;/span&gt;]))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb4-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="bu"&gt;print&lt;/span&gt;(np.&lt;span class="bu"&gt;sum&lt;/span&gt;(np.isnan(grad_at_0)))&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-2" title="2"&gt;&lt;span class="dv"&gt;100&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="bu"&gt;print&lt;/span&gt;(np.&lt;span class="bu"&gt;sum&lt;/span&gt;(np.isnan(grad_at_1)))&lt;/a&gt;
&lt;a class="sourceLine" id="cb4-4" title="4"&gt;&lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The s are not due to any short-coming of PyMC3; they only demonstrate a suitable place for our ideas and improvements. Additionally, by working within PyMC3, we can readily apply certain mathematical results. For instance, theorems that apply only to distributions. This idea is more relevant to the graph optimizations we consider later, but is still very important.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
&lt;section id="the-proximal-context" class="level1"&gt;
&lt;h1&gt;The Proximal Context&lt;/h1&gt;
&lt;p&gt;We start with the essential ingredient: the proximal operator.&lt;/p&gt;
&lt;div class="Def" data-markdown="" data-title-name="[Proximal Operator]"&gt;
&lt;p&gt;&lt;span class="math display"&gt;\[\begin{equation*}
\operatorname*{prox}_{\phi}(x) =
    \operatorname*{argmin}_{z} \left\{
    \frac{1}{2} \left(z - x\right)^2 + \phi(z)
    \right\}
    \;.
\end{equation*}\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;As we mentioned earlier, the proximal operator is the main tool of proximal algorithms. Exact solutions to proximal operators exist for many &lt;span class="math inline"&gt;\(\phi\)&lt;/span&gt;, and, since they’re often quite simple in form, their computation is relatively cheap: a property that the proximal methods themselves can inherit.&lt;/p&gt;
&lt;p&gt;Consider the MAP estimation of a penalized likelihood, i.e. &lt;span class="math display"&gt;\[\begin{equation}
\beta^* = \operatorname*{argmin}_\beta \left\{ l(\beta) + \gamma \phi(\beta) \right\}
  \;,
  \label{eq:prox_problem}
\end{equation}\]&lt;/span&gt; where functions &lt;span class="math inline"&gt;\(l\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(\phi\)&lt;/span&gt; are commonly referred to as likelihood and prior terms (or loss and penalty), respectively. The proximal framework usually assumes &lt;span class="math inline"&gt;\(l\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(\phi\)&lt;/span&gt; are at least lower semi-continuous and convex–although quite a few useful results still hold for non-convex functions.&lt;/p&gt;
&lt;p&gt;Notice that Equation &lt;span class="math inline"&gt;\(\eqref{eq:prox_problem}\)&lt;/span&gt; takes the form of a proximal operator when &lt;span class="math inline"&gt;\(l(\beta) = \frac{1}{2} (y - \beta)^2\)&lt;/span&gt;. Otherwise, in regression problems, we have &lt;span class="math inline"&gt;\(l(\beta) = \frac{1}{2} \|y - X \beta\|^2\)&lt;/span&gt;. In this case, properties of the proximal operator can be used to produce independent proximal operators in each dimension of &lt;span class="math inline"&gt;\(\beta\)&lt;/span&gt;. Since more than one property of the proximal operator can accomplish this–and result in distinct approaches–one might begin to see here a reason for the breadth of proximal methods.&lt;/p&gt;
&lt;p&gt;The proximal operator relevant to our example, &lt;span class="math inline"&gt;\(\operatorname*{prox}_{|\cdot|}\)&lt;/span&gt;, is equivalent to the soft-thresholding operator. Its implementation in Theano is somewhat trivial, but–for the sake of exposition–we provide an example.&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb5-1" title="1"&gt;beta_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.vector(&lt;span class="st"&gt;&amp;#39;beta&amp;#39;&lt;/span&gt;, dtype&lt;span class="op"&gt;=&lt;/span&gt;tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-2" title="2"&gt;beta_tt.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.r_[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;, &lt;span class="dv"&gt;-1&lt;/span&gt;, &lt;span class="fl"&gt;-0.2&lt;/span&gt;, &lt;span class="dv"&gt;0&lt;/span&gt;, &lt;span class="fl"&gt;0.2&lt;/span&gt;, &lt;span class="dv"&gt;1&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-3" title="3"&gt;&lt;span class="dv"&gt;10&lt;/span&gt;].astype(tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-5" title="5"&gt;lambda_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.scalar(&lt;span class="st"&gt;&amp;#39;lambda&amp;#39;&lt;/span&gt;, dtype&lt;span class="op"&gt;=&lt;/span&gt;tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-6" title="6"&gt;lambda_tt.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array(&lt;span class="fl"&gt;0.5&lt;/span&gt;).astype(tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-8" title="8"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; soft_threshold(beta_, lambda_):&lt;/a&gt;
&lt;a class="sourceLine" id="cb5-9" title="9"&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; tt.sgn(beta_) &lt;span class="op"&gt;*&lt;/span&gt; tt.maximum(tt.abs_(beta_) &lt;span class="op"&gt;-&lt;/span&gt; lambda_, &lt;span class="dv"&gt;0&lt;/span&gt;)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb6-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="bu"&gt;print&lt;/span&gt;(soft_threshold(beta_tt, lambda_tt).tag.test_value)&lt;/a&gt;
&lt;a class="sourceLine" id="cb6-2" title="2"&gt;[&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;9.5&lt;/span&gt; &lt;span class="fl"&gt;-0.5&lt;/span&gt; &lt;span class="fl"&gt;-0.&lt;/span&gt;   &lt;span class="fl"&gt;0.&lt;/span&gt;   &lt;span class="fl"&gt;0.&lt;/span&gt;   &lt;span class="fl"&gt;0.5&lt;/span&gt;  &lt;span class="fl"&gt;9.5&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Proximal operators can be composed with a gradient step to produce the &lt;em&gt;proximal gradient&lt;/em&gt; algorithm: &lt;span class="math display"&gt;\[\begin{equation}
\beta = \operatorname*{prox}_{\alpha \lambda \phi}(\beta - \alpha \nabla l(\beta))
  \;.
  \label{eq:forward-backward}
\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Besides the proximal operator for &lt;span class="math inline"&gt;\(\phi\)&lt;/span&gt;, steps in the proximal gradient algorithm are very straightforward and require only the gradient of &lt;span class="math inline"&gt;\(l(\beta)\)&lt;/span&gt;. This is where a tangible benefit of symbolic computation becomes apparent: &lt;span class="math inline"&gt;\(\nabla l(\beta)\)&lt;/span&gt; can be computed automatically and efficiently. With [backtracking] line search to handle unknown step sizes, &lt;span class="math inline"&gt;\(\alpha\)&lt;/span&gt;, the proximal gradient algorithm provides a surprisingly general means of sparse estimation.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="the-symbolic-operations" class="level1"&gt;
&lt;h1&gt;The Symbolic Operations&lt;/h1&gt;
&lt;p&gt;In order to identify a relevant, non-smooth problem, check that a given proximal method’s conditions are satisfied (e.g. convexity), and potentially solve the resulting proximal operators in closed-form, we need to obtain expressions for &lt;span class="math inline"&gt;\(l\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(\phi\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;In some cases, we’re able to tease apart &lt;span class="math inline"&gt;\(l\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(\phi\)&lt;/span&gt; using only the interface provided by PyMC3. Specifically, the &lt;em&gt;observed&lt;/em&gt; and &lt;em&gt;unobserved&lt;/em&gt; random variable fields in PyMC3 models.&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb7-1" title="1"&gt;&lt;span class="im"&gt;from&lt;/span&gt; theano &lt;span class="im"&gt;import&lt;/span&gt; clone &lt;span class="im"&gt;as&lt;/span&gt; tt_clone&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-2" title="2"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-3" title="3"&gt;logl &lt;span class="op"&gt;=&lt;/span&gt; tt_clone(lasso_model.observed_RVs[&lt;span class="dv"&gt;0&lt;/span&gt;].logpt,&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-4" title="4"&gt;                {beta_rv: beta_tt})&lt;/a&gt;
&lt;a class="sourceLine" id="cb7-5" title="5"&gt;logl.name &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&amp;quot;logl&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Instead, let’s assume we’re extending &lt;code&gt;find_MAP&lt;/code&gt; with even more generality, so that we can’t determine &lt;span class="math inline"&gt;\(l\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(\phi\)&lt;/span&gt; in this way. This situation can occur when a user specifies custom distributions or potential functions. Regardless, we need to operate at a more symbolic level.&lt;/p&gt;
&lt;div class="remark" data-markdown="" data-title-name=""&gt;
&lt;p&gt;At this point, it is extremely worthwhile to browse the &lt;a href="http://deeplearning.net/software/theano/extending/graphstructures.html"&gt;Theano documentation&lt;/a&gt; regarding graphs and their constituent objects.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The total log-likelihood is a good place to start. Let’s look at the symbolic graph for the log-likelihood of our model.&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb8-1" title="1"&gt;&lt;span class="im"&gt;from&lt;/span&gt; theano &lt;span class="im"&gt;import&lt;/span&gt; pp &lt;span class="im"&gt;as&lt;/span&gt; tt_pp&lt;/a&gt;
&lt;a class="sourceLine" id="cb8-2" title="2"&gt;&lt;span class="im"&gt;from&lt;/span&gt; theano &lt;span class="im"&gt;import&lt;/span&gt; pprint &lt;span class="im"&gt;as&lt;/span&gt; tt_pprint&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb9-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="bu"&gt;print&lt;/span&gt;(tt_pp(lasso_model.logpt))&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-2" title="2"&gt;(Sum{acc_dtype&lt;span class="op"&gt;=&lt;/span&gt;float64}(Sum{acc_dtype&lt;span class="op"&gt;=&lt;/span&gt;float64}(((&lt;span class="op"&gt;-&lt;/span&gt;log(TensorConstant{&lt;span class="dv"&gt;2&lt;/span&gt;}))&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-3" title="3"&gt;&lt;span class="op"&gt;-&lt;/span&gt; (&lt;span class="op"&gt;|&lt;/span&gt;(&lt;span class="op"&gt;\&lt;/span&gt;beta &lt;span class="op"&gt;-&lt;/span&gt; TensorConstant{&lt;span class="dv"&gt;0&lt;/span&gt;})&lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;/&lt;/span&gt; TensorConstant{&lt;span class="dv"&gt;1&lt;/span&gt;})))) &lt;span class="op"&gt;+&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-4" title="4"&gt;Sum{acc_dtype&lt;span class="op"&gt;=&lt;/span&gt;float64}(Sum{acc_dtype&lt;span class="op"&gt;=&lt;/span&gt;float64}(switch(TensorConstant{&lt;span class="dv"&gt;1&lt;/span&gt;},&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-5" title="5"&gt;(((TensorConstant{&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;1.0&lt;/span&gt;} &lt;span class="op"&gt;*&lt;/span&gt; ((y &lt;span class="op"&gt;-&lt;/span&gt; (X &lt;span class="op"&gt;\&lt;/span&gt;dot &lt;span class="op"&gt;\&lt;/span&gt;beta)) &lt;span class="op"&gt;**&lt;/span&gt; TensorConstant{&lt;span class="dv"&gt;2&lt;/span&gt;}))&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-6" title="6"&gt;&lt;span class="op"&gt;+&lt;/span&gt; log(TensorConstant{&lt;span class="fl"&gt;0.159154943092&lt;/span&gt;})) &lt;span class="op"&gt;/&lt;/span&gt; TensorConstant{&lt;span class="fl"&gt;2.0&lt;/span&gt;}),&lt;/a&gt;
&lt;a class="sourceLine" id="cb9-7" title="7"&gt;TensorConstant{&lt;span class="op"&gt;-&lt;/span&gt;inf}))))&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;a href="http://deeplearning.net/software/theano/tutorial/printing_drawing.html#pretty-printing"&gt;pretty printed&lt;/a&gt; Theano graph tells us–among other things–that we indeed have a sum of &lt;span class="math inline"&gt;\(\ell_2\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(\ell_1\)&lt;/span&gt; terms, although they are found among other confusing results (such as a &lt;code&gt;switch&lt;/code&gt; statement).&lt;/p&gt;
&lt;p&gt;As with most graphs produced by symbolic algebra systems, we need to understand how operations and objects are expressed in a graph and exactly which ones are relevant to us. After doing so, we can develop a means of finding what we want. The &lt;a href="http://deeplearning.net/software/theano/tutorial/printing_drawing.html#debug-print"&gt;debug printout&lt;/a&gt; is often a better visual summary of graphs, since it expresses branches clearly.&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb10-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; tt.printing.debugprint(lasso_model.logpt)&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-2" title="2"&gt;Elemwise{add,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; A] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-3" title="3"&gt; &lt;span class="op"&gt;|&lt;/span&gt;Sum{acc_dtype&lt;span class="op"&gt;=&lt;/span&gt;float64} [&lt;span class="bu"&gt;id&lt;/span&gt; B] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-4" title="4"&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;Sum{acc_dtype&lt;span class="op"&gt;=&lt;/span&gt;float64} [&lt;span class="bu"&gt;id&lt;/span&gt; C] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-5" title="5"&gt; &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{sub,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; D] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-6" title="6"&gt; &lt;span class="op"&gt;|&lt;/span&gt;     &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; E] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-7" title="7"&gt; &lt;span class="op"&gt;|&lt;/span&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{neg,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; F] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-8" title="8"&gt; &lt;span class="op"&gt;|&lt;/span&gt;     &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{log,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; G] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-9" title="9"&gt; &lt;span class="op"&gt;|&lt;/span&gt;     &lt;span class="op"&gt;|&lt;/span&gt;     &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;2&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; H]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-10" title="10"&gt; &lt;span class="op"&gt;|&lt;/span&gt;     &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{true_div,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; I] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-11" title="11"&gt; &lt;span class="op"&gt;|&lt;/span&gt;       &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{abs_,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; J] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-12" title="12"&gt; &lt;span class="op"&gt;|&lt;/span&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{sub,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; K] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-13" title="13"&gt; &lt;span class="op"&gt;|&lt;/span&gt;       &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;beta [&lt;span class="bu"&gt;id&lt;/span&gt; L]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-14" title="14"&gt; &lt;span class="op"&gt;|&lt;/span&gt;       &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; M] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-15" title="15"&gt; &lt;span class="op"&gt;|&lt;/span&gt;       &lt;span class="op"&gt;|&lt;/span&gt;     &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;0&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; N]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-16" title="16"&gt; &lt;span class="op"&gt;|&lt;/span&gt;       &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; O] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-17" title="17"&gt; &lt;span class="op"&gt;|&lt;/span&gt;         &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;1&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; P]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-18" title="18"&gt; &lt;span class="op"&gt;|&lt;/span&gt;Sum{acc_dtype&lt;span class="op"&gt;=&lt;/span&gt;float64} [&lt;span class="bu"&gt;id&lt;/span&gt; Q] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-19" title="19"&gt;   &lt;span class="op"&gt;|&lt;/span&gt;Sum{acc_dtype&lt;span class="op"&gt;=&lt;/span&gt;float64} [&lt;span class="bu"&gt;id&lt;/span&gt; R] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-20" title="20"&gt;     &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{switch,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; S] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-21" title="21"&gt;       &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; T] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-22" title="22"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;1&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; P]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-23" title="23"&gt;       &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{true_div,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; U] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-24" title="24"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{add,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; V] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-25" title="25"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{mul,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; W] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-26" title="26"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; X] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-27" title="27"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;1.0&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; Y]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-28" title="28"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{&lt;span class="bu"&gt;pow&lt;/span&gt;,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; Z] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-29" title="29"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{sub,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; BA] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-30" title="30"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;y [&lt;span class="bu"&gt;id&lt;/span&gt; BB]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-31" title="31"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;dot [&lt;span class="bu"&gt;id&lt;/span&gt; BC] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-32" title="32"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;X [&lt;span class="bu"&gt;id&lt;/span&gt; BD]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-33" title="33"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;beta [&lt;span class="bu"&gt;id&lt;/span&gt; L]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-34" title="34"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; BE] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-35" title="35"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;     &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;2&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; H]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-36" title="36"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; BF] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-37" title="37"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{log,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; BG] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-38" title="38"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;     &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="fl"&gt;0.159154943092&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; BH]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-39" title="39"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; BI] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-40" title="40"&gt;       &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="fl"&gt;2.0&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; BJ]&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-41" title="41"&gt;       &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; BK] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb10-42" title="42"&gt;         &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="op"&gt;-&lt;/span&gt;inf} [&lt;span class="bu"&gt;id&lt;/span&gt; BL]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see that the top-most operator is an &lt;code&gt;Elemwise&lt;/code&gt; that applies the scalar &lt;code&gt;add&lt;/code&gt; operation. This is the “&lt;span class="math inline"&gt;\(+\)&lt;/span&gt;” in &lt;span class="math inline"&gt;\(l + \phi\)&lt;/span&gt;. If we were to consider the inputs of this operator as candidates for &lt;span class="math inline"&gt;\(l\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(\phi\)&lt;/span&gt;, then we could do the following:&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb11-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="bu"&gt;print&lt;/span&gt;(lasso_model.logpt.owner.inputs)&lt;/a&gt;
&lt;a class="sourceLine" id="cb11-2" title="2"&gt;[Sum{acc_dtype&lt;span class="op"&gt;=&lt;/span&gt;float64}.&lt;span class="dv"&gt;0&lt;/span&gt;, Sum{acc_dtype&lt;span class="op"&gt;=&lt;/span&gt;float64}.&lt;span class="dv"&gt;0&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Starting from the sub-graphs of each term, we could then search for any non-smooth functions that have known closed-form proximal operators. In our case, we only consider the absolute value function.&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb12-1" title="1"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; get_abs_between(input_node):&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-2" title="2"&gt;    &lt;span class="co"&gt;&amp;quot;&amp;quot;&amp;quot; Search for `abs` in the operations between our input and the&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-3" title="3"&gt;&lt;span class="co"&gt;    log-likelihood output node.&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-4" title="4"&gt;&lt;span class="co"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-5" title="5"&gt;    term_ops &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;list&lt;/span&gt;(tt.gof.graph.ops([input_node],&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-6" title="6"&gt;[lasso_model.logpt]))&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-7" title="7"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-8" title="8"&gt;    &lt;span class="co"&gt;# Is there an absolute value in there?&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-9" title="9"&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;filter&lt;/span&gt;(&lt;span class="kw"&gt;lambda&lt;/span&gt; x: x.op &lt;span class="kw"&gt;is&lt;/span&gt; tt.abs_, term_ops)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-10" title="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-11" title="11"&gt;abs_res &lt;span class="op"&gt;=&lt;/span&gt; [(get_abs_between(in_), in_)&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-12" title="12"&gt;           &lt;span class="cf"&gt;for&lt;/span&gt; in_ &lt;span class="kw"&gt;in&lt;/span&gt; lasso_model.logpt.owner.inputs]&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-13" title="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-14" title="14"&gt;&lt;span class="cf"&gt;for&lt;/span&gt; r_ &lt;span class="kw"&gt;in&lt;/span&gt; abs_res:&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-15" title="15"&gt;    &lt;span class="cf"&gt;if&lt;/span&gt; &lt;span class="bu"&gt;len&lt;/span&gt;(r_[&lt;span class="dv"&gt;0&lt;/span&gt;]) &lt;span class="op"&gt;==&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-16" title="16"&gt;        phi &lt;span class="op"&gt;=&lt;/span&gt; r_[&lt;span class="dv"&gt;1&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-17" title="17"&gt;    &lt;span class="cf"&gt;else&lt;/span&gt;:&lt;/a&gt;
&lt;a class="sourceLine" id="cb12-18" title="18"&gt;        logp &lt;span class="op"&gt;=&lt;/span&gt; r_[&lt;span class="dv"&gt;1&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb13-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; tt.printing.debugprint(logp)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-2" title="2"&gt;Sum{acc_dtype&lt;span class="op"&gt;=&lt;/span&gt;float64} [&lt;span class="bu"&gt;id&lt;/span&gt; A] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-3" title="3"&gt; &lt;span class="op"&gt;|&lt;/span&gt;Sum{acc_dtype&lt;span class="op"&gt;=&lt;/span&gt;float64} [&lt;span class="bu"&gt;id&lt;/span&gt; B] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-4" title="4"&gt;   &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{switch,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; C] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-5" title="5"&gt;     &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; D] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-6" title="6"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;1&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; E]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-7" title="7"&gt;     &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{true_div,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; F] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-8" title="8"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{add,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; G] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-9" title="9"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{mul,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; H] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-10" title="10"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; I] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-11" title="11"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="fl"&gt;1.0&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; J]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-12" title="12"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{&lt;span class="bu"&gt;pow&lt;/span&gt;,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; K] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-13" title="13"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{sub,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; L] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-14" title="14"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;y [&lt;span class="bu"&gt;id&lt;/span&gt; M]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-15" title="15"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;dot [&lt;span class="bu"&gt;id&lt;/span&gt; N] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-16" title="16"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;X [&lt;span class="bu"&gt;id&lt;/span&gt; O]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-17" title="17"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;beta [&lt;span class="bu"&gt;id&lt;/span&gt; P]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-18" title="18"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; Q] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-19" title="19"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;     &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;2&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; R]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-20" title="20"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; S] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-21" title="21"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{log,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; T] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-22" title="22"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;     &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="fl"&gt;0.159154943092&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; U]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-23" title="23"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; V] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-24" title="24"&gt;     &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="fl"&gt;2.0&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; W]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-25" title="25"&gt;     &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; X] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-26" title="26"&gt;       &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="op"&gt;-&lt;/span&gt;inf} [&lt;span class="bu"&gt;id&lt;/span&gt; Y]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-27" title="27"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; tt.printing.debugprint(phi)&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-28" title="28"&gt;Sum{acc_dtype&lt;span class="op"&gt;=&lt;/span&gt;float64} [&lt;span class="bu"&gt;id&lt;/span&gt; A] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-29" title="29"&gt; &lt;span class="op"&gt;|&lt;/span&gt;Sum{acc_dtype&lt;span class="op"&gt;=&lt;/span&gt;float64} [&lt;span class="bu"&gt;id&lt;/span&gt; B] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-30" title="30"&gt;   &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{sub,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; C] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-31" title="31"&gt;     &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; D] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-32" title="32"&gt;     &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{neg,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; E] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-33" title="33"&gt;     &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{log,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; F] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-34" title="34"&gt;     &lt;span class="op"&gt;|&lt;/span&gt;     &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;2&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; G]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-35" title="35"&gt;     &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{true_div,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; H] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-36" title="36"&gt;       &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{abs_,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; I] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-37" title="37"&gt;       &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{sub,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; J] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-38" title="38"&gt;       &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;beta [&lt;span class="bu"&gt;id&lt;/span&gt; K]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-39" title="39"&gt;       &lt;span class="op"&gt;|&lt;/span&gt;   &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; L] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-40" title="40"&gt;       &lt;span class="op"&gt;|&lt;/span&gt;     &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;0&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; M]&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-41" title="41"&gt;       &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; N] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb13-42" title="42"&gt;         &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;1&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; O]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The above approach is still too limiting; we need something more robust. For instance, our logic could fail on graphs that are expressed as &lt;span class="math inline"&gt;\(\eta (l + \phi) + 1\)&lt;/span&gt;–although a graph for the equivalent expression &lt;span class="math inline"&gt;\(\eta l + \eta \phi + \eta\)&lt;/span&gt; might succeed. These are types of weaknesses inherent to naive approaches like ours. Furthermore, sufficient logic that uses a similar approach is likely to result in complicated and less approachable code.&lt;/p&gt;
&lt;p&gt;The appropriate computational tools are found in the subjects of graph unification and term rewriting, as well as the areas of functional and logic programming. Luckily, Theano provides some basic unification capabilities through its &lt;code&gt;PatternSub&lt;/code&gt; class.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PatternSub&lt;/code&gt; works within the context of Theano &lt;a href="http://deeplearning.net/software/theano/optimizations.html"&gt;graph optimization&lt;/a&gt;. Graph optimizations perform the common symbolic operations of reduction/simplification and rewriting. Consider the &lt;code&gt;phi&lt;/code&gt; variable; the print-outs show an unnecessary subtraction with &lt;span class="math inline"&gt;\(0\)&lt;/span&gt;. Clearly this step is unnecessary, so–in a basic way–we can see that the graph hasn’t been simplified, yet.&lt;/p&gt;
&lt;p&gt;Many standard algebraic simplifications are already present in Theano, and, by creating our own graph optimizations, we can provide the advanced functionality we’ve been alluding to.&lt;/p&gt;
&lt;div class="example" data-markdown="" data-title-name="[Algebraic Graph Optimization]"&gt;
&lt;p&gt;As a quick demonstration, we’ll make replacement patterns for multiplicative distribution across two forms of addition: &lt;code&gt;sum&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb14-1" title="1"&gt;test_a_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.as_tensor_variable(&lt;span class="dv"&gt;5&lt;/span&gt;, name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-2" title="2"&gt;test_b_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.as_tensor_variable(&lt;span class="dv"&gt;2&lt;/span&gt;, name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-3" title="3"&gt;test_c_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.as_tensor_variable(np.r_[&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;], name&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="st"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-5" title="5"&gt;test_exprs_tt &lt;span class="op"&gt;=&lt;/span&gt; (test_a_tt &lt;span class="op"&gt;*&lt;/span&gt; test_b_tt,)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-6" title="6"&gt;test_exprs_tt &lt;span class="op"&gt;+=&lt;/span&gt; (test_a_tt &lt;span class="op"&gt;*&lt;/span&gt; (test_b_tt &lt;span class="op"&gt;+&lt;/span&gt; test_a_tt),)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-7" title="7"&gt;test_exprs_tt &lt;span class="op"&gt;+=&lt;/span&gt; (test_a_tt &lt;span class="op"&gt;*&lt;/span&gt; (test_c_tt &lt;span class="op"&gt;+&lt;/span&gt; test_a_tt),)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-8" title="8"&gt;test_exprs_tt &lt;span class="op"&gt;+=&lt;/span&gt; (test_a_tt &lt;span class="op"&gt;*&lt;/span&gt; (test_c_tt &lt;span class="op"&gt;+&lt;/span&gt; test_c_tt),)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-9" title="9"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-10" title="10"&gt;mul_dist_pat_tt &lt;span class="op"&gt;=&lt;/span&gt; (tt.gof.opt.PatternSub(&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-11" title="11"&gt;    (tt.mul, &lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, (tt.&lt;span class="bu"&gt;sum&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;)),&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-12" title="12"&gt;    (tt.&lt;span class="bu"&gt;sum&lt;/span&gt;, (tt.mul, &lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;), (tt.mul, &lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-13" title="13"&gt;),)&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-14" title="14"&gt;mul_dist_pat_tt &lt;span class="op"&gt;+=&lt;/span&gt; (tt.gof.opt.PatternSub(&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-15" title="15"&gt;    (tt.mul, &lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, (tt.add, &lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;)),&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-16" title="16"&gt;    (tt.add, (tt.mul, &lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;), (tt.mul, &lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;))&lt;/a&gt;
&lt;a class="sourceLine" id="cb14-17" title="17"&gt;),)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Substitutions can be applied to an objective function until it is in a fully-reduced form: &lt;code&gt;EquilibriumOptimizer&lt;/code&gt; provides this functionality.&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb15-1" title="1"&gt;test_sub_eqz_opt_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.gof.opt.EquilibriumOptimizer(&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-2" title="2"&gt;    mul_dist_pat_tt, max_use_ratio&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-4" title="4"&gt;test_fgraph_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.gof.fg.FunctionGraph(&lt;/a&gt;
&lt;a class="sourceLine" id="cb15-5" title="5"&gt;    tt.gof.graph.inputs(test_exprs_tt), test_exprs_tt)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb16-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; tt.printing.debugprint(test_fgraph_tt)&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-2" title="2"&gt;Elemwise{mul,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; A] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;5&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-3" title="3"&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;5&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; B]&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-4" title="4"&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;2&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; C]&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-5" title="5"&gt;Elemwise{mul,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; D] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;8&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-6" title="6"&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;5&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; B]&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-7" title="7"&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{add,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; E] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;4&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-8" title="8"&gt;   &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;2&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; C]&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-9" title="9"&gt;   &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;5&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; B]&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-10" title="10"&gt;Elemwise{mul,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; F] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;9&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-11" title="11"&gt; &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; G] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;3&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-12" title="12"&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;5&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; B]&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-13" title="13"&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{add,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; H] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;7&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-14" title="14"&gt;   &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{[&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;]} [&lt;span class="bu"&gt;id&lt;/span&gt; I]&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-15" title="15"&gt;   &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; J] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-16" title="16"&gt;     &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;5&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; B]&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-17" title="17"&gt;Elemwise{mul,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; K] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;6&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-18" title="18"&gt; &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; L] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-19" title="19"&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;5&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; B]&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-20" title="20"&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{add,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; M] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-21" title="21"&gt;   &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{[&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;]} [&lt;span class="bu"&gt;id&lt;/span&gt; I]&lt;/a&gt;
&lt;a class="sourceLine" id="cb16-22" title="22"&gt;   &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{[&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;]} [&lt;span class="bu"&gt;id&lt;/span&gt; I]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, when we apply the optimization, the &lt;code&gt;FunctionGraph&lt;/code&gt; should contain the replacements.&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb17-1" title="1"&gt;test_fgraph_opt &lt;span class="op"&gt;=&lt;/span&gt; test_sub_eqz_opt_tt.optimize(test_fgraph_tt)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb18-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; tt.printing.debugprint(test_fgraph_tt)&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-2" title="2"&gt;Elemwise{mul,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; A] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;5&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-3" title="3"&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;5&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; B]&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-4" title="4"&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;2&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; C]&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-5" title="5"&gt;Elemwise{add,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; D] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;10&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-6" title="6"&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{mul,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; E] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;4&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-7" title="7"&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;5&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; B]&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-8" title="8"&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;2&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; C]&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-9" title="9"&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{mul,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; F] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;3&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-10" title="10"&gt;   &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;5&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; B]&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-11" title="11"&gt;   &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;5&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; B]&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-12" title="12"&gt;Elemwise{add,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; G] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;12&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-13" title="13"&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{mul,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; H] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;9&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-14" title="14"&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; I] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-15" title="15"&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;5&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; B]&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-16" title="16"&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{[&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;]} [&lt;span class="bu"&gt;id&lt;/span&gt; J]&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-17" title="17"&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{mul,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; K] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;8&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-18" title="18"&gt;   &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; I] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;2&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-19" title="19"&gt;   &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; L] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-20" title="20"&gt;     &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;5&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; B]&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-21" title="21"&gt;Elemwise{add,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; M] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;11&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-22" title="22"&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{mul,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; N] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;7&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-23" title="23"&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; O] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-24" title="24"&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{&lt;span class="dv"&gt;5&lt;/span&gt;} [&lt;span class="bu"&gt;id&lt;/span&gt; B]&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-25" title="25"&gt; &lt;span class="op"&gt;|&lt;/span&gt; &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{[&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;]} [&lt;span class="bu"&gt;id&lt;/span&gt; J]&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-26" title="26"&gt; &lt;span class="op"&gt;|&lt;/span&gt;Elemwise{mul,no_inplace} [&lt;span class="bu"&gt;id&lt;/span&gt; P] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;6&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-27" title="27"&gt;   &lt;span class="op"&gt;|&lt;/span&gt;DimShuffle{x} [&lt;span class="bu"&gt;id&lt;/span&gt; O] &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb18-28" title="28"&gt;   &lt;span class="op"&gt;|&lt;/span&gt;TensorConstant{[&lt;span class="dv"&gt;1&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;]} [&lt;span class="bu"&gt;id&lt;/span&gt; J]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Even more symbolic capabilities might be needed to [efficiently] achieve the functionality we desire. Standalone libraries like SymPy and &lt;a href="https://github.com/logpy/logpy/"&gt;LogPy&lt;/a&gt; can be adapted to Theano graphs and provide these capabilities–although direct implementation in Theano may be better.&lt;/p&gt;
&lt;p&gt;Finally, let’s briefly imagine how convexity could be determined symbolically. For differentiable terms, we could start with a simple second derivative test. Within Theano, a “second derivative” can be obtained using the &lt;code&gt;hessian&lt;/code&gt; function, and within &lt;code&gt;theano.sandbox.linalg&lt;/code&gt; are &lt;code&gt;Optimizer&lt;/code&gt; hints for matrix positivity and other properties relevant to determining convexity.&lt;/p&gt;
&lt;div class="remark" data-markdown="" data-title-name=""&gt;
&lt;p&gt;Other great examples of linear algebra themed optimizations are in &lt;code&gt;theano.sandbox.linalg&lt;/code&gt;: for instance, &lt;code&gt;no_transpose_symmetric&lt;/code&gt;. Some of these demonstrate exactly how straight-forward adding algebraic features can be.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Although our convexity testing idea is far too simple for some functions, the point is that the basic tools necessary for work in this direction are already in place. With the logic programming and symbolic libraries mentioned earlier, a robust implementation of the convex function calculus could be very much in reach.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="discussion" class="level1"&gt;
&lt;h1&gt;Discussion&lt;/h1&gt;
&lt;p&gt;We’ve sketched out some ideas and tools with which one could develop a robust estimation platform guided by the more abstract mathematical frameworks from which new and efficient methods are produced.&lt;/p&gt;
&lt;p&gt;Some key steps may require the integration of a fully featured symbolic algebra system. Along these lines, connections between Theano, SymPy and LogPy have been explored in &lt;span class="citation" data-cites="rocklin_mathematically_2013"&gt;Rocklin (2013)&lt;/span&gt;–as well as many other important aspects of the topics discussed here.&lt;/p&gt;
&lt;p&gt;Besides the automation of proximal algorithms themselves, there are areas of application involving very large and complex models–perhaps the ones arising in Deep Learning. How might we consider the operator splitting of ADMM within deeply layered or hierarchical models &lt;span class="citation" data-cites="polson_statistical_2015"&gt;(Polson, Willard, and Heidari 2015)&lt;/span&gt;? At which levels and on which terms should the splitting be performed? Beyond trying to solve the potentially unwieldy mathematics arising from such questions, by imbuing these symbolic tools with more mathematical awareness, we can at least experiment in these directions and quickly offer numerical solutions. This is–in part–the edge from which statistics hasn’t been benefiting and modern machine learning has.&lt;/p&gt;
&lt;p&gt;Before closing, a very related–and interesting–set of ideas is worth mentioning: the possibility of encoding more symbolic knowledge into probabilistic programming platforms like PyMC3. Using the same optimization mechanisms as the examples here, simple distributional relationships can be encoded. For instance, the convolution of normally distributed random variables:&lt;/p&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb19-1" title="1"&gt;mu_X &lt;span class="op"&gt;=&lt;/span&gt; tt.vector(&lt;span class="st"&gt;&amp;#39;mu_X&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-2" title="2"&gt;mu_X.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([&lt;span class="fl"&gt;1.&lt;/span&gt;], dtype&lt;span class="op"&gt;=&lt;/span&gt;tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-3" title="3"&gt;sd_X &lt;span class="op"&gt;=&lt;/span&gt; tt.vector(&lt;span class="st"&gt;&amp;#39;sd_X&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-4" title="4"&gt;sd_X.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([&lt;span class="fl"&gt;2.&lt;/span&gt;], dtype&lt;span class="op"&gt;=&lt;/span&gt;tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-5" title="5"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-6" title="6"&gt;mu_Y &lt;span class="op"&gt;=&lt;/span&gt; tt.vector(&lt;span class="st"&gt;&amp;#39;mu_Y&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-7" title="7"&gt;mu_Y.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([&lt;span class="fl"&gt;1.&lt;/span&gt;], dtype&lt;span class="op"&gt;=&lt;/span&gt;tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-8" title="8"&gt;sd_Y &lt;span class="op"&gt;=&lt;/span&gt; tt.vector(&lt;span class="st"&gt;&amp;#39;sd_Y&amp;#39;&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-9" title="9"&gt;sd_Y.tag.test_value &lt;span class="op"&gt;=&lt;/span&gt; np.array([&lt;span class="fl"&gt;0.5&lt;/span&gt;], dtype&lt;span class="op"&gt;=&lt;/span&gt;tt.config.floatX)&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-10" title="10"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-11" title="11"&gt;&lt;span class="cf"&gt;with&lt;/span&gt; pm.Model() &lt;span class="im"&gt;as&lt;/span&gt; conv_model:&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-12" title="12"&gt;    X_rv &lt;span class="op"&gt;=&lt;/span&gt; pm.Normal(&lt;span class="st"&gt;&amp;#39;X&amp;#39;&lt;/span&gt;, mu_X, sd&lt;span class="op"&gt;=&lt;/span&gt;sd_X, shape&lt;span class="op"&gt;=&lt;/span&gt;(&lt;span class="dv"&gt;1&lt;/span&gt;,))&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-13" title="13"&gt;    Y_rv &lt;span class="op"&gt;=&lt;/span&gt; pm.Normal(&lt;span class="st"&gt;&amp;#39;Y&amp;#39;&lt;/span&gt;, mu_Y, sd&lt;span class="op"&gt;=&lt;/span&gt;sd_Y, shape&lt;span class="op"&gt;=&lt;/span&gt;(&lt;span class="dv"&gt;1&lt;/span&gt;,))&lt;/a&gt;
&lt;a class="sourceLine" id="cb19-14" title="14"&gt;    Z_rv &lt;span class="op"&gt;=&lt;/span&gt; X_rv &lt;span class="op"&gt;+&lt;/span&gt; Y_rv&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We create a Theano &lt;code&gt;Op&lt;/code&gt; to handle the convolution.&lt;/p&gt;
&lt;div class="sourceCode" id="cb20"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb20-1" title="1"&gt;&lt;span class="kw"&gt;class&lt;/span&gt; NormConvOp(tt.Op):&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-2" title="2"&gt;    __props__ &lt;span class="op"&gt;=&lt;/span&gt; ()&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-4" title="4"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; make_node(&lt;span class="va"&gt;self&lt;/span&gt;, &lt;span class="op"&gt;*&lt;/span&gt;inputs):&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-5" title="5"&gt;        name_new &lt;span class="op"&gt;=&lt;/span&gt; &lt;span class="bu"&gt;str&lt;/span&gt;.join(&lt;span class="st"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;, [&lt;span class="bu"&gt;getattr&lt;/span&gt;(in_, &lt;span class="st"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;&amp;#39;&lt;/span&gt;) &lt;span class="cf"&gt;for&lt;/span&gt; in_ &lt;span class="kw"&gt;in&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-6" title="6"&gt;inputs])&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-7" title="7"&gt;        mu_new &lt;span class="op"&gt;=&lt;/span&gt; tt.add(&lt;span class="op"&gt;*&lt;/span&gt;[in_.distribution.mu &lt;span class="cf"&gt;for&lt;/span&gt; in_ &lt;span class="kw"&gt;in&lt;/span&gt; inputs])&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-8" title="8"&gt;        sd_new &lt;span class="op"&gt;=&lt;/span&gt; tt.sqrt(tt.add(&lt;span class="op"&gt;*&lt;/span&gt;[in_.distribution.sd&lt;span class="op"&gt;**&lt;/span&gt;&lt;span class="dv"&gt;2&lt;/span&gt; &lt;span class="cf"&gt;for&lt;/span&gt; in_ &lt;span class="kw"&gt;in&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-9" title="9"&gt;inputs]))&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-10" title="10"&gt;        conv_rv &lt;span class="op"&gt;=&lt;/span&gt; pm.Normal(name_new, mu&lt;span class="op"&gt;=&lt;/span&gt;mu_new, sd&lt;span class="op"&gt;=&lt;/span&gt;sd_new,&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-11" title="11"&gt;                            &lt;span class="co"&gt;# Is this another place where&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-12" title="12"&gt;automatically&lt;span class="op"&gt;/&lt;/span&gt;Theano managed&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-13" title="13"&gt;                            &lt;span class="co"&gt;# shapes are really needed.  For now, we&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-14" title="14"&gt;hack it.&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-15" title="15"&gt;                            shape&lt;span class="op"&gt;=&lt;/span&gt;(&lt;span class="dv"&gt;1&lt;/span&gt;,))&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-16" title="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-17" title="17"&gt;        &lt;span class="cf"&gt;return&lt;/span&gt; tt.Apply(&lt;span class="va"&gt;self&lt;/span&gt;, inputs, [conv_rv])&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-18" title="18"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-19" title="19"&gt;    &lt;span class="kw"&gt;def&lt;/span&gt; perform(&lt;span class="va"&gt;self&lt;/span&gt;, node, inputs, output_storage):&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-20" title="20"&gt;        z &lt;span class="op"&gt;=&lt;/span&gt; output_storage[&lt;span class="dv"&gt;0&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb20-21" title="21"&gt;        z[&lt;span class="dv"&gt;0&lt;/span&gt;] &lt;span class="op"&gt;=&lt;/span&gt; np.add(&lt;span class="op"&gt;*&lt;/span&gt;inputs)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, all that’s needed is a &lt;code&gt;PatternSub&lt;/code&gt; like before.&lt;/p&gt;
&lt;div class="sourceCode" id="cb21"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb21-1" title="1"&gt;&lt;span class="kw"&gt;def&lt;/span&gt; is_normal_dist(x):&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-2" title="2"&gt;    &lt;span class="cf"&gt;return&lt;/span&gt; &lt;span class="bu"&gt;hasattr&lt;/span&gt;(x, &lt;span class="st"&gt;&amp;#39;distribution&amp;#39;&lt;/span&gt;) &lt;span class="kw"&gt;and&lt;/span&gt; &lt;span class="bu"&gt;isinstance&lt;/span&gt;(x.distribution,&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-3" title="3"&gt;pm.Normal)&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-4" title="4"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-5" title="5"&gt;norm_conv_pat_tt &lt;span class="op"&gt;=&lt;/span&gt; (tt.gof.opt.PatternSub(&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-6" title="6"&gt;    (tt.add,&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-7" title="7"&gt;     {&lt;span class="st"&gt;&amp;#39;pattern&amp;#39;&lt;/span&gt;: &lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-8" title="8"&gt;      &lt;span class="st"&gt;&amp;#39;constraint&amp;#39;&lt;/span&gt;: &lt;span class="kw"&gt;lambda&lt;/span&gt; x: is_normal_dist(x)},&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-9" title="9"&gt;     {&lt;span class="st"&gt;&amp;#39;pattern&amp;#39;&lt;/span&gt;: &lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;,&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-10" title="10"&gt;      &lt;span class="st"&gt;&amp;#39;constraint&amp;#39;&lt;/span&gt;: &lt;span class="kw"&gt;lambda&lt;/span&gt; x: is_normal_dist(x)}&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-11" title="11"&gt;     ),&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-12" title="12"&gt;    (NormConvOp(), &lt;span class="st"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, &lt;span class="st"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;)),)&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-13" title="13"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-14" title="14"&gt;norm_conv_opt_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.gof.opt.EquilibriumOptimizer(norm_conv_pat_tt,&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-15" title="15"&gt;                                                   max_use_ratio&lt;span class="op"&gt;=&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;)&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-16" title="16"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-17" title="17"&gt;Z_fgraph_tt &lt;span class="op"&gt;=&lt;/span&gt; tt.gof.fg.FunctionGraph([X_rv, Y_rv], [Z_rv])&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-18" title="18"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-19" title="19"&gt;&lt;span class="co"&gt;# We lose the `FreeRV.distribution` attribute when cloning the graph&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-20" title="20"&gt;&lt;span class="co"&gt;# with `theano.gof.graph.clone_get_equiv` in `FunctionGraph`, so this&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-21" title="21"&gt;&lt;span class="co"&gt;# hackishly reattaches that information:&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-22" title="22"&gt;_ &lt;span class="op"&gt;=&lt;/span&gt; [&lt;span class="bu"&gt;setattr&lt;/span&gt;(g_in, &lt;span class="st"&gt;&amp;#39;distribution&amp;#39;&lt;/span&gt;, s_in.distribution)&lt;/a&gt;
&lt;a class="sourceLine" id="cb21-23" title="23"&gt;     &lt;span class="cf"&gt;for&lt;/span&gt; s_in, g_in &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;zip&lt;/span&gt;([X_rv, Y_rv], Z_fgraph_tt.inputs)]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb22"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb22-1" title="1"&gt;&lt;span class="cf"&gt;with&lt;/span&gt; conv_model:&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-2" title="2"&gt;    _ &lt;span class="op"&gt;=&lt;/span&gt; norm_conv_opt_tt.optimize(Z_fgraph_tt)&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-3" title="3"&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb22-4" title="4"&gt;norm_conv_var_dist &lt;span class="op"&gt;=&lt;/span&gt; Z_fgraph_tt.outputs[&lt;span class="dv"&gt;0&lt;/span&gt;].distribution&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The resulting graph:&lt;/p&gt;
&lt;div class="sourceCode" id="cb23"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb23-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; tt.printing.debugprint(Z_fgraph_tt)&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-2" title="2"&gt;NormConvOp [&lt;span class="bu"&gt;id&lt;/span&gt; A] &lt;span class="st"&gt;&amp;#39;X+Y&amp;#39;&lt;/span&gt;   &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-3" title="3"&gt; &lt;span class="op"&gt;|&lt;/span&gt;X [&lt;span class="bu"&gt;id&lt;/span&gt; B]&lt;/a&gt;
&lt;a class="sourceLine" id="cb23-4" title="4"&gt; &lt;span class="op"&gt;|&lt;/span&gt;Y [&lt;span class="bu"&gt;id&lt;/span&gt; C]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the convolution’s parameters (for the test values):&lt;/p&gt;
&lt;div class="sourceCode" id="cb24"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;a class="sourceLine" id="cb24-1" title="1"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="bu"&gt;print&lt;/span&gt;(norm_conv_var_dist.mu.tag.test_value)&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-2" title="2"&gt;[ &lt;span class="fl"&gt;2.&lt;/span&gt;]&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-3" title="3"&gt;&lt;span class="op"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="bu"&gt;print&lt;/span&gt;(norm_conv_var_dist.sd.tag.test_value)&lt;/a&gt;
&lt;a class="sourceLine" id="cb24-4" title="4"&gt;[ &lt;span class="fl"&gt;2.06155281&lt;/span&gt;]&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;More sophisticated routines–like the example above–could implement parameter expansions, efficient re-parameterizations and equivalent scale mixture forms in an effort to optimize a graph for sampling or point evaluation. Objectives for these optimizations could be straightforward and computationally based (e.g. reducing the number of operations in computations of the log likelihood and other quantities) or more statistically focused (e.g. highly efficient sampling, improve mixing). These ideas are most definitely not new–one example is given by &lt;span class="citation" data-cites="mohasel_afshar_probabilistic_2016"&gt;Mohasel Afshar (2016)&lt;/span&gt; for symbolic Gibbs sampling, but we hope the examples given here make the point that the tools are readily available and quite accessible.&lt;/p&gt;
&lt;p&gt;We’ll end on a much more spacey consideration. Namely, that this is a context in which we can start experimenting rapidly with objectives over the space of estimation routines. This space is generated by–but not limited to–the variety of symbolic representations, re-parameterizations, etc., mentioned above. It does not necessarily require the complete estimation of a model at each step, nor even the numeric value of quantities like the gradient or Hessian. It may involve them, but not their evaluation; perhaps, instead, symbolic comparisons of competing gradients and Hessians arising from different representations. What we’re describing lies somewhere between the completely numeric assessments common today, and the entirely symbolic work found within the theorems and manipulations of the mathematics we use to derive methods.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="bibliography" class="level1 unnumbered"&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;div id="refs" class="references"&gt;
&lt;div id="ref-combettes_proximal_2011"&gt;
&lt;p&gt;Combettes, Patrick L, and Jean-Christophe Pesquet. 2011. “Proximal Splitting Methods in Signal Processing.” &lt;em&gt;Fixed-Point Algorithms for Inverse Problems in Science and Engineering&lt;/em&gt;, 185–212.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-donoho_compressed_2006"&gt;
&lt;p&gt;Donoho, David L. 2006. “Compressed Sensing.” &lt;em&gt;IEEE Transactions on Information Theory&lt;/em&gt; 52 (4): 1289–1306. &lt;a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1614066"&gt;http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1614066&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-mohasel_afshar_probabilistic_2016"&gt;
&lt;p&gt;Mohasel Afshar, Hadi. 2016. “Probabilistic Inference in Piecewise Graphical Models.” &lt;a href="https://digitalcollections.anu.edu.au/handle/1885/107386"&gt;https://digitalcollections.anu.edu.au/handle/1885/107386&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-parikh_proximal_2014"&gt;
&lt;p&gt;Parikh, Neal, and Stephen Boyd. 2014. “Proximal Algorithms.” &lt;em&gt;Foundations and Trends in Optimization&lt;/em&gt; 1 (3): 123–231. &lt;a href="https://doi.org/10.1561/2400000003"&gt;https://doi.org/10.1561/2400000003&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-park_bayesian_2008"&gt;
&lt;p&gt;Park, Trevor, and George Casella. 2008. “The Bayesian Lasso.” &lt;em&gt;Journal of the American Statistical Association&lt;/em&gt; 103 (482): 681–86. &lt;a href="http://amstat.tandfonline.com/doi/abs/10.1198/016214508000000337"&gt;http://amstat.tandfonline.com/doi/abs/10.1198/016214508000000337&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-polson_proximal_2015"&gt;
&lt;p&gt;Polson, Nicholas G., James G. Scott, and Brandon T. Willard. 2015. “Proximal Algorithms in Statistics and Machine Learning.” &lt;em&gt;Statistical Science&lt;/em&gt; 30 (4): 559–81. &lt;a href="http://projecteuclid.org/euclid.ss/1449670858"&gt;http://projecteuclid.org/euclid.ss/1449670858&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-polson_statistical_2015"&gt;
&lt;p&gt;Polson, Nicholas G., Brandon T. Willard, and Massoud Heidari. 2015. “A Statistical Theory of Deep Learning via Proximal Splitting.” &lt;em&gt;arXiv Preprint arXiv:1509.06061&lt;/em&gt;. &lt;a href="http://arxiv.org/abs/1509.06061"&gt;http://arxiv.org/abs/1509.06061&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-rocklin_mathematically_2013"&gt;
&lt;p&gt;Rocklin, Matthew. 2013. “Mathematically Informed Linear Algebra Codes Through Term Rewriting.” PhD thesis, PhD Thesis, August. &lt;a href="http://people.cs.uchicago.edu/~mrocklin/storage/dissertation.pdf"&gt;http://people.cs.uchicago.edu/~mrocklin/storage/dissertation.pdf&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-salvatier_probabilistic_2016"&gt;
&lt;p&gt;Salvatier, John, Thomas V. Wiecki, and Christopher Fonnesbeck. 2016. “Probabilistic Programming in Python Using PyMC3.” &lt;em&gt;PeerJ Computer Science&lt;/em&gt; 2 (April): e55. &lt;a href="https://peerj.com/articles/cs-55"&gt;https://peerj.com/articles/cs-55&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="ref-srivastava_dropout_2014"&gt;
&lt;p&gt;Srivastava, Nitish, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. 2014. “Dropout: A Simple Way to Prevent Neural Networks from Overfitting.” &lt;em&gt;The Journal of Machine Learning Research&lt;/em&gt; 15 (1): 1929–58. &lt;a href="http://dl.acm.org/citation.cfm?id=2670313"&gt;http://dl.acm.org/citation.cfm?id=2670313&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;script type="text/x-mathjax-config"&gt;
MathJax.Hub.Config({
  CommonHTML: { linebreaks: { automatic: true } },
  "HTML-CSS": { linebreaks: { automatic: true } },
  SVG: { linebreaks: { automatic: true } },
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</content></entry></feed>